<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot深入分析学习]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%88%86%E5%B8%83%E5%BC%8F%2FSpringBoot%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[其实在17年入职目前公司的时候就已经接触了SpringBoot,当时公司重构代码，组长决定通过SpringBoot构建微服务架构，在会议室里面深入讲了一下微服务相关概念，当时也不是很懂，后来觉得SpringBoot就是为微服务所准备的，可以通过main函数运行。但其实SpringBoot版本发行是在2005年，而微服务这种概念的提出是在06年。本篇博客主要通过官网文档像大家介绍一下SpringBoot的基本概念。 基本概念SpringBoot是Spring家族中的一份子。在官网中的概念如下所示: 1234Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;.We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss.Most Spring Boot applications need very little Spring configuration. Spring Boot可以简单的创建单机的，生产级别的Spring应用使你可以直接运行。我们采取一个Spring平台固化视图和三方包，你可以更加轻量级的运行。大多数SpringBoot应用需要需要很少的Spring 配置。 通过上述概念可以说明的是Spring Boot创建的还是一个Spring的应用。并且Spring Boot更加轻量级，传统的Spring Boot de的配置很麻烦，要去关注各个三方应用的版本等问题。在Spring Boot中通过减少或者可以不用XML进行配置应用。通过自动装配等功能轻量级的开始一个应用。传统的Spring应用虽然功能很强大，但是并不是一个容器，它的生命周期还是通过Tomcat来完成的，而Spring Boot内嵌容器，使得生命周期可以自己去进行控制。 特性官网中对Spring Boot的特性描述如下： 1234567891011- Create stand-alone Spring applications- Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)- Provide opinionated &apos;starter&apos; dependencies to simplify your build configuration- Automatically configure Spring and 3rd party libraries whenever possible- Provide production-ready features such as metrics, health checks and externalized configuration- Absolutely no code generation and no requirement for XML configuration 创建单机的Spring应用。注意Spring Boot创建的还是Spring的应用。 内嵌Tomcat、Jetty可以直接运行，不需要去构建War包。内嵌容器可以更加方便构建Spring应用。并不是说内嵌容器的方式比通过打包使用脚本的方式效率或者速度更快。 提供’start’依赖去简化构建配置。 尽可能自动配置Spring和第三方库 提供生成级别的应用例如指标，运行状况检查和外部化配置 绝对没有代码生成也不需要XML配置。]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>distributed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis简介]]></title>
    <url>%2F2019%2F01%2F21%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2FRedis%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[缓存是互联网公司基本技术之一，使用缓存主要有两点好处，高性能和高并发，高性能是指可以把一些经常查询基本不变耗时的数据，放在缓存中，可以减少对数据库的依赖。在高并发的情况下，mysql的数据库可能会挂机。这种情况下可以将数据放到缓存中来应对高峰期高并发。 redis与memcached区别从下面几个方面来归纳总结redis和memcached的区别 数据类型memcached只支持string类型的数据存储，redis支持string，hash，list，set，zset五种数据类型。 数据持久化Redis通过RDB和AOF两种方式支持数据的持久化，而memcached不支持持久化。 分布式Redis通过一主多从的方式实现分布式。 memcached不支持分布式，只能通过客户端使用一致性哈希来实现分布式存储方式，这种方式在存储和查询时都需要在客户端计算一次数据所在的节点。 内存管理机制在Redis中，会将value值存储在磁盘中，内存中存储key的值，而memcached会将所有的数据都保存在内存中。 Redis为什么是单线程还支持高并发： 主要有三点支持高并发，首先Redis是基于内存操作，其效率很高，其次Redis是基于非阻塞的IO多路复用机制NIO，最后使用单线程可以避免上下文切换。 Redis的五种数据类型Redis共支持五种数据类型，以下会从每种的数据结构，底层的数据类型和使用场景进行详细的说明 String字符串类型底层数据结构：String类型通过int和SDS(simple dynamic string)作为结构存储，其中int存储整数类型的数据，SDS存储字节/字符串和浮点型数据。 应用场景：普通的key/value存储都可以归为此类 12345set &quot;test&quot; testget &quot;test&quot;del &quot;test&quot; hash类型底层数据结构：数据量小的时候用ziplist,另外一种是hashtable。 应用场景：整体看作一个对象，每一个field - value相当于对象的属相和属性值。例如存储用户信息对象数据，包括用户ID,用户姓名，年龄和生日，通过ID我们希望获取用户的姓名年龄和生日。 123456789HSET userInfo1 username &apos;tom&apos; HSET userInfo1 password &apos;123456&apos; hmset name &quot;qiutiangang&quot;hgetall namehdel name list列表类型底层数据结构：before3.2 当list元素个数和单个元素长度比较小的时候，采用ziplist否则用linkedlist结构，after3.2 底层用quickList来实现。linkedlist在插入节点上时间复杂度低但内存开销比较大。ziplist存储在连续的内存上，存储率比较高。但是插入和删除都需要频繁的申请和释放内存。quicklist仍是双向链表，只每一个节点是ziplist。 quicklist ==&gt; linkedlist + ziplist 应用场景：列表类型可以存储一个有序的字符串列表，常用的操作是向列表的两端添加元素或者获取列表的某一个片段。列表的内部使用一个双向链表实现，所以向列表两端添加元素的时间复杂度是o(1)，获取越接近两端的元素就越来越快。这意味着即使几千万的元素，获取前几条元素也很快。可以应用与twitter的关注列表，粉丝列表。 12345Lpush testList qiutiangangLpop testListlrange testlist 0 10 set集合底层数据结构:当set找那个只包含整数型元素时采用intset来存储。否则炒菜用hashtable来存储，对于set来说，该hashtable的value值用于null，通过key来存储元素。 应用场景：与list类似是一个列表功能。set是自动排重的 123sadd testSet aasmembers testSet zset有序集合底层数据结构：采用ziplist或者hashtable 应用场景：有序自动排重列表 1zadd testZ a Redis的持久化方式Redis支持两种方式的持久化，一种是RDB方式、另一种是AOF（append-only-ﬁle）方式。前者会根据指定的规则“定时”将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来。两种持久化方式可以单独使用其中一种，也可以将这两种方式结合使用。 RDB方式当符合一定条件时，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，等到持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方 式要比AOF方式更加的高效。RDB的缺点是后一次持久化后的数据可能丢失。 AOF方式当使用Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能。 Redis的内存淘汰策略Redis的内存淘汰侧罗是指在Redis的用于缓存内存不足时，怎么处理需要重新申请额外的空间数据： no-envicition:当内存不足以容纳新写入的数据时，写入操作会报错。 allkeys-Iru:当内存不足以容纳新写入数据时，在键空间找那个，移除最少使用的key. allkeys-random:当内存不足以容纳新写入的数据时，在键空间中，随机移除某个key。 volatile-Iru:当内存不足以容纳新写入的数据时。在设置过期的时间的键空间中，移除最少使用的key。 volatile-random:当内存不足以容纳新写入的数据时，在设置过期时间的键空间中，随机移除某个key。 volatile-ttl:当内存空间不足以容纳新写入的数据时，在设置过期时间的键空间中，有更早过期时间的key优先移除 Redis过期策略将Redis中的Key设置过期可以通过以下过期策略： 定时过期：每个设置过期时间的Key都需要创建一个定时器，到过期时间会立即清除，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的时间和吞吐量。 惰性过期：只有当访问一个Key时，才会判断Key是否已经过期。过期则清除。该策略最大化节省了CPU资源，却对内存非常不友好，极端情况下可能出现大量的key没有被访问，从而不会清除占用大量内存。 定期过期：每隔一段时间会扫描一定数量的数据库expires字典中的key，并清除其中已经过期的Key。 Redis使用了惰性过期和定时过期两种过期策略 Redis的高可用和高并发在分布式的环境中，要保证系统的高可用和高并发，就需要部署集群。Redis的高可用采用主从模式，一主多从，每个实例都容纳完整的数据。在保证高并发的情况下，还需要容纳大量的数据，这时就需要将Redis部署集群模式。保证系统的高可用，是在部署主从模式之上加哨兵机制。就可以实现，任何一个实例宕机，自动会进行主备之间切换。 哨兵模式将Redis部署为主从模式，如果master服务器宕机之后，可以手动的将slave服务器切换为mater服务器。这种人工切换的方式会使服务在一定时间内导致不可用。因此可以使用哨兵模式来完成。 哨兵是一个独立的进程，其原理是通过哨兵进行来进行对Redis实例发送消息，等待响应，从而监控运行的Redis实例。当master服务宕机之后，会自动将slave服务器切换为master服务器，并通过发布订阅模式通知其他服务修改配置。]]></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>database，redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2018%2F12%2F17%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[阿里巴巴开发手册中有一条关于使用线程的规定：123【强制】线程资源必须由线程池来提供，不允许在应用中显示的创建线程 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。 如果不使用用线程池，有可能造成系统创建大量同类线程而导致系统消耗完内存或者“过度切换”的问题。 使用线程有如下几个好处： 线程是稀缺资源，不能频繁的创建 解耦作用，将线程的创建与执行分开操作。 提高线程的可管理性。 线程池的实现原理当提交一个新的任务到线程池时，线程池的处理流程如下： 线程池判断核心线程池是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程。 线程池判断工作队列是否已经满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里，如果工作队列满了，则进入下一个流程。 线程池判断线程池是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务。 线程池ThreedPoolExecutor参数简介四个构造函数 12345678910111213141516171819202122232425262728293031//五个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)//六个参数的构造函数-1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)//六个参数的构造函数-2public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)//七个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) int corePoolSize ==&gt; 该线程池中核心线最大值 当一个任务被提价到线程池中，如果线程池中最大线程数小于核心线程池时，则创建核心线程，如果超过corePoolSize并小于最大线程数，则新建非核心线程。在默认情况下，核心线程在闲置的情况下不会被销毁。但是如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉。 int maximumPoolSize ==&gt; 该线程池中线程最大总数 线程总数 = 核心线程 + 非核心线程。 long keepAliveTime ==&gt; 非核心线程闲置超时时间 如果非核心线程闲置时间超过该设置的时间，则会被销毁。如果设置allowCoreTreadTimeOut,则会作用于核心线程。 BlockingQueue workQueue ==&gt; 工作队列 当一个任务被提交到线程池中，如果线程数超过核心线程数，则会被提交的工作队列中，如果工作队列中线程数超过最大值时，则会创建非核心线程执行该任务。 向ThreadPoolExecutor添加任务可以使用两个方法向线程池来提交任务，分别是execute()和submit()方法。 execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。 12345threadsPool.executor(new Runnable()&#123; public void run() &#123; //TODO &#125;&#125;) submit()方法用于提交需要返回值的任务。线程吃会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 1Future&lt;Object&gt; future = executor.submit(harRetureValuetask) 关闭线程池可以通过调用线程池的shutdown或者shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt放啊发来中断线程，所以无法响应中断的任务可能永远无法终止。 常见的四种线程池Excutors是Java提供管理线程池的类，改类的两个作用，控制数量和重用线程，通过该类主要有四种线程池的实现方式，这四种线程池底层主要是使用ThreadPoolExcutors类。 CacheThreadPool该线程池内部没有核心线程，线程池的数量没有限制，在创建线程时，若有空闲的线程则服用空闲的线程，若没有则创建新的线程，闲置状态的线程超过了60s没有被使用则会销毁。 1ExecutorService excutor = Executors.newCachedThreadPool(); FixedThreadPool该线程池的最大线程数等于核心线程数，在默认的情况下，该线程池的线程不会为闲置状态超时而被销毁。 1ExecutorService excutor = Executors.newFixedThreadPool(2); SingleThreadPool有且只有一个工作线程执行任务，所有的线程遵循队列的执行规则。 1ExecutorService excutor = Executors.newSingleThreadExecutor(); ScheduledThreadPool不仅设置了核心线程数，最大线程数也是Integer.MAX_VALUE。这个线程池时上述四个中唯一一个有延迟执行和周期执行任务的线程池。 1ExecutorService excutor = Executors.newScheduledThreadPool(1); 线程池隔离 线程池看似很美好，但是也会带来一些问题。 如果我们很多业务都依赖于同一线程池，其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。 这样其他业务就不能运行，这种情况对系统的打击是巨大的。 所以我们需要将线程池进行隔离。通常的做法是根据业务来进行划分： 1比如下单业务使用一个线程池，获取数据的任务使用一个线程池，这样即使一个任务将线程池的资源消耗尽，也不会对其他任务产生影响。 hystrix 隔离这样的需要hystrix已经帮我们实现了。 hystrix是一款开源的容错插件，具有依赖隔离，系统降级容错等功能。]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>thread</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程原理与实例]]></title>
    <url>%2F2018%2F11%2F22%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91%2FJAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[本篇博客详细介绍Java多线程的基本原理与并发知识。参考博客https://github.com/CyC2018 线程状态线程状态如下图所示，共有线程新建、可运行、阻塞、无限期等待、限期等待和终止五种状态。 新建（New）线程的新建状态是指创建之后未使用。 可运行（Runnable）线程的可运行状态指的是可能正在运行，也可能正在等待CPU时间片。 阻塞（Blocked）等待获取排它锁，如果其他线程释放锁便会结束此状态。 无限期等待等待其他线程显式的唤醒，否则不会分配时间片。 进入方法 退出方法 没有设置TImeout参数的Object.wait() Object().notify()和Object().notifyAll() 没有设置Timeout参数的Object.join() 被调用的线程执行完毕 限期等待无需等待其他线程显示的唤醒，在一定时间之后会被系统自动的唤醒。 调用Thread.sleep()方法使线程进入限期等待状态，用“使一个线程睡眠”来进行描述。 调用Object.wait()方法是线程进入限期等待状态，用“使一个线程挂起”来进行描述。 睡眠和挂起用来描述行为，而阻塞和等待用来描述状态。 阻塞和等待的区别为，阻塞是被动的，它是等待获取一个排它锁，而等待是主动的。通常调用Thread.sleep()或者Object.wait()方法进入 进入方法 退出方法 使用Thread.sleep()方法 时间结束 设置Timeout参数的Thread.join()方法 时间结束/被调用的线程执行完毕 设置Timeout参数的Object.wait()方法 时间结束/Object.notify()/Object.notifyAll() 终止线程执行完毕或者产生异常而结束。 线程的实现方法有三种实现线程的方法 实现Runnable接口 实现Callable接口 继承Thread类 实现Runnable接口或者实现Callable接口的类只能当做可以在线程中运行的任务，而不是真正的线程。最后还需要Thread类来调用。 实现Runnable接口12345678910111213141516public class AIMain &#123; public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread t = new Thread(instance); t.start(); &#125;&#125;class MyRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;创建线程&quot;); &#125;&#125; 实现Callable接口与Runnable接口相比，Callable接口有返回值，返回值通过FutureTask进行封装。 1234567891011121314151617181920public class AIMain &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; MyCallable instance = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(instance); Thread t = new Thread(ft); t.start(); System.out.println(ft.get()); &#125;&#125;class MyCallable implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; return 123; &#125; &#125; 继承Thread类1234567891011121314public class AIMain &#123; public static void main(String[] args) &#123; MyThread t = new MyThread(); t.start(); &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; System.out.println(&quot;创建线程&quot;); &#125;&#125; 线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其他部分之前完成。那么就需要对线程进行协调。 join()在线程中调用另一个线程join()方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于下面的程序来说，在线程B中，调用了a.join()方法，所以在执行时，即使B线程先执行，但是也要等线程a执行完毕之后再执行线程b。123456789101112131415161718192021222324252627282930313233343536public class AIMain &#123; public static void main(String[] args) &#123; JoinExample joinExample = new JoinExample(); joinExample.test(); &#125;&#125;class JoinExample &#123; private class A extends Thread &#123; public void run() &#123; System.out.println("A"); &#125; &#125; private class B extends Thread &#123; private A a; B (A a) &#123; this.a = a; &#125; public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("B"); &#125; &#125; public void test() &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125; wait()、notify()和notifyAll()调用wait()使得线程等待某个条件满足，线程在等待时会挂起，当其他线程运行使得这个条件满足时，其他线程会调用notify()或者notifyAll()来唤醒被挂起的线程。 它们都属于Object的一部分，而不属于Thread()。 使用wait()挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么对象就无法进入同步方法或者同步控制块中，那么就无法执行notify()或者notifyAll()来唤醒挂起的线程，造成死锁。 123456789101112131415161718192021222324public class AIMain &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitNotifyExample we = new WaitNotifyExample(); executorService.execute(() -&gt; we.after()); executorService.execute(() -&gt; we.befor()); &#125;&#125;class WaitNotifyExample &#123; public synchronized void befor() &#123; System.out.println("before"); notifyAll(); &#125; public synchronized void after() &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("after"); &#125;&#125; 实例说明死锁代码1234567891011121314151617181920212223242526272829303132333435363738394041public class DeadLock &#123; private static String s1 = "s1"; private static String s2 = "s2"; public static void main(String[] args) &#123; // 线程a先锁住变量s1,然后锁住变量s1 Thread a = new Thread(() -&gt; &#123; try &#123; while (true) &#123; synchronized(s1) &#123; System.out.println(Thread.currentThread().getName() + "锁住变量s1"); synchronized(s2) &#123; System.out.println(Thread.currentThread().getName() + "锁住变量s2"); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); // 线程b先锁住变量s2,然后锁住变量s1 Thread b = new Thread(() -&gt; &#123; try &#123; while (true) &#123; synchronized(s2) &#123; System.out.println(Thread.currentThread().getName() + "锁住变量s2"); synchronized(s1) &#123; System.out.println(Thread.currentThread().getName() + "锁住变量s1"); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); a.start(); b.start(); &#125;&#125;]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>thread</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程常见概念]]></title>
    <url>%2F2018%2F10%2F22%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[本篇博文主要记录了各种并发概念，参考《JAVA并发编程的艺术》。 指令重排在执行程序时，为了提高性能，处理器和编译器常常会对指令进行重新排序，排序时要遵循两个规则：在单线程的环境下不能改变程序运行的结果、存在数据依赖关系的不可以指令重排。这两个规则可以总结为不能通过happen-before原则推导出来，JMM允许任意指令重排。 as-if-serial:所有的操作都可以为了优化而重排序，但是必须保证重排序的执行的结果不能改变。as-if-serial只保证单线程，多线程环境下无效。 as-if-serialA和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B前面。但是A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。 happens-before由于我们就所有的场景来规定某个变量修改的变量何时对其他线程可见，我们可以指定某些规则，这些规则就是happens-before。在JMM中，如果一个操作的结果对另一个操作的结果可见，那么这两个操作之间必定存在happens-before关系。happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。依靠这个原则，我们可以解决在并发环境下两操作之间是否可能存在冲突的所有问题。 happens-before原则的定义如下： 如果一个操作happens-before另一个操作，那么第一个操作的结果对于第二个操作结果可见，而且第一个操作的顺序排在第一个操作顺序之前。 两个操作之间存在happens-before关系，并不一定要按照happens-before原则指定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种排序结果不非法。 下面是happens-before的原则规则： 程序次序规则：一个线程内，按照代码的顺序，书写前面的操作先发生与书写在后面很的操作。 锁定规则：一个unlock操作先行发生与后面对同一个锁的unlock操作。 volatile变量规则：对于变量的写操作先行发生于对这个变量的读操作。 传递规则：如果操作A先行发生于操作B,而操作B又先行发生于操作C,则可以得出操作A先发生于操作C、 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 线程中断规则：对线程的interrupt()方法的调用先行发生与被中断线程的代码检测到中断事件的发生。 线程终结规则：线程中的所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()返回值手段检测到线程已经终止执行。 对象终结规则：一个对象初始化完成先行发生于它的finalize()方法的开始。 synchronized和volatile比较synchronized实现原理Java中的每一个对象都可以作为锁，具体表现为以下三种形式。 对于普通的同步方法，锁是当前的同步对象。 对于静态同步方法，锁是当前类的class对象。 对于同步方法块，锁是synchronized括号里面配置对象。 JVM基于进入和退出Monitor对象来实现方法的同步和代码块的同步，但是两者的实现细节不一样。代码块的同步是使用monitorenter和monitorexit指令实现的，方法的实现是使用另一种方式实现的，但是可以同样使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块开始的位置，而monitorexit是插入到方法的结束处和异常处。任何对象都有一个monitorenter与之相关联，当一个monitor被持有后，它将处于锁定状态，线程执行到monitorenter指令时，将会尝试获取对象锁对应的monitor的所有权，即尝试获取对象的锁。 synchronized作用域 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号括起来的代码，作用的对象时调用这个代码块的对象。 修饰一个方法，被修饰的方法被称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象。 修饰一个静态的方法，作用的范围是整个静态的方法，作用的对象是这个类的所用对象。 修饰一个类，其作用的范围是synchronized后面括起来的部分，作用的对象是这个类的所用对象。 锁的四种状态synchronized在JSK1.6之后为了减少获取锁和释放锁，引入了偏向锁和轻量级锁，使得synchronized变得不那么重，所以锁的状态一共有四种 ==》 无锁状态、偏向锁、轻量级锁、重量级锁。锁的状态只升级不能降级 无锁状态无锁状态是指不对资源进行锁定，所有线程都可以访问，但只有一个线程可以修改成功。 偏向锁偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 轻量级锁CAS 重量级锁升级为重量级锁之后等待的线程会阻塞 volatile 实现原理 使得变量更新变得具有可见性，只要被volatile关键字修饰的变量的赋值一旦发生变化就会通知到其他线程，其他线程会放弃副本拷贝的值，主动去主内存进行拷贝。 产生内存屏障，防止指令进行重排序。 volatile 和 synchronized的区别 Volatile 的本质是告诉JVM当前变量是不确定的，需要从主存中获取。synchronized.synchronized 是锁定变量，只有当前线程可以访问。 Volatile 仅能使用变量级别。synchrnized 则是锁定当前变量，方法。 Volatile 不会造成线程的阻塞，synchronized会造成线程的阻塞。 怎么实现所有的线程在等待某个事件的发生才会去执行 读写锁：主线程先获取写锁，所有的子线程获取读锁，等待线程发生时主线程释放写锁。 countDownLatch countDownLatch初始值设置为1，所有的子线程调用await方法等待，等事件发生时调用countDown方法计数减为0。 synchronized和lock有什么区别 首先synchronized是java内置关键字，在jvm层面，Lock是个java类。 synchronied无法判断是否获取锁的状态，Lock可以判断是否获取到锁。 synchronized会自动释放锁（a:线程执行完会自动释放锁 b:线程执行遇到异常时会自动释放锁），Lock需要在finally中手动释放锁，否则会造成线程死锁。 用synchronized关键字的两个线程1和线程2，如果线程1获得锁或者线程1阻塞，线程2则会一直等待下去。而lock锁不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。 synchronized锁可重入，不可中断，非公平。而lock锁可重入，可中断，可公平。 Lock锁适合大量同步的代码同步问题，而synchronized锁适合代码少量同步问题。 CAS(无锁算法)对于多线程编程问题，为了保证多个线程对同一对象进行访问时，我们需要加同步锁synchronized，保证对象在多线程环境下使用正确性，但是加锁会导致如下两个问题1. 加锁和释放锁会导致上下文切换，引起性能问题。2. 多线程可以导致死锁问题。 独占锁（悲观锁）：在整个处理过程当中将数据处于锁定状态，它指的是数据被外界修改保持悲观状态，synchronized就是一种独占锁，它会导致所有需要此锁的线程挂起，等待锁的释放。 乐观锁：相对于悲观锁而言，乐观锁假设一般情况下不会造成冲突，在数据进行提交更新的情况下才会正式对数据的冲突与否进行检测，如果发现数据冲突则让用户决定如何去做。 CAS的机制就相当于这种（非阻塞算法），CAS由cpu内部硬件实现，执行速度较快，CAS有三个操作参数：内存地址，旧值，新值，操作时比较旧值有没有发生变化，如果没有发生变化就交换新值，没有发生变化则不交换。 CAS实现原子操作的三大问题： ABA问题: CAS操作值的时候，会检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成B,后又变成A,那么使用CAS进行检查时发现它的值没有发生变化，实际上却发生了变化，可以用版本号进行解决。 循环的时间长开销比较大。 只能保证一个共享变量的原子操作。 CountDownLatch和CyclicBarrier简介CountDownLatchCountDownLatch的构造函数接受一个int的参数作为构造器，如果想等待n个完成就需要传入参数为n。当调用countDownLatch的countDown方法时，n就会减1，countDownLatch的await方法会阻塞当前线程，直到n变为0 1234567891011121314151617181920212223242526272829303132public class AIMain &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch count = new CountDownLatch(2); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread() + "正在执行"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count.countDown(); System.out.println(Thread.currentThread() + "执行完毕"); &#125;).start(); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread() + "正在执行"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count.countDown(); System.out.println(Thread.currentThread() + "执行完毕"); &#125;).start(); System.out.println("-----------"); System.out.println("waiting two thread excuted"); count.await(); System.out.println("all thread alread excuted"); &#125;&#125; 底层分析：CountDownLatch底层是基于AQS来实现的，使用一个status变量来判断是否阻塞线程，如果status不为0的情况下，调用await()方法会将当前线程阻塞，并将线程加入队列里面。当有线程调用countdown时，会将status变量减一，直到变为0。 CyclicBarrierCyclicBarrier的字面意思是可循环使用的屏障。它要做的事情就是躺一组线程达到一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续执行。线程执行await()方法后线程将减1，并进行等待。直到计数器减为0，所有调用await()方法而在等待的线程才能继续执行。CyclicBarrier和CountDownLatch的区别是CyclicBarrier的计数器可以通过reset()方法循环使用，所以它才叫循环屏障。 底层分析： 与CountDownLatch的实现方式不同，并没有直接通过AQS来实现同步功能，而是通过ReentrantLock的基础上实现的。在线程调用await()方法时，会调用Condition的await方法进入等待状态，当最后一个线程调用await()方法时，调用Condition的signalAll方法唤醒所有线程。]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>thread</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文会介绍一些数据库的系统原理，比如常见的事务概念、数据库的隔离级别等。参考博客https://github.com/CyC2018 事物事物是指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以通过Rollback进行回滚。 原子性（Atomicity）事务被看做为最小的执行单位，要么全部执行成功，要么进行事务的回滚。可以通过日志来实现，将事务的操作记录到日志中，回滚时反向执行这些日志即可。 一致性（Consistency）数据库在事务的执行前后保持一致。在一致性的状态下，所有的事务对一个数据的读取结果都是一致的。 隔离性（Isolation）每个事务都是相互隔离的。 持久性（Durability）事务一旦提交，所对数据库的修改将永久的保存在数据库当中。 隔离级别未提交读（READ UNCOMMITTED）事务在没有提交之前，数据对其他事务是可见的。 提交读（READ COMMITTED）一个事务只有在提交之后数据才对其他事务可见。 可重复读（SERIALIZABLE）保证同一个事务对一个数据的多次读取结果是相同的。 可串行读（REPEATABLE READ）强制事务串行执行。 并发一致性问题在并发环境下，事务的隔离性很难得到保证，因此会出现很多并发一致性的问题。 读脏数据T1修改数据，T2读取这个数据，之后T1撤回修改，这样就会导致T1读到的数据是脏数据 不可重复读T2读取一个数据，之后T1对这个数据进行修改，此时T2再次读取时和第一次读取的结果不一样。 幻影读T1读取一个范围的数据，T2在这个范围内插入数据，此时T1读取的结果和第一次读取的结果不同。]]></content>
      <categories>
        <category>数据存储</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F07%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文会为大家介绍几种常见的排序算法，将持续更新！ 冒泡排序法冒泡排序算法是将数组中最大的数放到最后。先比较0和1的位置上数的大小并交换，再比较2和3位置的大小并交换。代码实现如下。其平均时间复杂度为O(n^2)，最坏时间复杂度为O(n^2)。 123456789101112131415161718public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int end = arr.length - 1; end &gt; 0; end--) &#123; for (int i = 0; i &lt; end; i++) &#123; if (arr[i] &gt; arr[i+1]) &#123; swap(arr, i, i+1); &#125; &#125; &#125;&#125;public static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j];&#125; 选择排序法选择排序法是找到数组中最小的元素放到位置0上，找到第二小的数字放到1位置上，依次类推。其平均时间复杂度为O(n^2)， 最坏时间复杂度为O(n^2)。 1234567891011121314public static void selectSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; // 循环的作用是找到最小的元素 for (int j = i+1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; &#125; swap(arr, i, minIndex); &#125;&#125; 插入排序法插入排序法的核心思想是默认左边的所有元素是有序的，例如待比较的数据为7,6,9,8,5,1。将6开始抽离出来，形成7,_,9,8,5,1从7开始比较，6和7进行比较，发现7&gt;6,将7右移，形成 _,7,9,8,5,1。然后将6插入到7前面的空位。结果为6,7,9,8,5,1。然后一次进行排序。其平均时间复杂度为O(n^2)， 最坏时间复杂度为O(n^2)。 12345678910public static void insertSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i-1;j &gt;=0 &amp;&amp; arr[j] &gt; arr[j+1]; j--) &#123; swap(arr, j, j+1); &#125; &#125;&#125; 快速排序将数组中的最后一个值作为比较值，将小于X的值放大数组的左边，大于X的值放到数组的右边。 然后再将&lt;=x 的区域的最后一个值在祖册区域进行划分，右侧区域依次排序。 快排的时间复杂度最好的情况是O(Nlog2N) 最坏的情况是O(n^2) 平均时间复杂度为O(Nlog2N) 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class QuickSort &#123; public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; // 经典快排 classicSort(arr, 0, arr.length - 1); // 随机快排 &#125; public static void classicSort(int[] arr, int L, int R) &#123; if (L &lt; R) &#123; // 数组，左边界，右边界，partition的条件num int[] part = partition(arr, L, R, arr[R]); classicSort(arr, part[1] + 1, R); classicSort(arr, L, part[0] - 1); &#125; &#125; //随机快排 public static void randomSort(int arr[],int left,int right)&#123; if(left&lt;right)&#123; //随机快排就是经典快排的基础上多这一步：产生一个随机位置与最后一个位置的数交换 //从而使时间复杂度理论的长期 期望值是 :O(N*logN) swap(arr, right, left+(int)((right-left+1)*Math.random()) ); int par[] = partition(arr, left, right, arr[right]); randomSort(arr, left, par[0]-1); randomSort(arr, par[1]+1, right); &#125; &#125; // 荷兰国旗问题，小于放左边，大于放右边，等于放中间 public static int[] partition(int[] arr, int L, int R, int num) &#123; int index = L; // 当前索引位置 int less = L - 1; // 小于区域 int more = R;// 大于区域 // 当前位置一直向右推，一定会遇到大于的区域 while (index &lt; more) &#123; if (arr[index] &lt; num) &#123; // 当前位置的数与小于区域的下一个数进行交换，然后当前位置下移一位 swap(arr, index++, ++less); &#125; else if (arr[index] &gt; num) &#123; // 当前位置的数与大于区域的数继续交换，由于不知道交换过来的数的大小，所以继续比较 swap(arr, index, --more); &#125; else &#123; index++; &#125; &#125; swap(arr, more, R); return new int[]&#123;less + 1, more&#125;; &#125; public static void swap(int arr[],int i,int j)&#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125;&#125; 堆排堆数据结构为完全二叉树，完全二叉树的子节点从左到右必须依次存在。例如下面的树结构，图一不是完全二叉树，因为2没有左节点却存在右节点。不满足从左到右依次存在。图二和图三是完全二叉树。堆排的时间复杂度为 O(N*log2N) 1234567891011121314151617 1 / \ 2 3 \ 4 1 / \ 2 3 / \4 5 1 / \ 2 3 其完全二叉树的实际结构对应为一个数组，对于任意一个节点，其左节点为2i-1，其右节点为2i+1。其父节点为i-1/2。 堆排的核心思想是将首先建立一个初始堆，使堆顶的元素最大，然后将对顶的元素和最后的元素进行交换，比较其左孩子和右孩子的最大值。将最大值进行交换。然后将索引值指向最大值的位置，将左孩子重新赋值为新的索引的左孩子。重复上述过程，就完成堆排。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package algorithm;// 堆排public class HeapSort &#123; public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i); &#125; int size = arr.length; swap(arr, 0, --size); while (size &gt; 0) &#123; heapify(arr, 0, size); swap(arr, 0, --size); &#125; &#125; public static void heapInsert(int[] arr, int index) &#123; while (arr[index] &gt; arr[(index - 1) / 2]) &#123; swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; public static void heapify(int[] arr, int index, int size) &#123; int left = index * 2 + 1; while (left &lt; size) &#123; int largest = left + 1 &lt; size &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; largest = arr[largest] &gt; arr[index] ? largest : index; if (largest == index) &#123; break; &#125; swap(arr, largest, index); index = largest; left = index * 2 + 1; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static void main(String[] args) &#123; int[] arr = new int[] &#123;6, 5, 4, 5, 3&#125;; heapSort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper实现原理]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%88%86%E5%B8%83%E5%BC%8F%2FZookeeper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Zookeeper主要是解决分布式环境下服务协调问题而产生的。本文首先讨论如果实现一个Zookeeper要如何设计，然后介绍经典2pc理论，最后会介绍ZAB协议。 有关Zookeeper的设计猜想如果想要去实现Zookeeper可以考虑主要是从下面几几个方面来实现。 1：防止单点故障 如果想要防止单点故障，解决的办法就是将项目部署为高可用集群模式。高可用模式意味着集群中某个节点宕机，不影响整个集群的数据继续提供服务的可能性。一般部署集群模式都是遵循主从复制模式，但是Zookeeper没有遵循这个思路。而是将节点设置为leader、follower和oberserver三种角色，每个节点通过ZAB协议来保证数据一致性。 2：高可用的集群模式 如果要满足高可用的集群模式，需要每个节点都可以接受到数据请求，并且每个节点接受的数据请求保持一致。Zookeeper针对这种情况为每个节点分为leader、follower和oberserver三个角色。并且还需要考虑一下leader节点挂了之后的操作（zookeeper用了基于paxos理论所衍生出来 的ZAB协议）。 3：强一致性 在分布式系统中，如果想要保持强一致性，就会涉及到分布式事物。分布式事务的数据一致性协议由2pc协议和3pc协议。下面将详细介绍一下经典的2pc理论。 关于2pc提交2pc(Two Phase Commitment Protocol)当一个事务操作需要跨越多个分布式节点的时候，为了保持事务的ACID特性，需要一个协调者(TM)来统一调度所有分布式节点的执行逻辑。这些分布式节点称为AP。TM负责调度AP的行为。并且最终决定这些AP是否要把事务进行真正的提交，因为分两阶段进行提交，所以叫2PC。 阶段一：提交事务请求（投票） 1：事务询问 协调者向所有的分布式节点发送事务内容，并询问是否可以进行事务提交操作。并开始等待各参与者的反应。 2：执行事务 各个参与者执行事务操作，并且将Undo和Redo信息记录到事务操作日志中。并且尽量把提交过程中的所有消耗时间的操作和准备都提前完成，确保后面成功提交事务。 3: 各个参与者向协调者发送询问响应 如果各个参与者成功执行事务，则向协调者发送yes相应，如果参与者没有执行成功，则向协调者发送no的响应。 阶段二：提交事务 协调者会根据投票阶段各个参与者的响应去完成响应操作，要么提交事务，要么中断事务（通过undo和redo来完成）。 ZAB协议ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，主要依赖ZAB协议实现分布式数据的一致性。ZAB协议包含两种基本模式：崩溃恢复和原子广播。 崩溃恢复当整个集群启动时，或者leader节点出现网络中断、崩溃等情况时，ZAB协议就会进入到恢复模式并选举产生新的leader，当leader服务器选举出来后，并且集群中有过半的集合和该leader节点完成同步后，ZAB协议就会退出恢复模式。 崩溃恢复原理ZAB协议基于原子广播协议的，正常情况下没有任何问题，当时一旦leader节点崩溃或者由于网络问题导致leader服务器失去过半的follower节点的联系（网络分区）。那么就会进入到崩溃恢复模式，为了使leader系统可以正常工作，需要解决两个问题。 已被处理的消息不能丢失 当leaders收到合法数量的follower的ack后，就会向各个follower广播commit命令。同时也会在本地执行commit命令。并向客户端返回成功。当时如果各个follower在收到commit命令之前leader挂了，导致剩下的服务器并没有执行这条消息。比如follower1执行了，follower2还没有收到commit命令 被丢弃的消息不能再次出现 当leader接收到消息请求生成proposal（提案）后就挂了，其他follower并没有收到proposal。因此经过恢复模式。重新选举leader后，这条消息是被跳过了，此时，挂了的leader重新启动并注册了follower，保留了被跳过的proposal状态，与这整个系统状态不一致，需要删除 ZAB协议需要满足上面两种情况，就必须设计一个leader选举算法：能够确保已经被leader提交事物的proposal能够被提交，同时丢弃已经被跳过的事物proposal。针对这个要求：如果leader选举算法能够保证新选举出来的leader服务器拥有最高的编号（zxid最大）的事物proposal,那么就可以保证这个新选举出来的leader一定具有已经提交的提案。 消息广播当集群中已经有过半的follower节点和leader状态同步后，整个集群就会进入到消息广播模式。在leader正常工作时，启动一台新的服务器进入到新的集群，这个集群就会进入到数据恢复模式，和leader节点进行数据同步，同步完成后，集合正常对外处理非事务请求处理。 消息广播实现原理消息广播实际上就是一个简化版的二阶段提交。 leader接受到消息请求后，将消息赋予一个全局唯一的64位自增ID：zxid。 leader为每个follower准备FIFO队列，将带有zxid消息作为一个提案（proposal）分发给所有的follower。 当follower接收到proposal，先把proposal写到磁盘，写入成功后向leader回复一个ack。 当leader接收到合法数量的ACK后，leader就会向这些follower发送commit命令，同时在本地指向该消息。 当follower收到消息的commit命令以后，会提交该消息 leader选举leader选举分为两种情况，启动时leader选举，leader崩溃时选举 启动时leader选举集群初始化时，每一个节点都是LOOKING状态，处于观望状态，接下来就开始进入主流程。当有一台服务器server1启动时，它本身无法进行和完成leader选举，当第二台server2启动时，这两台机器可以相互通信，每个机器试图找到leader，于是进入leader选举过程： server1和server2都会将自己作为leader服务器进行投票，每次投票都会包含所推举的服务器myId和zxId,此时server1的投票为（1,0）。server2的投票为（2,0）。然后将各自投票发给其他集群机器。 接受来自各个服务器的投票 处理投票：针对每一个投票的服务器都需要将别人的投票和自己的投票PK。pk的规则如下，优先zxid，如果zxid相同则比较myid。 运行时leader选举当集群中的leader服务器出现宕机或不可用的情况下会进行leader选举。 变更状态：leader挂后，剩下的非observer服务器都会将自己的服务器状态变为LOOKING,然后开始选举 每个server都会发出一个投票，在运行期间，每个server的zxId可能不同，例如server1的zxid为123，server3的zxid为122。产生投票（1,123），（2,122） 处理投票 统计投票 改变服务器状态]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>distributed</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前面介绍了二叉搜索树，它可以支持任何一种基本动态集合的操作，其时间复杂度为O(n)。因此，如果树的高度较高时，这些操作可能不比链表上执行的快。红黑树是许多平衡搜索树的一种，可以保证最坏的情况下基本动态集合的操作的时间复杂度为O(lgn)。 红黑树性质红黑树是一颗近似平衡的二叉查找树，它能够确保任何一个节点的左右子树高度二者中最低的二倍。一棵红黑树是满足于下面的红黑性质的二叉搜索树： 每个节点要么是红色，要么是黑色。 根节点必须是黑色。 红色节点不能连续（红色节点的孩子和父亲不能是红色）。 对每个节点，从该节点到其后代节点的简单路径上，均包含相同数目的黑色节点 有了上面几个性质作为限制，即可避免了二叉查找树退化成单链表的情况。但是仅仅避免这种情况是不够的，这里还要考虑每个节点到其每个页节点的路径长度的问题。如果某些路径长度过长，那么在对这些路径上的节点进行增删查操作时，效率也会大大降低。这个时候性质四和性质五作为约束，即可保证任意节点到其每个页节点的路径的最长不会超过最短路径的二倍。原因如下： 当某条路径最短时，这条路径必然都是由黑色节点构成的。当某条路径长度最长时，这条路径必然由红色和黑色节点构成的（性质4限定了不能出现两个连续的红色节点）。而性质五又限定了从任意节点到每个页节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上的红色节点数量=黑色节点的数量。该路径长度为两倍黑色节点的数量。也就是最短路径长度的两倍。 上图画出了从根节点M出发的其页子节点的最长和最短路径，上图包含了两条最短路径，实际上最长路径有四条，分别是： M -&gt; Q -&gt; O -&gt; N M -&gt; Q -&gt; O -&gt; P M -&gt; Q -&gt; Y -&gt; Z M -&gt; Q -&gt; Y -&gt; X 最短路径为 M -&gt; E 长度为2，最长路径是最短路径的两倍。 时间复杂度红黑树的时间复杂度为O(lgn) 从某个节点x出发到达一个叶节点的任意一条简单路径上的黑色节点的个数成为该节点的黑高。 一棵有n个内部节点的红黑树的高度至多为2lg(n+1) 旋转红黑树的基本操作有插入和删除，运行时间为O(lgn)。由于这两个操作对树做了修改，可能违反红黑树的性质，通过旋转改变树中的某些节点的颜色以及指针。旋转主要分为两种情况，左旋和右旋。如下图所示： 左旋的代码如下所示（参考算法导论）： 123456789101112131415161718private void rotateLeft(Node x) &#123; Node y = x.right//设置y节点，为x的右节点 //旋转开始 x.right = y.left //x的由节点设置为y的左节点 if (y.left != null) &#123; y.left.parent = x //将y的左节点的父节点指向x &#125; y.parent = x.parent if (x.parent == null) &#123; this.root = y //如果x的父节点为空，那么y就是root节点 &#125; else if (x == x.parent.left) &#123; x.parent.left = y; &#125; else &#123; x.parent.right = y; &#125; y.left = x; x.parent = y;&#125; 下图是左旋修改红黑树例子： 左旋和右旋代码是对称的，时间复杂度为O(1),旋转过程只改变指针了指针，其他属性不变。 右旋代码实现123456789101112131415private void rotateRight(Node y)&#123; Node&lt;K&gt; x = y.left; //设置x结点，为y结点的左结点 //旋转开始 y.left = x.right; //y的左结点设置为x的右结点 if (x.right != null) x.right.parent = y; //把x右结点的父结点指向y结点 x.parent = y.parent; //把x的父结点改为y的父结点 if (y.parent == null) this.root = x; //如果y的父结点为空。那么x就是root结点 else if (y == y.parent.left) //y为它父结点的左结点 y.parent.left = x; //把y的父结点的左结点改为x结点 else y.parent.right = x; //把y的父结点的右结点改为x结点 x.right = y; //x结点的右结点为y y.parent = x; //y的父结点为x &#125; 总结 在任何一种有n的节点的红黑树中，有n-1中可能旋转。 对x进行左旋，意味着将x的由孩子变为x的父节点。左旋中的左，意味着被旋转的节点变成左节点 对y进行右旋，意味着，将y的左结点变为y的父亲结点；即将y变成了一个右节点(y成了为x的右孩子)。因此，右旋中的右，意味着被旋转的节点将变成一个右节点。 插入我们可以在O(lgn)的时间内完成向一颗n个节点的红黑树插入一个新的节点。为了做到这一点，利用二叉搜索树的insert过程中的一个略做修改的版本将节点z插入树中，为了保证红黑树的性质，我们用一个辅助的方法fixUp对节点进行重新着色并旋转。 insert方法：1234567891011121314151617181920212223private void insert(Node&lt;K&gt; z)&#123; Node&lt;K&gt; y = null; Node&lt;K&gt; x = this.root; int com; while (x != null)&#123; // 如果根结点不为空，循环比较z的key的大小 y = x; com = z.key.compareTo(x.key); if (com &lt; 0) x = x.left; else x = x.right; &#125; z.parent = y; // y是x结点的父结点，把z结点定义为y结点的子结点 if (y == null) this.root = z; //如果y为null的话，z即为root结点 else&#123; com = z.key.compareTo(y.key); if (com &lt; 0) //如果z的key小于y的key，即为左结点 y.left = z; else y.right = z;//反之为右结点 &#125; z.color = RED;//新增结点颜色定义为红色，不违反红黑树性质的第五条 fixUp(z);//做颜色上的调整 &#125; 利用fixUP做旋转和着色处理，节点初始值为红色（红色可以少违反一条性质，性质5）。123456789101112131415161718192021222324252627282930313233343536373839404142private void fixUp(Node&lt;K&gt; z)&#123; while (z.parent != null &amp;&amp; z.parent.color)&#123; //若当前z结点的父结点是红色 if (z.parent == z.parent.parent.left)&#123; //若z的父结点是z的祖父结点的左结点 Node&lt;K&gt; y = z.parent.parent.right; //定义y结点为z的祖父结点的右结点 if (y != null &amp;&amp; y.color)&#123; //case1: 如果y是红色 z.parent.color = BLACK; //z的父结点为黑色 y.color = BLACK; //z的叔叔结点为黑色 z.parent.parent.color = RED; //祖父结点为红色 z = z.parent.parent; //将祖父节点设为当前节点(红色节点) &#125;else &#123; if (z == z.parent.right)&#123; //case2: y是黑色，且当前结点为右结点 z = z.parent; //将父节点作为新的当前节点。 rotateLeft(z); //以新的当前节点为支点进行左旋。 &#125; //case3: y是黑色，且当前节点是左结点。 z.parent.color = BLACK; //设置父结点为黑色 z.parent.parent.color = RED; //祖父结点为红色 rotateRight(z.parent.parent); //以z的祖父结点为支点右旋 &#125; &#125;else &#123; //若z的父结点是z的祖父结点的右结点 Node&lt;K&gt; y = z.parent.parent.left; //定义y结点为z的祖父结点的左结点 //case1：y结点是红色 if (y.color) &#123; z.parent.color = BLACK; y.color = BLACK; z.parent.parent.color = RED; z = z.parent.parent; //将祖父节点设为当前节点(红色节点) &#125; else &#123; //case2：y是黑色，且当前节点是左结点 if (z == z.parent.left)&#123; z = z.parent; //将父节点作为新的当前节点。 rotateRight(z); //以新的当前节点为支点进行右旋。 &#125; //case3: y是黑色，且当前节点是右结点。 z.parent.color = BLACK; //设置父结点为黑色 z.parent.parent.color = RED; //祖父结点为红色 rotateLeft(z.parent.parent); //以z的祖父结点为支点左旋 &#125; &#125; &#125; this.root.color = BLACK; &#125; 下图是fixUP的工作原理： 与n个节点的红黑树的其他基本操作一样，删除一个节点要花费的时间也是O(lgn)。与插入操作相比，删除操作要更加复杂一些。从一棵红黑树中删除节点的过程是基于二叉搜索树的delete过程。同样也需要transplant子过程。 123456789private void transplant(Node&lt;K&gt; u, Node&lt;K&gt; v)&#123; if (u.parent == null) this.root = v; else if (u == u.parent.left) u.parent.left = v; else u.parent.right = v; v.parent = u.parent; &#125; delete方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void delete(Node&lt;K&gt; z)&#123; //z是被删除结点 //x是取代节点的右孩子，也是需要调整的节点。 Node&lt;K&gt; x, parent; boolean color; if ((z.left != null) &amp;&amp; (z.right != null) ) &#123; //被删除节点的左右结点都不为空的情况。 Node&lt;K&gt; y = z; //被删节点的后继节点。用它来取代被删节点的位置，然后再将被删节点去掉。 y = y.right; //获取后继节点 while (y.left != null) y = y.left; if (z.parent != null) &#123; //要删除的结点不是根结点 if (z.parent.left == z) z.parent.left = y; else z.parent.right = y; &#125; else &#123; this.root = y; //是根结点 &#125; x = y.right; parent = y.parent; //保存取代节点的颜色 color = y.color; //被删除节点是它的后继节点的父节点 if (parent == z) &#123; parent = y; &#125; else &#123; //x不为空 if (x != null) x.parent = parent; parent.left = x; y.right = z.right; z.right.parent = y; &#125; y.parent = z.parent; y.color = z.color; y.left = z.left; z.left.parent = y; if (color == BLACK) deleteFixUp(x, parent); return ; &#125; if (z.left != null) &#123; x = z.left; &#125; else &#123; x = z.right; &#125; parent = z.parent; //保存取代节点的颜色 color = z.color; if (x != null) x.parent = parent; //不是根节点 if (parent != null) &#123; if (parent.left == z) parent.left = x; else parent.right = x; &#125; else &#123; this.root = x; &#125; if (color == BLACK) deleteFixUp(x, parent); deleteFixUp方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private void deleteFixUp(Node&lt;K&gt; x, Node&lt;K&gt; parent)&#123; Node&lt;K&gt; w; while ((x == null || x.color == BLACK) &amp;&amp; (x != this.root)) &#123; if (parent.left == x) &#123; //如果x是它父结点的左结点 w = parent.right; if (w.color == RED) &#123; //case1: x的兄弟w是红色的 //因为w必须有黑色子结点，所以可以改变w和x.parent的颜色，然后对x.parent做一次左旋 w.color = BLACK; parent.color = RED; rotateLeft(parent); w = parent.right; &#125; if ((w.left == null || w.left.color == BLACK) &amp;&amp; (w.right == null || w.right.color == BLACK)) &#123; //case2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的 //因为w也是黑色，所以从x上去掉一重黑色，使x只有一重黑色而w为红色，在原来的x.parent上新增一重额外的黑色，通过将x.parent作为新的结点来重复循环实现。 w.color = RED; x = parent; parent = x != null ? x.parent : null; &#125; else &#123; if (w.right == null || w.right.color == BLACK) &#123; //case3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色 //交换w和其左孩子的颜色，然后对w进行右旋 w.left.color = BLACK; w.color = RED; rotateRight(w); w = parent.right; &#125; //case4: x的兄弟w是黑色的；并且w的右孩子是红色的 //修改w，x.parent, w.right颜色，对x.parent进行左旋，设置x为root结束循环 w.color = parent != null ? parent.color : BLACK; parent.color = BLACK; w.right.color = BLACK; rotateLeft(parent); x = this.root; break; &#125; &#125; else &#123; //x是父结点的右结点时情况和上面相反 w = parent.left; if (w.color == RED) &#123; w.color = BLACK; parent.color = RED; rotateRight(parent); w = parent.left; &#125; if ((w.left == null || w.left.color == BLACK) &amp;&amp; (w.right == null || w.right.color == BLACK)) &#123; w.color = RED; x = parent; parent = x != null ? x.parent : null; &#125; else &#123; if (w.left == null || w.left.color == BLACK) &#123; w.right.color = BLACK; w.color = RED; rotateLeft(w); w = parent.left; &#125; w.color = parent != null ? parent.color : BLACK; parent.color = BLACK; w.left.color = BLACK; rotateRight(parent); x = this.root; break; &#125; &#125; &#125; if (x != null) x.color = BLACK; &#125; 下图给出了deleteFixUp的几种情况:]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码分析]]></title>
    <url>%2F2018%2F07%2F07%2FJava%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介HashMap是线程不安全的。如果想要线程安全的HashMap可以使用Hashtable、Collections.synchronizedMap(new HashMap())或者ConcurrentHashMap。通常ConcurrentHashMap是更好的选择。Hashtable是一个遗留类，线程安全的实现过程就是在方法中使用synchronized关键字。Collections.synchronizedMap(new HashMap())是对整个Map进行加锁。而ConcurrentHashMap是对桶数组进行加锁。在JDK1.8中ConcurrentHashMap与HashMap中有相通之处。底层依然由数组链表和红黑树组成。ConcurrentHashMap在实际中借用了较多的CAS算法。例如初始化利用CAS来判断有无其他线程进行初始化，在put元素时，如果数组中的元素为null时，则直接根据CAS插入。如果hash值相同的链表的头结点，会使用synchronized上锁，这样才能保证线程安全。本文源码分析根据JDK1.8版本。 版本比较JDK1.6的实现ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层由Segment数组和HashEntry数组组成。segment继承ReentrantLock用来充当锁的角色，每个segment对象守护每个散列表的若干个桶。HashEntry用来封装映射表的键值对；每个桶是由若干个HashEntry对象连接起来的链表。一个ConcurrentHashMap实例中包含由若干个Segement对象组成的数组。如图所示。 JDK1.8中的改进取消了segement字段（segement虽然已经保留，但是为了兼容旧版本），直接采用transient volatile HashEntry table保存数据，采用table数组元素作为锁，从而实现了对每一行元素加锁，进一步减少并发冲突的概率。 将原来的table数组+单向链表的数据结构，变更为table数组+单向链表+红黑树的数据结构（和hashmap是相同的），对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中，如果hash之后散列的很均匀，那么table数组中的每个元素的队列长度主要为0或者1。单实际情况并非总是如此理想，虽然CorrentHashMap类默认的负载因子是0.75，但是在数据量大或者运气不佳的情况下，还是会存在一些队列过长。如果还是采用单向链表的方式，那么查询某个节点的时间复杂度是O(n),因此，对于个数超过8的链表，JDK1.8采用了红黑树的结构，那么时间复杂度为O(lgn)，可以改进性能。 源码分析定义12public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344 //最大的表容量。private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认的初始表容量。必须是2的幂 private static final int DEFAULT_CAPACITY = 16; //最大(两个)数组大小。 static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //此表的默认并发级别。(1.8中已经不使用了，为了兼容以前的版本) private static final int DEFAULT_CONCURRENCY_LEVEL = 16; //这个表的装载因子。 private static final float LOAD_FACTOR = 0.75f; //链表转红黑树的阀值，如果table[i]下面的链表长度大于8时就转化为树 static final int TREEIFY_THRESHOLD = 8;//红黑树转链表的阀值，小于等于6时转为链表，仅在扩容时才可能树转链表 static final int UNTREEIFY_THRESHOLD = 6;//数组可以转化为树的表的最小容量，（否则，如果一个bin中的节点太多，表将被调整大小。）该值应至少为4 * TREEIFY_THRESHOLD以避免调整大小和树化阈值之间的冲突。 static final int MIN_TREEIFY_CAPACITY = 64;//每个转移步骤的最小重新排列数。范围是细分为允许多个resizer线程。这个值作为一个下限，以避免resizers遇到内存争夺过多，该值至少应该是DEFAULT_CAPACITY。 private static final int MIN_TRANSFER_STRIDE = 16; //用来控制扩容的时候 单线程进入的变量 private static int RESIZE_STAMP_BITS = 16; //用来控制扩容的时候 单线程进入的变量 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;//可以帮助调整大小的最大线程数 private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; //节点的标识 static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash//装数据的数组，第一次插入数据的时候初始化,大小为2^n.transient volatile Node&lt;K,V&gt;[] table; //扩容时使用 private transient volatile Node&lt;K,V&gt;[] nextTable; //记录容器的容量大小(但返回的不一定是当前Map的真实元素个数)，通过CAS无锁更新 private transient volatile long baseCount;//hash表初始化或扩容时的一个控制位标识量。 //负数代表正在进行初始化或扩容操作 //-1代表正在初始化 //-N 表示有N-1个线程正在进行扩容操作 //正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小 //默认是table大小的0.75 倍，用公式0.75（n - (n &gt;&gt;&gt; 2)）计算。 private transient volatile int sizeCtl; //自旋锁（锁定通过 CAS）在调整大小和/或创建CounterCells时使用。在CounterCell类更新value中会使用，功能类似显示锁和内置锁，性能更好(在Striped64类也有应用) private transient volatile int cellsBusy; 构造方法ConcurrentHashMap共有5个构造方法，这里主要介绍第五个构造方法 1234567891011121314151617181920212223/看一下最后一个参数concurrencyLevel,表示能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; //检查参数的有效性 if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; &#125; //返回给定所需容量，table的大小总是2的幂次方 private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 上面的代码先用一系列的移位和|操作把n变成二进制表示的形式，然后右移一位，就会变成2^k了。 重要的内部类 Node Node是最核心的内部类，它包装了key-value的键值对，与HashMap的定义很相似，但是两者之间还是有一些差别，它对value和next属性设置了volatile同步锁，它不允许调用setValue()方法直接改变Node的value域，它增加了find()方法辅助map.get()方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return val; &#125; public final int hashCode() &#123; return key.hashCode() ^ val.hashCode(); &#125; public final String toString()&#123; return key + "=" + val; &#125; public final V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; public final boolean equals(Object o) &#123; Object k, v, u; Map.Entry&lt;?,?&gt; e; return ((o instanceof Map.Entry) &amp;&amp; (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp; (v = e.getValue()) != null &amp;&amp; (k == key || k.equals(key)) &amp;&amp; (v == (u = val) || v.equals(u))); &#125; /** * Virtualized support for map.get(); overridden in subclasses. */ Node&lt;K,V&gt; find(int h, Object k) &#123; Node&lt;K,V&gt; e = this; if (k != null) &#123; do &#123; K ek; if (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek)))) return e; &#125; while ((e = e.next) != null); &#125; return null; &#125; &#125; TreeNode节点 树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转化成TreeNode。但是与HashMap不同的是，它并不是直接转换成红黑树，而是把这些节点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap中继承Node类，而并非HashMap中继承子LinkedHashMap.entry类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next, TreeNode&lt;K,V&gt; parent) &#123; super(hash, key, val, next); this.parent = parent; &#125; Node&lt;K,V&gt; find(int h, Object k) &#123; return findTreeNode(h, k, null); &#125; /** * Returns the TreeNode (or null if not found) for the given key * starting at given root. */ final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) &#123; if (k != null) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; q; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.findTreeNode(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); &#125; return null; &#125;&#125; TreeBin 这个类并不负责包装用户的key,value信息，而是包装很多TreeNode节点。它代替了TreeNode的根节点，也就是实际的ConcurrentHashMap数组中，存放的是TreeBin对象，而不是Node对象，这是与HashMap的区别，另外这个类还带有读写锁。 ForwardingNode 在transfer操作中使用，一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1。这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。生命周期：仅存活于扩容操作。 主要方法 initTable 当put()方法调用table==null时会执行此方法初始化table 123456789101112131415161718192021222324252627//初始化表，使用sizeCtl中记录的大小。private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; //进入循环 while ((tab = table) == null || tab.length == 0) &#123; //如果sizeCtl&lt;0说明已经有其它线程正在进行扩容，即正在初始化或初始化完成,其它线程通过Thread.yield()让出CPU时间片，等待table非空即可。 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin //利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; //这里注意table的大小为sizeCtl table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; helpTransfer 这是扩容过程中的辅助方法。在多线程的情况下，如果发现其他线程正在扩容，则帮助转移元素（只有这种情况下会被调用）。从某种程度上来说，其优先级很高，只要检测到扩容就会放下其他工作，先扩容。 12345678910111213141516171819202122//调用这个方法之前，nextTable对象一定已经存在的。final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; //返回用于调整大小为n的表的大小的标记位。 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; //开始扩容 transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table; &#125; addCount 12345678910111213141516171819202122232425262728293031323334353637383940414243private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; //利用CAS方法把当前ConcurrentHashMap的元素个数+1 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; //多线程CAS发生失败的时候执行 fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; s = sumCount(); &#125; //如果check值大于等于0 则需要检验是否需要进行扩容操作 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); //正在进行初始化或扩容操作 if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; //如果已经有其他线程在执行扩容操作 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; //当前线程是唯一的或是第一个发起扩容的线程 此时nextTable=null else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125; &#125; transfer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings("unchecked") //构造一个nextTable对象 它的容量是原来的两倍 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; //构造一个连节点指针 用于标志位 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); //并发扩容的关键属性 如果等于true 说明这个节点已经处理过 boolean advance = true; //循环的关键变量，判断是否已经扩容完成，完成就return，退出循环 boolean finishing = false; // to ensure sweep before committing nextTab //死循环 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; //循环的关键控制i，i--操作保证了倒序遍历数组 while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; //nextIndex=transferIndex=n=tab.length(默认16) else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; //用CAS计算得到的transferIndex else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; //i&lt;0，i&gt;=n说明已经遍历完旧的数组tab，i+n&gt;=nextn说明已经扩容完成 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; //所有节点复制完毕 if (finishing) &#123; nextTable = null; table = nextTab; //扩容阈值设置为原来容量的1.5倍，相当于现在容量的0.75倍 sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; //利用CAS更新扩容阈值,sc-1表明新加入一个线程参与扩容 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; //如果有两个线程，值肯定不相等，所以直接返回（保持只有一个线程执行） if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; //finishing和advance保证线程已经扩容完成了可以退出循环 finishing = advance = true; i = n; // recheck before commit &#125; &#125; //如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); //f.hash=-1,说明该节点为ForwardingNode，说明该节点已经处理过了 else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; //把当前节点加锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //ln原位置节点，hn新位置节点 Node&lt;K,V&gt; ln, hn; //这是一个链表Node节点 if (fh &gt;= 0) &#123; int runBit = fh &amp; n; //构造两个链表，一个是原链表；另一个是原链表的反序排列 Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; //在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); //在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); //在table的i位置上插入forwardNode节点 表示已经处理过该节点 setTabAt(tab, i, fwd); //设置advance为true 返回到上面的while循环中 就可以执行i--操作 advance = true; &#125; //对TreeBin对象进行处理，与上面的过程类似 else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; //构造正序和反序两个链表 for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; //如果扩容后已经不再需要tree的结构，反向转换为链表结构 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; //在nextTable的i位置上插入一个链表 setTabAt(nextTab, i, ln); //在nextTable的i+n的位置上插入另一个链表 setTabAt(nextTab, i + n, hn); //在table的i位置上插入fwd节点，表示已经处理过该节点 setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; put方法 既然上面说的ConcurrentHashMap的构造函数不会初始化table，会延迟到第一次put，那么我们就来看看put方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public V put(K key, V value) &#123; return putVal(key, value, false); &#125;//计算hash值 static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS; &#125;//putVal操作采用CAS+synchronized实现并发插入或更新操作 final V putVal(K key, V value, boolean onlyIfAbsent) &#123; //ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键 if (key == null || value == null) throw new NullPointerException(); //算出hash值（即数组下标） int hash = spread(key.hashCode()); int binCount = 0; //死循环，直到插入成功 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //初始化table tab = initTable(); //去除tab中的节点赋值给f //如果table[i]==null(即该位置的节点为空，没有发生碰撞)，则利用CAS操作直接存储在该位置，如果CAS操作成功则退出死循环。 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; //table[i]!=null(即该位置已经有其它节点，发生碰撞) //检查table[i]的节点的hash是否等于MOVED，如果等于，则检测到正在扩容，则帮助其扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; //结点上锁 这里的结点可以理解为hash值相同组成的链表的头结点 synchronized (f) &#123; //避免多线程，需要重新检查 if (tabAt(tab, i) == f) &#123; //fh〉0 说明这个节点是一个链表的节点 不是树的节点 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //hash和key都相同 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; //如果没有找到值为key的节点，新建Node加入链表。 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //首节点为TreeBin，为红黑树结构，按照红黑树的方式插入数据。 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //如果链表长度达到阀值需要调整结构变为红黑树。 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; //将当前ConcurrentHashMap的元素数量+1，有可能触发扩容操作。 addCount(1L, binCount); return null; &#125; tryPresize 这个方法也是扩容操作。在putAll和链表转红黑树的时候使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private final void tryPresize(int size) &#123; //给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容 int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); int sc; //没有正在初始化或扩容，或者说表还没有被初始化 while ((sc = sizeCtl) &gt;= 0) &#123; Node&lt;K,V&gt;[] tab = table; int n; //没有被初始化 if (tab == null || (n = tab.length) == 0) &#123; n = (sc &gt; c) ? sc : c; //期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化 if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; //重复检查 if (table == tab) &#123; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = nt; //无符号右移2位(即0.75*n) sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; //更新扩容阀值 sizeCtl = sc; &#125; &#125; &#125; //若想要扩容的值不大于原阀值，或现有容量&gt;=最值，什么都不用做了 else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) break; else if (tab == table) &#123; //返回一个标志位 int rs = resizeStamp(n); //执行扩容操作 if (sc &lt; 0) &#123; Node&lt;K,V&gt;[] nt; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); &#125; &#125; &#125; treeifyBin 链表转红黑树的方法 123456789101112131415161718192021222324252627private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; //容量小于64，扩容 if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; &#125; //在原来index的位置，用TreeBin替换掉原来的Node对象 setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); &#125; &#125; &#125; &#125; &#125; get 上面介绍完put方法，下面看看get方法 1234567891011121314151617181920212223public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; //计算hash值 int h = spread(key.hashCode()); //根据hash值确定节点位置 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; //eh&lt;0，说明这个节点在树上，直接查找树 else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; //链表，找到对应的值并返回 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null; &#125; containsValue 查询当前ConcurrentHashMap是否包含该value值。有可能需要遍历一遍ConcurrentHashMap。 12345678910111213141516public boolean containsValue(Object value) &#123; //判断value是否为null，这里和HashMap不同 if (value == null) throw new NullPointerException(); Node&lt;K,V&gt;[] t; //如果table不为空遍历table。 if ((t = table) != null) &#123; Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length); for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) &#123; V v; if ((v = p.val) == value || (v != null &amp;&amp; value.equals(v))) return true; &#125; &#125; return false; &#125; replaceNode remove的核心方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //注意：cv才是key-value中的value！final V replaceNode(Object key, V value, Object cv) &#123; int hash = spread(key.hashCode()); for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; //该table第一个元素为空，直接跳过 if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) break; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; boolean validated = false; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; validated = true; for (Node&lt;K,V&gt; e = f, pred = null;;) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; V ev = e.val; //value为null或value和查到的值相等 if (cv == null || cv == ev || (ev != null &amp;&amp; cv.equals(ev))) &#123; oldVal = ev; if (value != null) e.val = value; else if (pred != null) pred.next = e.next; else setTabAt(tab, i, e.next); &#125; break; &#125; pred = e; if ((e = e.next) == null) break; &#125; &#125; //以树的方式find、remove else if (f instanceof TreeBin) &#123; validated = true; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; if ((r = t.root) != null &amp;&amp; (p = r.findTreeNode(hash, key, null)) != null) &#123; V pv = p.val; if (cv == null || cv == pv || (pv != null &amp;&amp; cv.equals(pv))) &#123; oldVal = pv; if (value != null) p.val = value; else if (t.removeTreeNode(p)) setTabAt(tab, i, untreeify(t.first)); &#125; &#125; &#125; &#125; &#125; if (validated) &#123; if (oldVal != null) &#123; if (value == null) addCount(-1L, -1); return oldVal; &#125; break; &#125; &#125; &#125; return null; &#125; clear 移除ConcurrentHashMap中所有的元素。 12345678910111213141516171819202122232425262728293031323334public void clear() &#123; long delta = 0L; // negative number of deletions int i = 0; Node&lt;K,V&gt;[] tab = table; while (tab != null &amp;&amp; i &lt; tab.length) &#123; int fh; Node&lt;K,V&gt; f = tabAt(tab, i); //为空，直接跳过 if (f == null) ++i; else if ((fh = f.hash) == MOVED) &#123; tab = helpTransfer(tab, f); i = 0; // restart &#125; else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; p = (fh &gt;= 0 ? f : (f instanceof TreeBin) ? ((TreeBin&lt;K,V&gt;)f).first : null); //首先删除链、树的末尾元素，避免产生大量垃圾 while (p != null) &#123; --delta; p = p.next; &#125; //利用CAS无锁置null setTabAt(tab, i++, null); &#125; &#125; &#125; &#125; if (delta != 0L) addCount(delta, -1); &#125; 总结ConcurrentHashMap是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于HashTable和同步包装器包装的HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。1.6中采用ReentrantLock 分段锁的方式，使多个线程在不同的segment上进行写操作不会发现阻塞行为;1.8中直接采用了内置锁synchronized，因为1.8的虚拟机对内置锁已经优化的足够快了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F2018%2F07%2F05%2FJava%2FHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashMap是一种以Key,value存在的经典数据结构，也是在开发过程中比较常用的数据结构，本篇博客主要是结合源码进行分析理解。 HashMap简介Java为数据结构映射定义了一个接口java.util.map，此接口公用四个常用的实现类，分别是HashMap,LinkedHashMap,HashTable,TreeMap。下面针对这四个常用集合进行说明。 HashMap 它根据键的hashcode进行存储数据，大多数的情况下可以直接定位它的值，因而具有很快的访问速度，但是遍历顺序不是确定的，HashMap最多允许一条记录的键为空，允许多条记录的值为空。HashMap不是线程安全的。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 HashTable Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它是线程安全的和不允许键为空，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 LinkedHashMap LinkedHashMap是HashMap的一个子类，它与HashMap的区别是LinkedHashMap是有序的，而HashMap是无序的。 TreeMap TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 HashMap知识点归纳总结 hashmap为什么不是线程安全的 hashmap底层是一个Entry数组，当发生hash冲突的时候，hashmap采用链表的方式来解决，在对应的数组位置放链表的头结点，对链表来说，新加入的节点会从头结点加入（此过程不是同步的，如果多个线程同时访问一个hash映射，而其中一个线程从结构上修改该映射，则它必须保持跟外部同步）。如果两个线程同时对同一桶数组进行添加元素，线程a添加成功后，线程b会将其覆盖。会造成线程a的写操作丢失 hashmap和hashtable区别 hashmap允许键值对为空，hashtable不允许键值对为空 hashtable的public的方法被synchronized修饰，线程安全的。 尽量不要使用hashtable，单线程可以使用hashmap，多线程可以使用concurrentHashMap，hashtable采用synchronized关键字，即hashtable是针对整个map进行锁定，ConcurrentHashMap是对map中的所有桶加了锁。这样会导致在竞争激烈的并发环境表现出效率低问题。 为什么hashMap中数组的size必须是2的次幂 Hash简介：Hash一般译为散列或者直接音译为哈希，就是把任意长度的输入，通过hash算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是说，散列的空间远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单来说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 Hash表是一种与数组，链表等不同的数据结构，与他们需要不断的遍历比较来查找的办法，哈希表设计了一种哈希关系f(key)=address,根据key来计算存储地址address,这样可以一次查找。f既是存储数据过程中，用来指引数据存储到什么位置的函数。 如果桶数组的长度为2的次幂，则length-1转换成二进制末尾为1，再与hash进行与操作则不会造成空间的浪费，而如果不是2的次幂，则转换成二进制的末尾是0，则与hash进行运算时hash转换成二进制末尾不能为1。 HashMap源码分析内部实现从结构上来讲，HashMap是数组 + 链表 + 红黑树实现的，如下所示： 需要明白两个问题：数据底层到底存储的是什么？这样存储的方式有什么优点？ 底层实现 从源码可知，HashMap类有一个非常重要的字段，就是Node[] table即桶数组，很明显是Node数组，底层源码如下所示： 1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry&lt;K,V&gt;,其本身就是一个映射（键值对），上图的黑色圆点就是Node对象。 功能实现简介 确定Hash桶数组的位置 不管是增加元素，删除和查找键值对，定位到Hash桶数组的位置都是关键的一步，当我们用Hash算法求得元素对应的位置时候，马上就可以知道对应元素的位置是我们想要的，而不用去遍历链表大大优化了查询速度。对应源码如下：123456static final int hash(Object key) &#123; int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 这里的hash算法本质上就三步，key的hashcode值、高位运算和取模运算。下面举例说明，n为table的长度。 上述的计算步骤可以简化理解为要查询下图结构是否包含35元素,首先定位到35所处的桶的位置，index = 35 % 16 = 3。在3号桶所指的链表继续查找，发现35在链表中 分析HashMap的put方法 HashMap的执行过程可以简化为如下所示： 判断桶数组table[i]是否为空或者null,如果数组为空则进行扩容操作。 根据key值计算hash值来得到桶数组索引i,如果table[i] == null,直接执行第6步骤，否则执行第3步骤。 判断table[i]的元素是否key相同，如果相同则直接覆盖，这里相同指的是hashcode和equals相同，否则直接执行步骤4 判断table[i]是否为treeNode,即是否为红黑树，如果是红黑树，直接插入，否则执行步骤5 判断table[i],判断链表长度是否大于8，大于8则把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的操作。遍历过程中发现key存在直接覆盖value即可。 插入成功后，会判断是否需要扩容。默认的负载因子为0.75，也就是说如果插入的元素超过桶数组中75%时，就会将原来的桶数组扩容至现在的两倍。并将原来的对象插入到新的数组中。 Hash碰撞处理： 根据Key进行插入或者获取元素时，首先会根据Key值调用hashcode()方法，如果得到相同的hashcode时，会调用equals()方法，如果key相同时，插入直接覆盖，如果不同时，插入链表的下一位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 扩容机制 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。鉴于JDK1.8中使用红黑树，较复杂，为了理解使用JDK1.7源码进行分析 12345678910111213 void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。1234567891011121314151617 void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; JDK1.7扩容时可能形成环，这是因为插入的数据会插入到头节点中。JDK优化将数据插入到末尾 JDK1.8扩容代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes"，"unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap的有序性问题 说明 在HashMap中，是将key作hash算法，然后将hash值映射到内存地址中，直接取的key所对应的数据。在HashMap中，底层数据结构采用的是数组，所谓的内存地址是数组的下标索引。HashMap功能的缺点是无序的，即存入HashMap的元素与其遍历的结果不一致，如果希望HashMap是有序的，可以使用LinkedHashMap.LinkedHashMap继承自HashMap,具有高效性，同时在HashMap的基础上，添加了链表的head 和 tail 两个节点，从而变成了按照插入顺序的双向循环链表。HashMap通过Hash算法可以尽快的进行put()和get()操作,TreeMap则提供了一种完全不同的Map实现，从功能上讲，TreeMap比HashMap提供了更为强大的功能，它实现了 SortedMap 接口，这意味着它可以对元素进行排序。TreeMap的性能略微低于 HashMap。如果在开发中需要对元素进行排序，那么使用HashMap便无法实现这种功能，使用 TreeMap 的迭代输出将会以元素顺序进行。LinkedHashMap是基于元素进入集合的顺序或者被访问的先后顺序排序，TreeMap 则是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。 源码分析 对于HashMap的遍历，一般我们会采用下面两种方式：123456789for(Object key : map.keySet()) &#123; // do something&#125;//或者for(HashMap.Entry entry : map.entrySet()) &#123; // do something&#125; 从上面可以看出，一般都是对HashMap的key集合或者Entry集合进行遍历。多次遍历的结果顺序都是一致的，但是与插入的顺序是不一致的。其对应HashMap集合源码如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks;&#125;/** * 键集合 */final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; // 省略部分代码&#125;/** * 键迭代器 */final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125;&#125;abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry // 寻找第一个包含链表节点引用的桶 do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; // 寻找下一个包含链表节点引用的桶 do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; //省略部分代码&#125; 如上面代码所示，遍历所有的键时，首先要获取KeySet对象，然后再通过keySet的迭代器keyIterator进行遍历，keyIterator继承hashIterator类，核心逻辑也封装在HashIterator类中，HashIterator的逻辑并不复杂，在初始化时HashIterator先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行链表。遍历完成后。再继续寻找下一个包含链表节点引用的桶，找到则继续遍历，找不到则结束遍历。其遍历过程如下所示：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F06%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式是一套被反复使用、多人知晓的，经过分类编目的，代码设计经验总结。 简介java中单例模式是一种常见的设计模式，单例模式有以下几种特点： 单例类中只能有一个实例（对象全局唯一），可以使用的单例模式都有一个的类都有一个共性，那就是这个类没有状态，换句话说，这个类无论实例化多少个，都是一样的。 单例类中只能自己创建自己唯一的实例 单例类必须给其他所有的对象提供这一实例 单例模式可以分为懒汉式和饿汉式 懒汉式单例模式：在类加载时不初始化 饿汉式单例模式：在类加载时完成初始化，所以类加载比较慢，但是获取对象的速度快。 我们是通过以下几个方式去保证我们取到的实例是唯一的： 1：静态实例，带有static关键字的属性在每一个类都是唯一的。 2：私有化构造方法，此为保证单例中最重要一步。 懒汉式单例模式（线程不安全）123456789101112public class Singletion &#123; private Singleton () &#123; &#125; private static Singleton instance; public static Singleton getInstance () &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式单例模式（线程安全）123456789101112public class Singleton &#123; private Singleton () &#123; &#125; private static Singleton instance; public static synchronized Singleton getInstance () &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 饿汉式单例模式123456789public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton instance = new Singleton(); public static Singleton getInstance () &#123; return instance; &#125;&#125; 静态内部类单例模式静态内部类加载单例模式时候跟其他方式有所不同，其他方式只要类被加载时，那么instance就会被实例化，而使用静态内部类单例模式时，虽然类被装载了，instance不一定被初始化。因为SingletionHolder类没有主动被使用，只有通过getInstance方法时，才会显示SingletionHolder类，从而实例化instance。如果实例化instance很消耗资源，让他延迟加载，另一方面，不希望Instance在类加载时就被实例化，因为不能确保Singletion类还可能在其他方面被主动使用而被加载，那么这个时候实例化instance是不合适的。这个时候显然使用静态内部类单例模式会显得更加合理一点。 1234567891011public class Singleton &#123; private Singleton () &#123; &#125; private static class SingletonHolder &#123; private static final Singletion instance = new Singleton(); &#125; public static Singleton getInstance () &#123; return SingletonHolder.getInstance(); &#125;&#125;]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F06%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式是为其他对象提供一种代理以控制对这个对象的访问。代理模式分为两种，可以分为两种，一种是静态代理，另外一种是动态代理。两种代理模式本质都是相同的，都是从原有类的行为基础上，加入多出的行为，甚至替换原有的东西，产生一个新的与原有类接口相同却行为不同的类型。 静态代理有如下几个特点： 代理类持有一个被代理类的对象的引用。 对于不关心的方法，一般全部交给被代理类对象处理。 在代理类中处理我们关心的方法。 实例一般来说数据库连接是一种珍贵资源，频繁的创建、销毁连接是一种浪费系统CPU以及内存，一般使用数据库连接池来解决这个问题。创建固定的连接等待被使用，使用完毕放回到连接池中。数据库在整个应用启动期间，几乎是不关闭的。 但是在编写程序时，会调用connection.close()方法去关闭数据库连接，这样做是对的，并不能告诉程序员们说，你们使用连接都不要关了，去调用一个其他的类似归还给连接池的方法吧。这不符合程序员的编程思维的，也很勉强，而且具有风险性，因为程序员会忘的。 Connection方法（去掉很多方法）1234567891011import java.sql.SQLException;import java.sql.Statement;import java.sql.Wrapper;public interface Connection extends Wrapper &#123; Statement createStatement() throws SQLException; void close() throws SQLException; &#125; connection代理类12345678910111213141516171819202122import java.sql.SQLException;import java.sql.Statement;public class ConnectionProxy implements Connection&#123; private Connection connection; public ConnectionProxy(Connection connection) &#123; super(); this.connection = connection; &#125; public Statement createStatement() throws SQLException&#123; return connection.createStatement(); &#125; public void close() throws SQLException&#123; System.out.println(&quot;不真正关闭连接，归还给连接池&quot;); &#125;&#125; 数据库连接池1234567891011121314151617181920212223242526272829303132333435363738394041package test_proxy;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.LinkedList;// 数据库连接池public class DataSource &#123; private static LinkedList&lt;Connection&gt; connectionList = new LinkedList&lt;Connection&gt;(); static &#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; private static Connection createNewConnection() throws SQLException &#123; return DriverManager.getConnection("url", "user", "password"); &#125; private DataSource() throws SQLException &#123; if (connectionList == null || connectionList.size() &lt; 10) &#123; for (int i = 0; i &lt; 10; i++) &#123; connectionList.add(createNewConnection()); &#125; &#125; &#125; public ConnectionProxy getConnection() &#123; if (connectionList.size() &gt; 10) &#123; //return connectionList.remove(); 这是原有的方式，直接返回连接，这样可能会被程序员把连接给关闭掉 //下面是使用代理的方式，程序员再调用close时，就会归还到连接池 return new ConnectionProxy(connectionList.remove()); &#125; return null; &#125;&#125; 总结优点：可以在不修改目标类的前提下，对目标类进行修改。 缺点：代理类需要与目标类实现同一接口，所以会有很多代理类，类太多，并且，一旦接口增加方法，目标类与代理类都需要维护，增加了维护成本。 并且静态代理一定是要目标类存在的前提下，但是实际项目中编译之前有可能不知道要代理哪个，这就由动态代理来解决了。]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务基本原理]]></title>
    <url>%2F2018%2F06%2F22%2F%E5%88%86%E5%B8%83%E5%BC%8F%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇博客主要介绍微服务基本原理。参考博客https://mp.weixin.qq.com/s/mOk0KuEWQUiugyRA3-FXwg 微服务简介微服务就是一种架构风格，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务运行在独立进程中，服务间采用轻量级的通信机制协作（通常采用HTTP/JSON），每个服务都能独立部署，独立维护，独立扩展，服务与服务之间通过诸如Restful API等方式相互调用。 使用场景描述在电商网站用户下单场景中，首先订单服务会与财务系统发生数据交互，对财务系统返回的结果进行判断，如果下单成功，更新本地数据库订单支付状态。调用库存服务，相应的商品数量较少一个。然后通知仓储服务，通知进行发货操作，最后更新用户服务中用户的积分。如下图所示。 微服务组件介绍根据上述简单业务场景介绍，大致可以看到订单服务，库存服务，仓储服务与用户服务之间的调用关系，在微服务中主要通过各个组件来实现其功能。下面重点介绍微服务中常见的组件 Eureka订单服务想要调用其他服务时，首先要知道其他服务的地址才可以进行发送请求，这时就需要Eureka来协助完成。Eureka是微服务的注册中心，专门负责服务的注册与发现。Eureka Service里有一张注册表，当服务启动时，会将服务的IP地址和端口号保存到注册表中。每个服务会把Eureka service中的注册表缓存到本地中。这样就可以进行服务之间的调用。 总结一下： Eureka client：负责将这个服务的信息注册到Eureka Service中。同时会将Eureka Service中注册表缓存到本地中。 Eureka Service：注册中心，里面有注册表，保存了各个服务的IP地址和端口号。 Feign订单服务知道其他服务的IP地址和端口号，需要与其他系统进行网络连接，然后构造复杂的请求，发送请求，解析其他服务返回的结构。这时，可以用Feign组件来完成。Feign组件的关键是使用动态代理完成。首先，如果你对某个接口定义了@FeignClient这个注解，Feign就会针对这个接口创建一个动态代理，Feign的动态代理会根据你在接口上的@RequestMapping(“”)来动态构造你要请求的地址。最后针对这个地址来发起请求，解析响应。 Ribbon假设库存服务部署在多台机器上，此时Feign是不知道究竟请求哪台机器上的服务。Ribbon就是解决这个问题的，它的作用是负载均衡，每次请求时选择一台机器，均匀的把请求分布到各个机器上。 Ribbon负载均衡默认使用最经典的Round Ribbon轮询算法，这个算法的大概意思是假设有库存服务部署在五台机器上，现在有10次请求，会先将你的请求分配在第一台机器，第二台机器上，第三台机器上第四台机器上，第五台机器上。然后再来依次轮询。 此外，Ribbon是和Feign以及Eureka紧密协作完成工作的。具体如下： 首先Ribbon会从Eureka Service获取对应的服务注册表，也就是知道了所有的机器都部署在哪台机器上，在监听哪些端口号。 然后Ribbon就可以使用默认的Ribbon Round算法，从中选择一台机器。 Feign就会根据这台机器，进行构建链接，发起请求。 Hystrix在微服务架构里，一个系统会有很多服务。以上述场景为例，在一个业务逻辑中，订单服务需要调用四个服务，假设订单服务最多可以同时支持100个线程。在调用用户服务时用户服务挂了，此时执行这个逻辑就会卡住几秒钟，最后会抛出超时异常。在高并发的情况下，订单服务的100个线程都会卡在用户服务这块，导致订单服务没有其他的线程处理请求。然后就会导致其他系统请求订单系统时，发现订单服务也挂了，不响应任何请求。 上面这个就是微服务架构中恐怖的雪崩问题。某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。 可以使用微服务中Hystrix，Hystrix是隔离、熔断以及降级的一个框架。假设某个系统挂了，就不去请求这个服务，而是走本地的一个方法。这个过程就是熔断，服务降级。 ZuulZuul是负责网络路由的。举个简单的例子，加入在后台部署了几百个服务，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。 而且有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。 ConsulEureka2.x注册中心停止迭代维护，并且Eureka是不能保证数据的一致性（当注册一个服务时，其他服务根本发现不了，或者很长时间才能发现）。这时可以使用Consul组件作为微服务的注册中心。如果使用Consul作为注册中心，必须在每一个服务所在的机器上部署一个Consul Agent。作为一个服务所在的机器代理。然后还要在多台机器上部署Consul Server。这就是核心的注册中心。 Consul Agent会发送每个服务的信息到Consul Server，还会对服务发送请求判断是否健康。集中式心跳管理比如Eureka。是让各个服务每隔一段时间发送心跳到Eureka Server。如果一段时间没有接受到请求，那么就认为这台机器宕机。使用集中式心跳管理会对Eureka Server造成很大的压力。实际上平时Eureka Server接受到最多的请求就是各个服务的请求。所以Consul Agent对集中式心跳管理进行优化，引入了Consul Agent。每个机器上的Consul Agent会对服务不断的发送请求判断是否宕机，如果服务宕机则发送请求到Consul Server。这样可以减少Consul Server的服务压力。 如果要发现其他服务。Consul Agent也会转发请求到Consul Server，查询其他服务所在的机器信息。Consul Server一般要求部署三到五台，以保证高可用和以及数据的一致性。他们之间会自动实现数据同步。而且Consul Server会自动选举出一台机器作为leader，其他为follower。各个服务发送给Leader，由Leader同步给follower。如果库存服务注册时，那么Leader一定有注册信息。其他服务发现库存服务，会先请求Leader Server。服务的注册和发现都是通过Leader Server来完成，保证数据的强一致性。]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>distributed</tag>
        <tag>Microservice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM简介]]></title>
    <url>%2F2018%2F04%2F24%2FJava%2FJVM%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[JVM主要实现两个功能，分别是软件层面的机器码翻译和内存管理，这个功能主要是帮助Jav实现Write Once Run Everywhere。首先JDK会将程序编译为.class文件。然后JVM加载class文件将其编译成机器可识别的0、1状态码。内存管理主要可以使编程者专注于业务代码的实现，而不必关心垃圾回收的问题。 内存管理机制 Java是由JVM自动管理内存，负责垃圾回收，进行对象的销毁，下面是运行时数据区域： 程序计数器：存放当前线程执行字节码指令地址（行号）。当线程进行上下文切换时需要记录被挂起线程执行的位置。 虚拟机栈/本地方法栈：本地方法栈与虚拟机栈的作用是类似的，他们的区别是虚拟机栈执行为虚拟机执行Java方法，而本地方法栈则为虚拟机使用到的Native方法服务（Native是指调用Java方法调用非Java代码的接口的代码）。虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行时都会创建一个帧栈，用于存储局部变量表、操作数栈、动态链接、方法等信息。栈的存储速度比堆的存储速度更快一点，栈的存储速度仅次于计算机的寄存器。栈的大小是确定的。对象的引用是存在栈中，对象的本身是存在堆中的。 堆：存放对象实例。可以处于物理上不连续的内存空间，只要逻辑上连续就可以。每次动态进行分配内存，由于是每次运行时进行动态内存分配，所以存储速度比较慢。 方法区：用于存储已被虚拟机加载的类信息，常量，静态变量，及时编译的代码等数据。 方法区和堆是线程共享的，程序计数器和虚拟机栈/本地方法栈是线程私有的。 Java堆分为新生代和老年代。新生代：所有的新生对象放到新生代，新生代分为三个区，一个伊甸园区（Eden）,两个幸存者（survivor）,新的对象先进入到Eden区，Eden区满了之后还存活的对象会放到其中一个survivor区，满了之后仍然存活的对象会进入到第二个survivor区。第二个survivor区满了之后还存活的对象会进入到老年代，会始终保持有一个survivor区是空的。 有关Java堆的参数设置: -Xms20M(start)堆的起始大小 -Xmx(max) 堆的最大大小 -Xmn(new) 堆的新生代大小 老年代：经过多次新生代GC幸存的对象会被放到老年代。大对象直接进入到老年代。 对象在堆空间中分配的流程Java堆分为新生代和老年代。新生代：所有的新生对象放到新生代，新生代分为三个区，一个伊甸园区（Eden）,两个幸存者（survivor）,新的对象先进入到Eden区，Eden区满了之后还存活的对象会放到其中一个survivor区，满了之后仍然存活的对象会进入到第二个survivor区。第二个survivor区满了之后还存活的对象会进入到老年代，会始终保持有一个survivor区是空的。 新对象在堆空间分配流程： 当产生一个新对象时，首先会判断Eden区是否有足够的内存，如果有足够的内存，直接将对象分配到堆内存中。如果Eden区内存不足则进入下一流程。 当Eden区不足时会进行一次Minor GC操作，将没有存活的对象清除掉，然后继续判断是否有足够的内存空间，如果存在足够的内存空间，则将对象之间分配到Eden区。如果内存空间不足则进入下一流程。 如果Minor GC之后Eden区的内存依然不足，会判断survivor区是否有足够的内存空间，如果survivor中有足够的内存空间，则将Eden区存活的对象分配在Survivor区，然后继续判断Eden区是否有足够的内存空间，如果Eden区有足够的内存空间，则将对象直接分配到Eden区。如果Survivor区的内存空间不足时，则进入下一个流程。 当Survivor区内存空间不足时，则将Survivor内存空间分配到老年代中，然后将Eden区中存活的对象分配到Survivor中，最后判断Eden区是否有足够的内存空间分配新对象，如果此时还没有足够的内存空间分配对象，则根据大对象直接分配在老年代中，继续判断老年代是够有足够的空间分配对象。 当老年代中没有足够的空间，则进行Full GC。 判断对象是否可以被回收判断对象是否存活的两种算法：引用计数算法和可达性分析算法。 引用计数算法就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，表示对象可以被回收，其缺点是很难解决对象之间相互引用问题。 可达性分析算法基本的思路就是通过一系列名为“GC Roots”对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 其中GC Roots包括虚拟机栈中的引用对象，方法区中静态变量所引用的对象，本地方法栈中JNI(一般说的Native方法)引用的对象。 四种引用类型：强引用、软引用、弱引用和虚引用。 垃圾收集算法： 标记-清除算法：首先标记出所有需要回收的对象，在标记完后统一回收被标记的对象，这个过程中会有两个步骤：标记和清除，其效率不高并且会产生大量碎片。 复制回收算法：将内存划分为相同的两块，每次只使用一块，将存活的对象复制到另一块。其缺点是空间利用率不高。 标记整理算法：对象存活率较高时使用复制算法其效率会变低，让所有存活的对象都向一端移动，直接清理掉边界以外的内存。先标记，然后修改用用地址到碎片的过程，然后修复碎片 分代收集算法：将对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，新生代中，每次垃圾收集时都会有大批的对象死去，只有少量的存活，选择复制算法，只要复制少量存活对象的复制文本就可以完成收集，而老年代中因为对象的存活率高，没有额外的空间对它进行分配就必须用标记-清理或者标记-整理算法进行回收。 GC垃圾回收器JVM提供的收集器较多，特征不一，适用于不同的业务场景： serial 收集器 最古老的垃圾单线程收集器，进行垃圾收集时必须暂停其他线程，一般作用于clent端。serial 收集器作用与新生代，采用复制算法，serial-old 收集器作用于老年代，采用标记整理算法。 parnew 收集器 parnew 收集器是serial收集器的多线程的版本。与serial收集器相同，进行垃圾回收时必须暂停其他线程工作。新生代采用复制算法，老年代（parnew old）采用标记整理算法。它是运行在server模式下首选的新生代收集器，除了serial收集器外，目前只有它能配合CMS收集器工作。 parallel scavenges 收集器 parallel scavenge收集器是一个新生代的收集器，它也是使用复制算法的收集器，又是并行的多线程的收集器。主要注重吞吐量 cms 收集器 CMS(Concurrent mark sweep) 是一种以标记清除算法实现作用于老年代的收集器，是第一次让垃圾收集线程与工作线程同时工作的。 G1收集器 G1(Garbage-first) 与其他GC收集器相比，G1具备如下特点 1：并行与并发：G1能充分利用充分利用多CPU的硬件环境。使用多个CUP来缩短stop-the-world时间。 2：分代收集：G1不需要其他收集器的配合完成分代收集 3：空间整合：与CMS 收集器采用标记-清除算法不同，G1收集器采用标记整理算法。 JVM内存溢出情况整理 Java堆内存溢出情况 Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制回收对象，那么在对象达到最大堆容量限制之后就会产生内存溢出异常。当出现Java堆内存溢出，异常堆栈信息’Java.lang.OutOfMemoryError’会跟着进一步提示”Java heap space”,要解决这个区域的异常，一般会先通过内存映象分析工具对Dump出来的对转存储快照进行分析，重点是确认内存中的对象是否是必要的，也就是先区分到底是内存泄露还是内存溢出。如果是内存泄露，可进一步通过工具来进行查看泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎样的路径与GC Roots相关导致垃圾回收器无法回收它们，如果不存在泄露，就是内存中的对象是存活的，那就应当检查虚拟机的堆参数与机器物理内存对比是否可以调大，并且从代码上检查某些对象存在的生命周期是否过长。 虚拟机栈和本地方法栈溢出 如果线程请求的栈深度大于虚拟机锁允许的最大深度，将会抛出StackOverflowError,如果虚拟机在扩展栈时没有足够的内存空间，则会抛出OutOfMemoryError。以上两种情况其实是对同一件事情的描述，当栈空间无法继续分配时，到底是栈内存空间太小还是已经使用的栈内存空间太大。在单线程的情况下，无论是帧栈太大还是虚拟机栈太小，当内存无法分配时，则会抛出StackOverFlowError异常。如果通过建立多线程的方式导致的内存溢出，在不能减少线程或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少帧栈容量来换取更多线程。 方法区和运行时常量池溢出 若是运行时常量池溢出，在OutOfMemoryErro后面跟随的提示信息是’PermGen Space’,说明运行时常量池属于方法区(永久代)的一部分。方法区用于存放calss类的相关信息，比如类名，访问权限，常量池，方法描述，若运行时产生大量的类去填充方法区，直达溢出。比如Spring对类进行增强时（创建代理类），都会使用到cglib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载到内存。再比如大量JSP或动态产生JSP文件应用（JSP第一次运行时需要编译为Java类）等。 jvm加载类的过程从源文件的生成到程序的运行，Java程序要经过两个步骤：编译和运行。源文件由编译器编译成字节码，字节码由Java虚拟机解释运行。 编译：创建完源文件之后，程序会被编译器编译为.class文件。Java编译一个类时,如果这个类所依赖的类没有被编译，编译器会先编译这个被依赖的类，然后引用，否则直接引用。编译后的字节码格式主要是两部分，常量池和方法字节码。 常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等，而符号引用主要包括了三类常量：类和接口的全限定名，字段的名称和描述符。方法的名称和描述符。 运行：Java类的运行大概分为两部分，类的加载和执行。类的加载是通过加载器将字节码（*.class）加载到jvm内存中。类从被加载到内存开始，到卸载出内存为止，共有七个阶段，加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备和解析三个部分统称为连接。 类加载器 类加载器虽然只是用于实现类的加载动作，但在Java程序中起到的作用远远不限于类的加载阶段，对于任何一个类，都需要由加载它的类加载器和这个类本身一同确定在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否相等，只有这个类是由同一个类加载器加载的前提才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类必定不相等。共有四种类加载器：启动类加载器，扩展类加载器，应用程序类加载器和自定义类加载器。 启动类加载器：它的作用是将JAVA_HOME/lib目录下的类加载到内存中。需要注意的是由于启动类加载器涉及到虚拟机本地的实现细节，开发人员无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 扩展类加载器：它是由Sun的ExtClassLoader实现的，它的作用是将JAVA_HOME/lib/ext目录下或由系统变量Java.ext.dir指定位置中的类加载到内存中，它可以由开发人员直接使用。 应用程序类加载器：它是由Sun的AppClassLoader实现的，它的作用是将classpath路径下指定的类加载到内存中。它也可以由开发人员使用。 自定义加载器：自定义的类加载器继承自ClassLoader，并覆盖findClass方法，它的作用是将特殊用途的类加载到内存中。 双亲委派模型： 所谓的类加载器的双亲委派模型指的是类加载器的层级关系。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这种组合关系来实现，而不是通过继承来实现。 启动类加载器：启动类加载器将存放在&lt;JAVA_HOME&gt;\lib的目录中的类库加载到虚拟机内存中，启动类加载器无法被Java程序直接引用 扩展类加载器：负责加载&lt;JAVA_HOME&gt;\lib\exe目录中，开发者可以直接使用扩展类加载器 应用程序类加载器: 一般称为系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序没有定义过自己的类加载器，一般情况下这个就是程序的默认的类加载器。 某一个类加载器请求加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，则返回成功，如果父类加载器无法完成加载任务，将抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载，依次类推。 使用双亲委派模型的好处：即防止内存中出现多份相同的字节码。 反向思考这个问题，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写一个Java.lang.Object的同名类并放在ClassPath中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的Object类，那么类之间的比较结果及类的唯一性将无法保证，而且如果不适用这种双亲委派模型将会给虚拟机的安全带来隐患。所以，要让类对象进行比较有意义，前提是他们要被同一个类加载器加载。 破坏双亲委派机制： 上文提到的双亲委派模型并不是强制性的模型，而是Java设计者推荐给开发者的类加载的实现方式，在Java的世界里，绝大部分的类加载器都遵循这个规律，但是会有破坏双亲委派模型的情况：线程上下文类加载器，这个类加载器可以通过Java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那么类加载器就是应用程序类，像JDBC就采用了这种方式。这种方式就是逆向使用了加载器，违背了一般性原则。 保证线程可见的三种方法： 使用volatile关键字 使用synchronized关键字 使用final关键字（一旦初始化完成其他线程就可见）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程基础知识]]></title>
    <url>%2F2018%2F03%2F31%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程的一些基础概念介绍 OSI七层网络模型第一层：物理层。这一层主要就是传输这些二进制数据。 第二层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输。 第三层：网络层。定义网络设备间如何传输数据。 第四层：传输层。管理着网络中端到端的数据传输。 第五层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断。 第六层：表示层。定义了不同系统的数据传输格式，编码和解码规范等。 第七层：应用层。定义了用于在网络中进行通信和传输数据的接口。 TCPTCP/IP 是传输层的协议，使用三次握手和四次挥手提供一种面向链接，可靠的字节流服务。 TCP内存模型一个TCP连接由四个元组构成，分别是两个IP地址和两个端口号。一个TCP连接通长分为三个阶段：启动、数据传输、退出。 当一个TCP接收到另一端的数据时，它会发送一个确认，这个确认不会立即发送，一般会延迟一会。ACK是累积的，一个确认字节号N的ACK表示直到N（不包含N）已经被成功接收了。这样的好处是一个ACk丢失，后面的ACK就足以确认前面的报文。 一个完整的TCP连接是双向对称的。数据可以在两个方向平等的流动。给上次应用程序提供一种双服务，一旦建立连接，这个连接的一个方向的每个TCP报文段包含相反方向的报文段的ACK。 ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。 三次握手三次握手的作用就是为了向对方证明自己的发送、接受数据是没有问题的。 第一次握手：客户端发送带有SYN标志的数据包到服务端，如果服务端接收到数据包，则服务端得出结论：客户端的发送能力和服务端的接受能力是没有问题的。 第二次握手：服务端发送带有SYN/ACK标志的数据包到服务端。如果客户端接受到该数据包，则客户端得出结论：客户端、服务端的发送接受能力是没有问题的。 第三次握手：客户端发送带有ACK标志的数据包到服务端。如果服务端接受到哦数据包。则服务端得出结论：客户端、服务端的发送接受能力是没有问题的。 四次挥手TCP的连接是双向传输的对等模式，双方都可以向对方发送接受数据，当有一方要关闭连接时，会发送指令告诉对方，我要关闭连接。这时对方会回ACK，此时，一个连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完所有的数据，会发送一个FIN段来关闭此方向的连接。接受方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK，它是无法马上回复对方一个FIN报文段的，因为结束数据运输的指令是上层应用层所决定的。 客户端-发送一个FIN,用来关闭客户端到服务端的数据传送。 服务端-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号， 服务端-关闭与客户端的连接，发送一个FIN给客户端。 客户端-发回ACK报文确认，并将确认序号设置为收到序号加10.0 HTTPHTTP协议是建立在TCP协议基础之上的，当浏览器需要从网页上获取网页数据的时候，会发出一次HTTP请求，HTTP会通过TCP建立起一个服务器的连接通道，当本次请求需要的数据完毕后，HTTP会立即将TCP链接断开，这个过程很短，HTTP是一种短连接，无状态的连接。所谓无状态连接，是指每次请求服务器都会通过一个新的连接来进行请求，连接结束之后，相关内容就会释放，不会记录任何状态，所以是无状态连接。 一次完整的HTTP请求过程DNS域名解析 –&gt; 发起TCP三次握手 –&gt; 建立TCP连接后发起HTTP请求 –&gt; 服务器响应HTTP请求，得到相应的数据 –&gt; 浏览器解析请求，渲染视图等操作。 HTTP的长连接和短连接HTTP的长连接和短连接本质上是属于TCP的长连接和短连接。其中HTTP是属于应用层的传输协议，TCP是属于传输层的协议，而IP是网络层的协议。IP协议主要解决网络路由和寻址的问题。TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。 在HTTP/1.0中默认使用短连接。也就是说客户端和服务器之间每进行一次HTTP请求，就建立一次连接，任务结束就中断连接。而从HTTP/1.1起，默认使用长连接。使用长连接的HTTP协议，会在响应头加下面这行代码 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器端的HTTP协议不会断开（底层的TCP连接不会关闭），客户端再次访问这个服务器时，会继续使用这个连接。 HTTPSHTTPS协议是由SSL + HTTP构建的加密传输、身份认证的网络协议，比HTTP协议更加安全。一般HTTPS协议需要到CA上进行申请证书，一般免费证书较少，需要一定费用。 安全传输正常客户端和服务单的通信如下图所示，这种传输不是安全传输，因为如果第三方劫持消息的话，B就接受不到A的消息。安全传输一句话描述就是对于A向B发送消息，只有A和B两个节点能够知道。 进行安全传输的话，可以服务单和客户端进行加密解密，也就是对称传输，但是如果一个服务端有很多个客户端的话，无异于没有加密。也是不安全的传输。 针对上述问题，可以使用HTTPS进行公钥和私钥先进行非对称加密，再进行对称加密来完成安全传输。如下图所示，私钥可以被公钥所解密，但是公钥只有私钥可以解密，私钥属于服务端，公钥属于客户端。具体过程如下所示： 客户端在使用HTTPS协议与HTTP进行通信时有如下几个步骤(原理)： 客户端发起HTTS请求，并且生成一个随机数（第一个随机数）传送给服务端 服务端接收到随机数，也会产生一个随机数（第二个随机数），并将随机数和证书（颁发机构（CA）、证书内容本身的数字签名（使用第三方机构的私钥加密）、证书持有者的公钥、证书签名用到的hash算法）返回给客户端。 客户端会接受到证书做验证（根据颁发机构找到本地的根证书，根据CA得到根证书的公钥，通过公钥对数字签名进行解密，得到证书的内容摘要A。用证书提供的算法对证书的内容进行摘要，得到摘要B，通过A和B进行对比，也就是验证数字签名）。 通过验证后会产生一个随机数（第三个随机数）发送给客户端，通过公钥对随机数进行加密发送给服务端 （随机数1 + 2 + 3）通过对称加密得到一个密匙（会话秘钥） 通过会话密匙对内容进行对称加密传输 注：HTTPS传输随机数是非对称加密，通过验证之后使用对称加密。非对称加密需要两个秘钥（公钥和私钥），如果公钥对其加密，只有对应的私钥才能进行解密，如果私钥加密，与其对应的所有公钥都可以进行解密。 REST 和 RESTFUL 关于REST(representational state transfer) 表述性状态转移，使用web标准来做一些准则和约束 REST原则： 网络上所有的事物都被抽象为资源 每一个资源都有一个唯一的资源标识符（URI） 使用统一的接口处理资源请求（POST/PUT/GET/DELETE/HEAD） 所有的操作都是无状态的 RESTFUL:遵守了rest原则的web服务，是由rest派生出来的。 在Restful之前的操作： http://127.0.0.1/user/query/1 GET 根据用户id查询用户数据 http://127.0.0.1/user/save POST 新增用户 http://127.0.0.1/user/update POST 修改用户信息 http://127.0.0.1/user/delete GET/POST 删除用户信息 RESTful用法： http://127.0.0.1/user/1 GET 根据用户id查询用户数据 http://127.0.0.1/user POST 新增用户 http://127.0.0.1/user PUT 修改用户信息 http://127.0.0.1/user DELETE 删除用户信息 RPC（remote procedure call）架构RPC服务和HTTP服务还是存在不同点的，RPC的效率会更高，而HTTP服务开发迭代会更快。对于大型企业来说，内部子系统和接口较多，RPC的框架的好处就会显示出来，RPC是基于Socket,而socket真则是对TCP/IP的封装和应用。首先是长链接，不用每次请求三次握手，减少网络开销。其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。下面主要从一下三个方面来介绍RPC服务：分别是RPC架构，同步异步调用一集流行的RPC框架。 RPC架构 从图中我们可以清楚的看到，一个完整的RPC架构里面包含了四个核心组件，分别是Client，Server，Client stub，Server stub(stub可以理解为存根) 客户端：服务的调用方。 服务端：真正的服务提供者。 客户端存根：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务端。 服务端存根：接受客户端发过来的消息，将消息解包，并调用本地方法。 RPC主要是应用与大型企业里面（系统繁多，业务线复杂），在实际的开发中，一般会这样做，项目中一般使用maven来管理，处理订单的系统服务，先声明它的所有的接口（这里指的是具体的interface），然后将整个项目打包一个jar包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边只需要引入二方库即可调用，这么做主要是为了减少客户端的jar包大小。另外将客户端和服务端进行解耦，提高程序的可移植性， 同步调用和异步调用 同步调用是指客户端等待服务端调用执行完成并返回结果。异步调用是指客户端不等待调用执行完成返回结果，通过回调函数等待接受返回结果的通知。如果客户端并不关心结果，则可以变成单向的调用。 流行的RPC框架 gRPC是谷歌最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言，底层使用Netty框架支持。 Thrift是FaceBook一个开源项目，主要是跨语言的服务开发框架。它有一个代码生成器来对它说定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发即可。对于底层的RPC等都是透明的。但是对于用户来说需要学习特定领域语言特性，是需要花费一定成本的。 Dubbo是阿里集团开源的极为出名的RPC框架。在众多互联网和企业中广泛应用。协议和序列化框架都可以插拨是及其鲜明的特色。同样远程接口是基于Java Interface，并且依托于Spring框架方便开发，并且方便打包成单一文件，独立进行运行，和现在微服务概念一致。 RPC架构和REST对比]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>netWork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有效的括号序列]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[有效的括号序列 问题描述给定一个括号序列，里面包含小括号，中括号和大括号。你要判断这个括号序列是否有效。有效的括号序列要求，每个左括号都必须有一个同类的右括号与它正确配对。另外，空字符串认为是有效的括号序列。 123456789101112比如说，给你的序列是：()[]&#123;&#125;小括号/中括号/大括号的左右括号都能正确配对，因此这是一个有效的括号序列。再比如说给你的序列是：([)]这里面虽然正好有一对小括号和一对中括号，但它们的顺序不对，括号间无法正确配对，因此这不是一个有效的括号序列。 解题思路利用栈这种数据结构来解决此问题，如果遇到括号的左半部分，则压入栈，遇到右半部分则跟栈顶元素匹配，判断是否匹配。 代码实现123456789101112131415161718192021222324252627282930313233// 有序的括号序列public class AIMain &#123; public static void main(String[] args) &#123; System.out.println(checkStr("([])")); &#125; public static boolean checkStr(String str) &#123; if (str == null) &#123; return false; &#125; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == '(' || str.charAt(i) == '[' || str.charAt(i) == '&#123;') &#123; stack.push(str.charAt(i)); &#125; else if (stack.isEmpty()) &#123; return false; &#125; else &#123; if (str.charAt(i) == ')' &amp;&amp; stack.peek() != '(') &#123; return false; &#125; if (str.charAt(i) == ']' &amp;&amp; stack.peek() != '[') &#123; return false; &#125; if (str.charAt(i) == '&#125;' &amp;&amp; stack.peek() != '&#123;') &#123; return false; &#125; stack.pop(); &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最大利润]]></title>
    <url>%2F2017%2F08%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%2F</url>
    <content type="text"><![CDATA[买卖股票的最大利润 问题描述给你一个整数数组，其中第 i 个元素表示的是第 i 天的股票价格，你要计算出先买一股，然后再卖出它能获得的最大利润 123456789101112比如说，给你的数组是：9, 3, 7, 5, 1, 8如果你在价格为 1 时买入并在价格为 8 时卖出，这时能获得最大的利润 7。再比如说给你的数组是：9, 8, 7, 6这时股票每天都在迭，不存在买入再卖出来获利的可能，因此没有交易，最大利润为 0。 解题思路首先声明一个链表指向给定的链表值，然后用一个链表指针指向声明的链表，判断指针的下一个是否与目标值项目，如果与目标值相同则指向下一个，循环此过程。 代码实现12345678910111213141516171819202122232425// 买卖股票的最大利润public class AIMain &#123; public static void main(String[] args) &#123; int[] prices = new int[] &#123;1, 3, 4, 2, 7, 9, 1, 10&#125;; System.out.println(getMaxValue(prices)); &#125; public static int getMaxValue(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int result = 0; int buy = prices[0]; for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &lt; buy) &#123; buy = prices[i]; &#125; else &#123; result = Math.max(result, prices[i] - buy); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表中删除数字]]></title>
    <url>%2F2017%2F08%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[单链表中删除数字 问题描述给定一个数字，将链表中删除值为这个数字的节点。 123456node：1-&gt;2-&gt;1-&gt;4-&gt;5target: 1result: 2-&gt;4-&gt;5 解题思路首先声明一个链表指向给定的链表值，然后用一个链表指针指向声明的链表，判断指针的下一个是否与目标值项目，如果与目标值相同则指向下一个，循环此过程。 代码实现1234567891011121314151617181920212223242526// 单链表中删除数字public class AIMain &#123; class ListNode &#123; int value; ListNode(int value) &#123; this.value = value; &#125; ListNode next; &#125; public ListNode remove(ListNode head, int target) &#123; if (head == null) &#123; return null; &#125; ListNode result = new ListNode(0); result.next = head; ListNode tmp = result; while (tmp.next != null) &#123; if (tmp.next.value == target) &#123; tmp.next = head.next.next; &#125; tmp.next = head.next; &#125; return result.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变态台阶问题]]></title>
    <url>%2F2017%2F08%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%8F%98%E6%80%81%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[变态台阶问题 问题描述一只青蛙可以一次跳一阶台阶，可以跳两阶台阶，也可以跳n阶台阶。求n阶台阶共有几种跳发？ 解题思路对于n-1阶台阶，可以从n-2阶台阶上去，也可以从n-3阶台阶上去，依次推导为f(n-1) = f(n-2) + f(n-3) + … +f(1) 同理对于n阶台阶可以推导出 f(n) = f(n-1) + f(n-2) + …. +f(1) 根据上述推导可以得出 f(n) - f(n-1) = f(n-1) ==&gt; f(n) = 2 * f(n-1) 代码实现1234// 跳台阶问题public int JumpFloorII(int target) &#123; return (int) Math.pow(2, target - 1);&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[台阶问题]]></title>
    <url>%2F2017%2F08%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[台阶问题 问题描述对于一个n阶台阶，上楼时可以走一阶台阶，也可以走两阶台阶。一共有多少种走法？ 123456789101112131415当n=1时，共有一种走法当n=2时，可以向上走两阶，也可以向上走一阶。共有两种走法当n=3时，可以向上每次走一阶台阶，可以先走一阶台阶、再走两阶台阶。还可以先走两阶台阶，再走三阶台阶。共有三种走法。可以抽象为下面公式：&#123; f(1) = 1 f(2) = 2 f(n) = f(n-1) + f(n-2) &#125; 解题思路根据上述问题描述，本题共有两种解法，用递归或者循环。 代码实现12345678910111213141516171819202122232425262728293031323334353637// 跳台阶问题public class TestStep &#123; public static int getStepConut(int n) &#123; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; return getStepConut(n -1) + getStepConut(n-2); &#125; public static int getStepCountByForeach(int n) &#123; int pre1 = 1; int pre2 = 2; int result = 0; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; for (int i = 3; i &lt;= n; i++) &#123; result = pre1 + pre2; pre1 = pre2; pre2 = result; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getStepConut(6)); System.out.println(getStepCountByForeach(6)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2017%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[滑动窗口的最大值 问题描述给定一个长度为n的数组，有一个大小为K的滑动窗口从数组的最左侧移动到数组的最右侧。滑动窗口每次移动一位，只可以看到滑动窗口内的数字 123456789101112输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 解题思路维持一个双向队列，在队列中存储元素在数组中的位置，并且维持队列的严格递减。也就是维持队首元素是最大的。如果队列中有比当前元素小的就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。 代码实现1234567891011121314151617181920212223242526272829303132public class MaxWindowArr &#123; public static int[] solution(int[] arr, int k) &#123; if (arr == null || k == 0 || arr.length &lt; k) &#123; return new int[0]; &#125; int[] result = new int[arr.length - k + 1]; Deque&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; while (!queue.isEmpty() &amp;&amp; arr[queue.getLast()] &lt; arr[i]) &#123; queue.removeLast(); &#125; queue.addLast(i); if (queue.getFirst() == i - k) &#123; queue.removeFirst(); &#125; if (i &gt; k - 1) &#123; result[i - k] = arr[queue.getFirst()]; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; int[] arr = new int[] &#123;1,3,-1,-3,5,3,6,7&#125;; int k = 3; int[] result = solution(arr, k); for (int i : result) &#123; System.out.println(i); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中重复的数字]]></title>
    <url>%2F2017%2F08%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中重复的数字 问题描述在一个长度为n的数组中所有的数组都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复数字。要求时间复杂度为O(N),空间复杂度为O(1)。 123456input:&#123;2,3,1,0,2,5&#125;output:2 解题思路这道题的解题思路与上一道“第一次只出现一次的字符”大致相同。只不过上次出现的字符会额外使用长度为26的数组对每个字符出现的次数进行标记。这道题目要求时间复杂度O(N),空间复杂度为O(1)。因此不能使用排序算法，也不能使用额外的数据结构作为标记数组。 对于数组在[0, n-1]范围内的问题，可以将值为i的元素调整到第i个位置进行求解。 代码实现12345678910111213141516171819202122232425262728// 数组中重复的数字public class Duplicate &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123;2, 1, 0, 1&#125;; System.out.println(getDuplicateNumber(arr)); &#125; public static int getDuplicateNumber(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return -1; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; while (i != arr[i]) &#123; if (arr[i] == arr[arr[i]]) &#123; return arr[i]; &#125; swap(arr, i, arr[i]); &#125; &#125; return -1; &#125; public static void swap(int[] arr, int i, int j) &#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个只出现一次的字符]]></title>
    <url>%2F2017%2F08%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[第一个只出现一次的字符 问题描述给定一个只包含小写字母的字符串，你要找到第一个只出现一次的字符，并返回它的下标。如果字符串中所有字符都不只出现一次，则返回 -1。 1234567891011比如说，给你的字符串是：apple第一个只出现一次的字符是 a，于是你要返回它的下标 0。如果给你的字符串是：noon这个字符串中的两个字符 o 和 n 都不只出现一次，因此返回 -1。 解题思路首先将数组遍历一遍，然后将字符对应数组的位置。根据出现的次数进行增加。再遍历一次数组，找到位置中等于一的下标。具体代码如下 代码实现1234567891011121314151617181920212223// 求第一次只出现一次的字符串public class FindUniqChar &#123; public static void main(String[] args) &#123; String str = "noon"; System.out.println(findUniqChar(str)); &#125; public static int findUniqChar(String str) &#123; if (str == null || str.isEmpty()) &#123; return -1; &#125; int[] charArr = new int[26]; for (int i = 0; i &lt; str.length(); i++) &#123; charArr[str.charAt(i) - 'a']++; &#125; for (int i = 0; i &lt; str.length(); i++) &#123; if (charArr[str.charAt(i) - 'a'] == 1) &#123; return i; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个有序数组的中位数]]></title>
    <url>%2F2017%2F08%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[两个有序数组的中位数 问题描述给定两个排好序的整数数组nums1和nums2，假设数组是以递增排序的，数组的大小分别是 m 和 n。你要找到这两个数组的中位数。要求算法的时间复杂度是O(log(m+n))。 这里两个数组中位数的意思是，两个数组合到一起排序后，位于中间的那个数，如果一共有偶数个，则是位于中间的两个数的平均数。 123456789101112131415161718192021比如说，给你的两个数组是：1, 32它们放在一起排序后是：1, 2, 3所以中位数就是 2。再比如说，给你的两个数组是：1, 32, 4它们放在一起排序后是：1, 2, 3, 4所以中位数就是 (2 + 3) / 2 = 2.5。 解题思路看到这道题，首先想到的是把两个有序数组合成一个有序数组，然后求整个有序数组的中位数。但是这样并不符合题目要求的时间复杂度。 所以参看网上的资料找到如下的解题方案。 举例说明，对于数组num1的元素为1,2。数组num2的元素为3,4,5,7,9。这两个元素的中位数的位置位k = f((m + n) / 2 + 1)。对于第一个数组来说，首先找到k/2。也就是元素2的位置。对于第二个数组来说，找到k - k/2 的元素，也就是元素4。2小于4的情况下，很显然1,2肯定不是所要求的中位数，所以将偏移量向后移动。假设2大于4的情况下，那么3和4也不是要求的中位数，向后移动。每次去掉数组中k/2个元素，直到达到边界情况。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package algorithm;// 求两个有序数组的中位数public class MedianSortArray &#123; public static void main(String[] args) &#123; int[] a = new int[] &#123;1, 2&#125;; int[] b = new int[] &#123;3, 4, 5, 6, 7&#125;; System.out.println(getMedianSortArray(a, b)); &#125; public static double getMedianSortArray(int[] arr1, int[] arr2) &#123; int m = arr1.length; int n = arr2.length; int target = m + n; if ((target &amp; 1) == 1) &#123; return findKthFromSortArray(arr1, arr2, target / 2 + 1); &#125; else &#123; double a = findKthFromSortArray(arr1, arr2, target / 2); double b = findKthFromSortArray(arr1, arr2, (target / 2) + 1); return (a + b) / 2; &#125; &#125; public static double findKthFromSortArray(int[] arr1, int[] arr2, int k) &#123; int len1 = arr1.length; int len2 = arr2.length; int base1 = 0; int base2 = 0; while (true) &#123; if (len1 == 0) &#123; return arr2[base2 + k - 1]; &#125; if (len2 == 0) &#123; return arr1[base1 + k - 1]; &#125; if (k == 1) &#123; return Math.min(arr1[base1], arr2[base2]); &#125; int i = Math.min(k/2, len1); int j = Math.min(k - i, len2); int a = arr1[base1 + i - 1]; int b = arr2[base2 + j - 1]; if (i + j == k &amp;&amp; a == b) &#123; return a; &#125; if (a &lt;= b) &#123; base1 += i; len1 -= i; k -= i; &#125; if (a &gt;= b) &#123; base2 += j; len2 -= j; k -= j; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分搜素法]]></title>
    <url>%2F2017%2F08%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分搜素法 问题描述给定一个递增排序的整数数组 nums，和一个目标值 target。你要在数组里找到 target，然后返回它的下标。如果找不到则返回 -1。 12345比如说，给你的数组是：-2, 0, 2, 4, 5, 8, 9给你的目标值是 5。5 在这个数组中，找到后返回它的下标 4 即可。 解题思路经典算法二叉搜索法 代码实现123456789101112131415161718192021222324public class BinarySerch &#123; private static int binarySerch(int[] sortArr, int target) &#123; if (sortArr == null || sortArr.length == 0) &#123; return -1; &#125; int maxLenth = sortArr.length - 1; int minLenth = 0; while (minLenth &lt;= maxLenth) &#123; int midLenth = minLenth + maxLenth / 2; if (target &lt; sortArr[midLenth]) &#123; maxLenth = midLenth - 1; &#125; else if (target &gt; sortArr[midLenth]) &#123; minLenth = midLenth + 1; &#125; else if (target == sortArr[midLenth]) &#123; return midLenth; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] sortArr = new int[] &#123;1, 2&#125;; System.out.println(binarySerch(sortArr, 2)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树三种遍历实现]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[二叉树三种遍历实现 问题描述给你一个二叉树，你要返回一个数组，表示二叉树前序遍历，中序遍历和后序遍历的结果。1234567891011比如说，给你的二叉树是： 1 / \ 2 3 \ 4 / 5你要返回的中序遍历结果是：2, 5, 4, 1, 3 解题思路二叉树的前序遍历为根左右 二叉树的中序遍历为左根右 二叉树的后序遍历为左右根 代码实现前序遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package algorithm;import java.util.ArrayList;import java.util.List;import java.util.Stack;// 二叉树的三种遍历public class TraversalTree &#123; class TreeNode &#123; int value; TreeNode left; TreeNode right; TreeNode(int value) &#123; this.value = value; &#125; &#125; // 用递归方式实现前序遍历 前序遍历为根左右 public List&lt;Integer&gt; preOrderTraversalMethodOne(TreeNode root) &#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return resultList; &#125; resultList.add(root.value); if (root.left != null) &#123; preOrderTraversalMethodOne(root.left); &#125; if (root.right != null) &#123; preOrderTraversalMethodOne(root.right); &#125; return resultList; &#125; // 用非递归的方式实现前序遍历 前序遍历为根左右 public List&lt;Integer&gt; preOrderTraversalMethodTwo(TreeNode root) &#123; if (root == null) &#123; return new ArrayList&lt;Integer&gt;(); &#125; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); resultList.add(node.value); if (root.right != null) &#123; stack.push(root.right); &#125; if (root.left != null) &#123; stack.push(root.left); &#125; &#125; return resultList; &#125; // 用递归的方式实现中序遍历 中序遍历为左根右 public List&lt;Integer&gt; inOrderTraversalMethodOne(TreeNode root) &#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return resultList; &#125; if (root.left != null) &#123; this.inOrderTraversalMethodOne(root); &#125; resultList.add(root.value); if (root.right != null) &#123; this.inOrderTraversalMethodOne(root.right); &#125; return resultList; &#125; // 用非递归的方式实现中序遍历 中序遍历为左根右 public List&lt;Integer&gt; inOrderTraversalMethodTwo(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); resultList.add(root.value); root = root.right; &#125; return resultList; &#125; // 用递归的方式实现后序遍历 后序遍历为左右根 public List&lt;Integer&gt; postOrderTraversalMethodOne(TreeNode root) &#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return resultList; &#125; if (root.left != null) &#123; postOrderTraversalMethodOne(root.left); &#125; if (root.right != null) &#123; postOrderTraversalMethodOne(root.right); &#125; resultList.add(root.value); return resultList; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的逆层序遍历]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%86%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的逆层序遍历 问题描述给定一棵二叉树，要求你从叶子节点到根节点一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以二维数组返回。 这道题目和二叉树层序遍历的唯一区别是，它是从下向上一层一层去访问的。123456789101112131415比如说，给你的二叉树是： 1 / \ 2 4 / \ 8 16它的层序遍历结果是：[ [1], [2, 4], [8, 16]] 解题思路将二叉树层序遍历之后在首尾互换。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class TreeNodeTest &#123; public class TreeNode &#123; int value; TreeNode left; TreeNode right; TreeNode(int value) &#123; this.value = value; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; levelOrderTraversal(TreeNode root) &#123; if (root == null) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; List&lt;Integer&gt; treeList = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; queue.size(); i++) &#123; TreeNode treeNode = queue.poll(); treeList.add(treeNode.value); if (treeNode.left != null) &#123; queue.add(treeNode.left); &#125; if (treeNode.right != null) &#123; queue.add(treeNode.right); &#125; &#125; result.add(treeList); &#125; for (int i = 0; i &lt; result.size()/2; ++i) &#123; int j = result.size() - 1 - i; List&lt;Integer&gt; tmp = result.get(j); result.set(j, result.get(i)); result.set(i, tmp); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层序遍历]]></title>
    <url>%2F2017%2F08%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的层序遍历 问题描述给定一棵二叉树，要求你从根节点到叶子节点一层一层地对其进行访问，对于每一层的节点，则是从左向右进行访问。将访问的结果以二维数组返回。123456789101112131415比如说，给你的二叉树是： 1 / \ 2 4 / \ 8 16它的层序遍历结果是：[ [1], [2, 4], [8, 16]] 解题思路将每一层先添加到队列中去，然后根据队列的长度循环取出，这样就可以得到每一层的数据。 代码实现1234567891011121314151617181920212223242526272829303132333435public class TreeNodeTest &#123; public class TreeNode &#123; int value; TreeNode left; TreeNode right; TreeNode(int value) &#123; this.value = value; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; levelOrderTraversal(TreeNode root) &#123; if (root == null) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; List&lt;Integer&gt; treeList = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; queue.size(); i++) &#123; TreeNode treeNode = queue.poll(); treeList.add(treeNode.value); if (treeNode.left != null) &#123; queue.add(treeNode.left); &#125; if (treeNode.right != null) &#123; queue.add(treeNode.right); &#125; &#125; result.add(treeList); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表的相交节点]]></title>
    <url>%2F2017%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[链表的相交节点 问题描述这个题目说的是，给你两个单链表，你要找到它们相交的第一个节点。如果两个链表没有相交，则返回空指针。假设链表无环，并且你不能改变它的原始结构。另外要求算法是线性时间复杂度，空间复杂度要求是 O(1)。123456789比如说，两条链表分别是：A: 1 -&gt; 2 \ 6 -&gt; 7 -&gt; null /B: 3 -&gt; 4 -&gt; 5你要返回的是 6 这个节点。 解题思路定义两个指针，分别让这两个指针指向两个链表，并且指针遍历链表。如果指针指向链表的节点相同，该链表的节点就是相交节点，如果指针在该链表指向为空，则将指针指向另一个链表 代码实现12345678910111213141516171819202122public class AIMain &#123; class ListNode &#123; int value; ListNode next; ListNode (int value) &#123; this.value = value; &#125; &#125; public ListNode solution (ListNode p1, ListNode p2) &#123; if (p1 == null || p2 == null) &#123; return null; &#125; ListNode pA = p1; ListNode pB = p2; while (pA != pB) &#123; pA = pA == null ? p2 : pA.next; pB = pB == null ? p1 : pB.next; &#125; return pA; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断单链表是否有环]]></title>
    <url>%2F2017%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[判断单链表是否有环 问题描述给定一个单链表，你要判断它是否会形成环，也就是链表的最后一个节点指向了前面一个已经存在的节点。 解题思路遍历链表中所有的节点，如果相同的节点出现两次，则证明有环。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940public class JudgeCycleNode &#123; public class ListNode &#123; int value; ListNode next; ListNode(int value) &#123; this.value = value; &#125; &#125; public boolean JudgeCycleMethod1(ListNode head) &#123; if (head == null) &#123; return false; &#125; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); while (head != null) &#123; if (set.contains(head.value)) &#123; return true; &#125; head = head.next; &#125; return false; &#125; public boolean JudgeCycleMethod2(ListNode head) &#123; if (head == null) &#123; return false; &#125; ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串]]></title>
    <url>%2F2017%2F08%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[最长回文子串 问题描述给定一个字符串，你要在它所有的回文子串中，找到长度最长的子串，并返回它。1234567比如说，给你的字符串是：abcbab你要返回的最长回文子串是：abcba 解题思路这道题与查询字符串的回文串子串个数思路类似。 代码实现12345678910111213141516171819202122232425262728293031323334public class MaxPalindromeLen &#123; public String getMaxLength(String str) &#123; if (str == null || str.length() == 0) &#123; return null; &#125; int result = 0; int start = 0; int len = str.length(); boolean[][] count = new boolean[len][len]; for (int i = len - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; len - 1; j++) &#123; if (i == j) &#123; count[i][j] = true; &#125; else if (i + 1 == j) &#123; count[i][j] = str.charAt(i + 1) == str.charAt(j); &#125; else &#123; count[i][j] = str.charAt(i) == str.charAt(j) &amp;&amp; count[i+1][j-1]; &#125; if (count[i][j] &amp;&amp; j - i + 1 &gt; result) &#123; start = i; result = j - i + 1; &#125; &#125; &#125; return str.substring(start, start + result); &#125; public static void main(String[] args) &#123; String str = "abcbab"; System.out.println(new MaxPalindromeLen().getMaxLength(str)); &#125;&#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最大深度]]></title>
    <url>%2F2017%2F08%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的最大深度 问题描述给定一棵二叉树，你要找到从根节点到最远叶子节点的深度123456789比如说，给你的二叉树是 1 / \ 2 4 / \ 8 16这棵树有 3 个叶子节点，分别是 2，8，16。最远的叶子节点是 8 和 16，根节点到 8 或 16 都有 3 个节点，因此最大深度是 3。 解题思路访问树的每一个节点，访问结束后深度加一。 代码实现123456789101112131415161718192021222324252627282930313233343536373839public class AlgoCasts &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; // Time: O(n), Space: (n) public int maxDepth(TreeNode root) &#123; if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125; // Time: O(n), Space: O(n) public int maxDepthIterative(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); int depth = 0; while (!q.isEmpty()) &#123; int size = q.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode s = q.poll(); if (s.left != null) q.add(s.left); if (s.right != null) q.add(s.right); &#125; ++depth; &#125; return depth; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中超过一半的数字]]></title>
    <url>%2F2017%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中超过一半的数字 问题描述给定一个数组，里面有一个数字出现的次数超过了一半，你要找到这个数字并返回。12345比如说，给你的数组是1, 3, 3, 1, 3, 1, 1这个数组的长度是 7，这里我们只考虑整数除法，长度 7 除以 2 是 3。数组里面 1 出现了 4 次，超过了一半的数量 3，因此你要返回的就是 1。 解题思路第一种解法：维护一个map，记录每个数字出现的次数。同时用变量记录出现次数最多的数字。返回出现次数最多的数字即可。 第二种解法：用变量记录出现数字，遍历数组，如果两个数字相同则变量加一，否则变量减一，减到0时则重新赋值新遍历，最后返回变量记录的数字即可。 代码实现1234567891011121314151617181920212223242526272829303132public class AlgoCasts &#123; // Time: O(n), Space: O(n) public int getMajorityWithHashMap(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int maxNum = 0, maxCount = 0; for (int num: nums) &#123; int newCnt = map.getOrDefault(num, 0) + 1; map.put(num, newCnt); if (newCnt &gt; maxCount) &#123; maxCount = newCnt; maxNum = num; &#125; &#125; return maxNum; &#125; // Time: O(n), Space: O(1) public int getMajority(int[] nums) &#123; int num = nums[0], count = 1; for (int i = 1; i &lt; nums.length; ++i) &#123; if (count == 0) &#123; num = nums[i]; count = 1; &#125; else if (nums[i] == num) &#123; ++count; &#125; else --count; &#125; return num; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最小深度]]></title>
    <url>%2F2017%2F08%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的最小深度 问题描述给定一棵二叉树，你要找到从根节点到最近的叶子节点的深度。12345678910111213141516171819比如说，给你的二叉树是： 1 / \ 2 4 / \ 8 16这棵树有 3 个叶子节点，分别是 2，8，16。最近的叶子节点是 2，根节点到 2 共有两个节点，因此最小深度是 2。再比如说，给你的二叉树是： 1 \ 2 \ 4这棵树唯一的叶子节点是 4，根节点到它共有 3 个节点，因此最小深度是 3。 解题思路根据一个树的左右节点是否为空来判断二叉树的最小深度 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041public class getMinDepth &#123; public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; // Time: O(n), Space: (n) public int minDepth(TreeNode root) &#123; if (root == null) return 0; if (root.left == null &amp;&amp; root.right == null) return 1; if (root.left == null) return minDepth(root.right) + 1; if (root.right == null) return minDepth(root.left) + 1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; &#125; // Time: O(n), Space: O(n) public int minDepthIterative(TreeNode root) &#123; if (root == null) return 0; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); int depth = 1; while (!q.isEmpty()) &#123; int size = q.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode s = q.poll(); if (s.left == null &amp;&amp; s.right == null) return depth; if (s.left != null) q.add(s.left); if (s.right != null) q.add(s.right); &#125; ++depth; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并两个有序数组]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[合并两个有序数组 问题描述给定两个递增排序的数组，你要把第二个数组合并到第一个，并使其仍然保持递增排序。两个数组中的元素个数会显式地给出，并且第一个数组的大小可以容纳下两个数组中所有的元素。12345678比如说给你的两个数组是：2, 4, _, _1, 3它们都有 2 个元素。并且第一个数组后面有足够的空间来填充第二个数组。把第二个数组合并到第一个数组后，得到的是：1, 2, 3, 4 解题思路确定第一个数组的长度是最长的，可以使用两个变量来分别控制两个数组的位置。 代码实现12345678910111213141516// 合并两个有序数组public class MergerSortArray &#123; public int[] getSortArray(int[] arr1, int[] arr2) &#123; int m = arr1.length; int n = arr2.length; int index = m + n -1; while (index &gt;= 0) &#123; if (m &lt; 0 || n &lt; 0) &#123; arr1[index--] = m &lt; 0 ? arr2[n--] : arr1[m--]; &#125; else &#123; arr1[index--] = arr1[m] &gt; arr2[n] ? arr1[m--] : arr2[n--]; &#125; &#125; return arr1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并两个有序链表]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[合并两个有序链表 问题描述这个题目说的是，给你两个递增排序的链表，你要把它们合成一个链表，并且保持递增排序。另外要求，新链表上的节点使用的就是旧的两个链表上的节点，不能创建新节点。123456789比如说，给你的两个链表 L1 和 L2，分别是：L1: 1 -&gt; 3L2: 2 -&gt; 4 -&gt; 6合并后的链表就是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 解题思路可以使用递归来实现合并两个有序链表。 代码实现1234567891011121314151617181920212223242526272829// 合并两个有序链表public class MergeListNode &#123; public class ListNode &#123; int value; ListNode next; ListNode(int value) &#123; this.value = value; &#125; &#125; public ListNode getMergeNode(ListNode l1, ListNode l2) &#123; ListNode head; if (l1 == null ) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else &#123; if (l1.value &lt; l2.value) &#123; head = l1; head.next = getMergeNode(l1.next, l2); &#125; else &#123; head = l2; head.next = getMergeNode(l1, l2.next); &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带有 min 函数的栈]]></title>
    <url>%2F2017%2F08%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%B8%A6%E6%9C%89%20min%20%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[带有 min 函数的栈 问题描述实现一个栈，除了提供 push，pop，top 等常用函数，还需要提供一个函数在 O(1) 时间内取得这个栈里的最小元素。 解题思路使用两个栈来实现此功能，其中一个栈与正常的栈相同，另外一个栈来存储最小的元素。 代码实现12345678910111213141516171819202122232425262728293031323334353637import java.util.Stack;// 带有min函数的栈public class MinStack &#123; Stack&lt;Integer&gt; stackData; Stack&lt;Integer&gt; stackMin; MinStack() &#123; stackData = new Stack&lt;Integer&gt;(); stackMin = new Stack&lt;Integer&gt;(); &#125; public void push(int value) &#123; if (stackMin.isEmpty()) &#123; stackMin.push(value); &#125; else if (stackMin.peek() &gt; value) &#123; stackMin.push(value); &#125; else &#123; stackMin.push(stackMin.peek()); &#125; stackData.push(value); &#125; public int pop() &#123; if (stackData.isEmpty()) &#123; throw new RuntimeException("You stack is empty!"); &#125; stackMin.pop(); return stackData.pop(); &#125; public int getMin() &#123; if (stackMin.isEmpty()) &#123; throw new RuntimeException("You stack is empty!"); &#125; return stackMin.peek(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子序列的最大和]]></title>
    <url>%2F2017%2F08%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[连续子序列的最大和 问题描述给定一个非空整数数组，你要找到和最大的连续子序列，然后返回它的和。12345比如说，给你的数组 a 是：2, -8, 3, -2, 4, -10和最大的连续子序列是 3, -2, 4, 他们的和是 5。 解题思路方法一：可以用暴力求解法，两层循环穷举出所有的子序列，然后进行求和，取出最大的子序列的和。 方法二：如果一个子序列的和为负数，那么这个子序列一定不是和最大的子序列。 代码实现123456789101112131415161718public class FindMaxArray &#123; public int maxSumOfSubArray(int[] nums) &#123; int max = Integer.MIN_VALUE, cur = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; cur = cur &lt;= 0 ? nums[i] : (cur + nums[i]); max = Math.max(max, cur); &#125; return max; &#125; public static void main(String[] args) &#123; int[] arr = new int[]&#123;2, -8, 3, -2, 4, -10&#125;; System.out.println(new FindMaxArray().maxSumOfSubArray(arr)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没有重复字符的最长子串长度]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[没有重复字符的最长子串长度 问题描述给定一个字符串，你要找到没有重复字符的最长子串，然后返回它的长度。123456789比如说给你的字符串 s 是：abcabcbb没有重复字符的最长子串是 abc，这里再往下的字符是 a，和前面这个 a 重复了。后面满足条件的子串还有 bca，cab，abc 等，不过它们的长度都是 3 ，因此返回的长度为 3。再比如说 ddd，没有重复字符的最长子串就是一个 d，因此你要返回的长度是 1。 解题思路用滑动窗口方法来实现 代码实现1234567891011121314151617181920212223242526272829import java.util.HashSet;import java.util.Set;public class FindMaxLenth &#123; // 用滑动窗口方法查找 public int getmaxLen(String str) &#123; if (str == null || str.length() == 0) &#123; return 0; &#125; int result = 0; int len = str.length(); int i = 0; int j = 0; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); while (i &lt; len &amp;&amp; j &lt; len) &#123; if (!set.contains(str.charAt(j))) &#123; set.add(str.charAt(j++)); result = Math.max(j - i, result); &#125; else &#123; set.remove(str.charAt(i++)); &#125; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(new FindMaxLenth().getmaxLen("abcabcbb")); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缺失的数字]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[缺失的数字 问题描述从 0 到 n 这 n+1 个整数中去掉一个，然后把剩下的 n 个整数放进一个长度为 n 的数组，给你这个数组，你要找到那个去掉的整数。12345比如说，给你的数组是：4, 1, 0, 2这里的数组长度是 4，说明这是从 0 到 4 中去掉一个数字后形成的数组。数组中缺失的数字是 3，因此我们要返回 3。 解题思路两个相同的数字异或结果为零。 因为是连续的数组，所以先把0-n个数先异或起来，再与数组中的数异或，这样就可以得到缺失的数字。 代码实现123456789101112public boolean judgeNodePalindrme(ListNode node) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (ListNode head = node; head != null; head = node.next) &#123; stack.push(head.value); &#125; for (ListNode head = node; head != null; head = node.next) &#123; if (head.value != stack.pop()) &#123; return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转二叉树]]></title>
    <url>%2F2017%2F08%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本篇博文介绍树这种数据结构，以及为什么要有平衡二叉树和二叉搜索树。 树的概念用来模拟具有树状结构的数据集合，树可视为具有N个节点和N-1条边的有向无环图。二叉树是一种更为经典的树状结构，二叉树是每个节点最多有两个字数的树状结构，通常字数被成为左子树和右子树。 树的遍历前序遍历：最先访问根节点，然后遍历左子树，最后遍历右子树。 中序遍历：先遍历左子树，然后访问根节点，最后遍历右子树 后序遍历：先遍历左子树，然后遍历右子树，最后遍历根节点 注：当删除树的节点时，删除过程将按照后序遍历的顺序进行，当删除一个节点时，要删除它的左节点和右节点，然后才能删除节点本身。 二叉搜索树满足下面条件的二叉树被称为二叉搜索树： 1：左子树节点的值小于等于父节点的值 2：右子树节点的值大于等于父节点的值 每个节点的值都满足上述条件，易于查找，但是二叉搜索树会出现不平衡的情况，即左子树和右子树的深度差距很大，如果二叉搜索树，只有右子树，就会变成链表，查找效率就会变得很查。对于查找而言，如果一颗二叉树的高度是N,那么最多可以在N步内完成查找，也就是说树的高度尽可能越矮查找会越快。考虑到查找情况，叶子节点到根节点的差距不能太大。所以我们希望二叉搜索树是一棵矮胖树，而不是一条链路的二叉搜索树。于是就出现了平衡二叉树 平衡二叉树满足下面条件的树被称为平衡二叉树： 1：它的左子树和右子树都是平衡二叉树。 2：左子树和右子树的深度差不能超过1 反转二叉树递归操作 123456789public static TreeNode invertNode(TreeNode root) &#123; if (root == null) &#123; return null; &#125; TreeNode temp = root.left; root.left = invertNode(root.right); root.right = invertNode(temp); return root;&#125; 非递归操作1234567891011121314151617181920public static TreeNode invertNode(TreeNode root) &#123; if (root == null) &#123; return null; &#125; Queue&lt;TreeNode&gt; treeQueue = new LinkedList&lt;TreeNode&gt;(); treeQueue.add(root); while (!treeQueue.isEmpty()) &#123; TreeNode current = treeQueue.poll(); TreeNode temp = current.left; TreeNode left = current.right; TreeNode right = temp; if (current.left != null) &#123; treeQueue.add(current.left); &#125; if (current.right != null) &#123; treeQueue.add(current.right); &#125; &#125; return root;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断单链表是否为回文链表]]></title>
    <url>%2F2017%2F08%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[判断单链表是否为回文链表 问题描述给定一个单链表表示的数，你要判断它是不是一个回文数字。回文数字就是正着读和反着读都相同的数字。1234567891011比如说，给你的链表是：4 -&gt; 2它表示 42，反过来是 24，不是一个回文数字，因此你要返回 false。再比如说，给你的链表是：4 -&gt; 2 -&gt; 2 -&gt; 4它表示 4224，反过来也是 4224，它是一个回文数字，因此你要返回 true。 解题思路使用一个额外的栈，遍历一次链表并存储链表的每一个节点的值。 继续遍历链表并且出栈判断与链表的每一个值是否相等。 代码实现123456789101112public boolean judgeNodePalindrme(ListNode node) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (ListNode head = node; head != null; head = node.next) &#123; stack.push(head.value); &#125; for (ListNode head = node; head != null; head = node.next) &#123; if (head.value != stack.pop()) &#123; return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文数字的判断]]></title>
    <url>%2F2017%2F08%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[回文数字的判断 问题描述给定整数，你要判断它是否是一个回文数字。所谓回文数字就是，你正着读和反着读都是同一个数字。1234567891011比如，给你的数字是：12321无论你从左向右读，还是从右向左读，都是 12321，所以它是一个回文数字，你要返回 true。再比如说：-232你从左向右读是 -232，但从右向左读则是 232-，和 -232 不一样，因此它不是一个回文数字，你要返回 false。 解题思路可以把数字转换成字符串进行比较是否为回文字符串。 代码实现12345678910111213141516171819202122232425public static boolean judgePalindrome(int num) &#123; String str = String.valueOf(num); int i = 0; int j = str.length() - 1; while (i &lt; j) &#123; if (str.charAt(i) != str.charAt(j)) &#123; return false; &#125; i++; j--; &#125; return true;&#125;public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int tmp = x; long y = 0; while (tmp != 0) &#123; int num = tmp % 10; y = y * 10 + num; tmp = tmp / 10; &#125; return y == x;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文子串个数]]></title>
    <url>%2F2017%2F08%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[回文子串个数 问题描述给定一个字符串，你要计算出它所包含的回文子串个数。只要起始下标或终止下标不同，即使子串相同，我们也认为是不同的回文子串。1234567891011比如说，给你的字符串是：abc这个字符串中总共有 3 个回文子串，分别是 a， b 和 c。因此你要返回的个数是 3。再比如说，给你的字符串是：aba这个字符串中总共有 4 个回文子串，分别是 a，b，a，和 aba。因此你要返回的个数是 4。 解题思路这是一道动态规划问题 动态规划：通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。 首先需要两个变量来控制子串。第一个变量a指向数组的末尾，依次递减，第二个变量b从a开始，依次递增。两层for循环就能遍历所有的子串。 判断是否为回文字符串的方法，如果变量a和b相等，则证明指向同一个字符串，是回文字符传，如果a和b相差1，则说明两个字符为相邻字符，如果这两个字符相等的话，则证明是回文字符串。两个字符不相邻，则判断这两个字符是否相等并且判断a+1、b-1是否为回文字符串。 代码实现1234567891011121314151617181920212223public int getCountPalindrome(String str) &#123; if (str == null || str.length() == 0) &#123; return 0; &#125; int length = str.length(); int result = 0; boolean[][] count = new boolean[length][length]; for (int i = str.length() - 1; i &gt; 0; i--) &#123; for (int j = i; j &lt; str.length() - 1; j++) &#123; if (i == j) &#123; count[i][j] = true; &#125; else if (i + 1 == j) &#123; count[i][j] = str.charAt(i) == str.charAt(j); &#125; else &#123; count[i][j] = str.charAt(i) == str.charAt(j) &amp;&amp; count[i+1][j-1]; &#125; if (count[i][j]) &#123; result++; &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[括号的合法排序]]></title>
    <url>%2F2017%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%90%88%E6%B3%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[括号的合法排序 问题描述这个题目说的是，给你 n 对括号，你要返回这 n 对括号的所有合法排列方式 12345678比如说，n 等于 3 时，合法的排列有 5 个： ((())) (()()) (())() ()(()) ()()() 解题思路根据上面的描述，可以找到规律，首先先写出n个左括号，然后依次写出右括号。 代码实现12345678910111213141516171819202122232425262728293031public class AIMain &#123; public static List&lt;String&gt; getList(int n) &#123; if (n &lt;= 0) &#123; return new ArrayList&lt;String&gt;(); &#125; List&lt;String&gt; resultList = new ArrayList&lt;String&gt;(); genStr(resultList, n, n, ""); return resultList; &#125; public static void genStr(List&lt;String&gt; resultList, int left, int right, String str) &#123; if (left == 0 &amp;&amp; right == 0) &#123; resultList.add(str); &#125; else &#123; if (left &gt; 0) &#123; genStr(resultList, left -1, right, str + "("); &#125; if (right &gt; left) &#123; genStr(resultList, left, right - 1, str + ")"); &#125; &#125; &#125; public static void main(String[] args) &#123; List&lt;String&gt; resultList = getList(3); for (String str : resultList) &#123; System.out.println(str); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2F2017%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转单向链表和双向链表 问题描述给定一个单链表，你需要反转它，然后返回。1234567比如说给你的单链表是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null你要返回的反转后的链表是：5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null 解题思路反转单向链表和双向链表实现的大体思路基本一致。 代码实现1234567891011121314151617181920212223242526反转单向链表public class ReserveNode &#123; class ListNode &#123; int value; ListNode next; ListNode(int value) &#123; this.value = value; &#125; &#125; public ListNode reserve(ListNode head) &#123; if (node == null) &#123; return null; &#125; ListNode pre = null; ListNode next = null; while(head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125; 12345678910111213141516171819202122232425262728反转双向链表public class ReserveNode &#123; class ListNode &#123; int value; ListNode next; List Node last; ListNode(int value) &#123; this.value = value; &#125; &#125; public ListNode reserve(ListNode head) &#123; if (node == null) &#123; return null; &#125; ListNode pre = null; ListNode next = null; while(head != null) &#123; next = head.next; head.next = pre; head.last = next; pre = head; head = next; &#125; return pre; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列递增的二维数组搜索]]></title>
    <url>%2F2017%2F08%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E7%BB%84%E5%85%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[数组全排序 问题描述给定一个整数数组，并且数组中没有重复元素，你要返回这个数组所有可能的排列。123456789101112比如说给你的数组是：0, 1, 2你要返回的所有排列是：0, 1, 20, 2, 11, 0, 21, 2, 02, 0, 12, 1, 0 解题思路这是一道回溯问题，从看到这道题到大致了解代码大概花了两天左右的时间。 首先将所有的数组中元素都与第一个数组交换，剩下的继续这个操作。 代码实现12345678910111213141516171819public void allSort(int[] nums, int start, int end) &#123; if (start == end) &#123; System.out.println(Arrays.toString(nums)); return; &#125; // 把数组中的第一个元素依次和第二个第三个元素依次交换 for (int i = start; i &lt;= end; i++) &#123; swap(nums, start, i); allSort(nums, start + 1, end); // 交换回来 swap(nums, start, i); &#125;&#125;static void swap(int[] array,int a,int b)&#123; int tem=array[a]; array[a]=array[b]; array[b]=tem;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断二叉树是否相同]]></title>
    <url>%2F2017%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%2F</url>
    <content type="text"><![CDATA[判断二叉树是否相同 问题描述给定两个二叉树，你要判断它们是否相同。这里所谓相同，指的是两棵树结构相同，并且相应节点上的数值相等。123456789101112131415161718192021比如说，给你的两棵二叉树都是： 1 1 / \ / \ 2 4 2 4它们的结构相同，相应节点上的值也相等，因此返回 true。 如果另一棵树是： 1 / \ 2 5或 1 / 2 /4两棵树则不相同，返回 false。 解题思路这道题目与判断二叉树是否对称 解题思路基本一致，可以用递归遍历二叉树中的每一个节点的值，进行判断是否相等，也可以用额外的栈来进行存储遍历 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Stack;// 判断两个二叉树是否相等public class JudgeSameBinaryTree &#123; class TreeNode &#123; int value; TreeNode left; TreeNode right; TreeNode(int value) &#123; this.value = value; &#125; &#125; public boolean JudgeTreeMethodOne(TreeNode a, TreeNode b) &#123; if (a == null &amp;&amp; b == null) &#123; return true; &#125; if (a == null || b == null) &#123; return false; &#125; return a.value == b.value &amp;&amp; JudgeTreeMethodOne(a.left, b.left) &amp;&amp; JudgeTreeMethodOne(a.right, b.right); &#125; public boolean JudgeTreeMethodTwo(TreeNode a, TreeNode b) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(a); stack.push(b); while (!stack.isEmpty()) &#123; TreeNode p = stack.pop(); TreeNode q = stack.pop(); if (p == null &amp;&amp; q == null) &#123; continue; &#125; if (a == null || b == null) &#123; return false; &#125; if (a.value != b.value) &#123; return false; &#125; stack.push(p.left); stack.push(q.left); stack.push(p.right); stack.push(q.right); &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列递增的二维数组搜索]]></title>
    <url>%2F2017%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E8%A1%8C%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[行列递增的二维数组搜索 问题描述给定一个二维数组 matrix，和一个目标值target。你要在数组里找到这个目标值，然后返回它的行/列下标。如果找不到，则返回 [-1,-1]。 这个数组的每一行都是从左向右递增，每一列都是从上到下递增。和「二维数组的二分搜索」不同，这道题目并不保证每一行的第一个数都比上一行的最后一个数要大。123456789比如说，给你的二维数组是：1, 3, 52, 4, 67, 8, 9给你的目标值是 4。目标值4在这个数组中，找到后返回它的下标 [1, 1] 即可。如果给你的目标值是 100，显然它不在这个二维数组中，你要返回 [-1，-1]。 解题思路首先将目标锁定为第一行的最后一列，也就是二维数组5的位置。然后比较与4的大小，很显然比4大，由于是递增的二维数组，那么第二、三列的数字肯定都比目标值大，向左移动，比较3与目标值的大小，如果比目标值小的话，那么这行的左边的数字肯定都比目标值要小，向下移动。 代码实现1234567891011121314151617181920212223242526272829303132333435// 在递增的二维数组中查询目标值public class FindTargetNum &#123; // Time: O(m+n), Space: O(1) private int[] findNumber(int[][] arr, int target) &#123; int row = 0; int col = arr[0].length - 1; while (row &lt; arr.length &amp;&amp; col &gt; -1) &#123; if (arr[row][col] == target) &#123; return new int[] &#123;row, col&#125;; &#125; else if (arr[row][col] &gt; target) &#123; col--; &#125; else &#123; row++; &#125; &#125; return new int[] &#123;-1, -1&#125;; &#125; public static void main(String[] args) &#123; int[][] matrix = new int[][] &#123; &#123; 0, 1, 2, 3, 4, 5, 6 &#125;,// 0 &#123; 10, 12, 13, 15, 16, 17, 18 &#125;,// 1 &#123; 23, 24, 25, 26, 27, 28, 29 &#125;,// 2 &#123; 44, 45, 46, 47, 48, 49, 50 &#125;,// 3 &#123; 65, 66, 67, 68, 69, 70, 71 &#125;,// 4 &#123; 96, 97, 98, 99, 100, 111, 122 &#125;,// 5 &#123; 166, 176, 186, 187, 190, 195, 200 &#125;,// 6 &#123; 233, 243, 321, 341, 356, 370, 380 &#125; // 7 &#125;; int[] resultArr = new FindTargetNum().findNumber(matrix, 233); System.out.println(resultArr[0]); System.out.println(resultArr[1]); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单身数字]]></title>
    <url>%2F2017%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%8D%95%E8%BA%AB%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[单身数字 问题描述给定一个非空的整数数组，这个数组中有一个整数只出现了一次，其它的整数都出现两次，你要找出这个只出现一次的整数。12345比如说，给你的数组是：5, 7, 5, 6, 6这里 7 只出现了一次，因此你要返回的就是 7。 解题思路这道题可以共有两种解法：可以用set集合来进行过滤数组里面的数字，此时set集合里面是5,6,7。然后相加乘以2再减去原来数组中的和 就得出单身数组 第二种方法比价简单，所有的元素进行异或得出的结果就是单身数字 代码实现123456789101112131415161718192021222324252627282930313233import java.util.HashSet;import java.util.Set;// 找到单身数字public class FindSingleNumber &#123; // Time: O(n), Space: O(n) public int findNumberMethodOne(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return -1; &#125; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int setSum = 0; int arrSum = 0; for (int num : arr) &#123; arrSum += num; if (!set.contains(num)) &#123; setSum += num; set.add(num); &#125; &#125; return setSum * 2 - arrSum; &#125; //Time: O(n), Space: O(1) public int findNumberMethodTwo(int[] arr) &#123; int result = 0; for (int num : arr) &#123; result ^= num; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断二叉树是否对称]]></title>
    <url>%2F2017%2F07%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[判断二叉树是否对称 问题描述给定一个二叉树，你要判断它是否沿中轴线对称。1234567891011121314151617比如说，给你的二叉树是： 1 / \ 2 2 / \ / \4 8 8 4这棵二叉树是沿中轴线对称的，因此要返回 true。如果我去掉最后这个 4： 1 / \ 2 2 / \ /4 8 8就不对称了，这时就要返回 false。 解题思路求对称二叉树，肯定要遍历树的所有节点。具体有两种方式，递归遍历。除此之外，所有的递归都是系统实现栈，并且把所有的当前数据压倒栈中，所以所有的递归操作都可以自己实现一个栈。进行压栈和弹栈。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 判断二叉树是否对称public class FindSortArrayTarget &#123; public class TreeNode &#123; int value; TreeNode left; TreeNode right; TreeNode(int value) &#123; this.value = value; &#125; &#125; // Time: O(n), Space: O(n) public boolean isSymmetricTreeRecursive(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return judgeBalance(root.left, root.right); &#125; boolean judgeBalance(TreeNode left, TreeNode right) &#123; if (left != null &amp;&amp; right != null) &#123; return left.value == right.value &amp;&amp; judgeBalance(left.left, right.right) &amp;&amp; judgeBalance(left.right, right.left); &#125; else &#123; return right == null &amp;&amp; left == null; &#125; &#125; // Time: O(n), Space: O(n) public boolean judgeBalanceByStack(TreeNode root) &#123; if (root == null) &#123; return true; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(root.right); stack.push(root.left); while (!stack.isEmpty()) &#123; TreeNode left = stack.pop(); TreeNode right = stack.pop(); if (left == null &amp;&amp; right == null) &#123; continue; &#125; if (left == null || right == null) &#123; return false; &#125; if (left.value != right.value) &#123; return false; &#125; stack.push(left.left); stack.push(right.right); stack.push(left.right); stack.push(right.left); &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有序数组中求和为给定值的两个数]]></title>
    <url>%2F2017%2F07%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有序数组中求和为给定值的两个数 问题描述给定一个整数数组，并且这个数组是按递增排序的，你要找到数组中的两个整数，它们的和等于给定的目标值，然后返回它们的下标。题目假设给你的数组总是有且只有一个解，而且同一个元素不能使用两次。另外，返回结果的下标要从 1 开始。12345比如说给你的数组是：1, 2, 3, 6, 8, 11目标值是 10。那么，满足条件的两个整数是，2 和 8，它们的和是 10。所以你要返回它们的下标是 [2, 5]。 解题思路看到这道题的第一印象，感觉和上一篇求和为定值的两个数是差不多，当然可以用暴力破解法，也可以使用额外的哈希表来求出位置，但是除此之外，作者又找到一种非常非常简便的解法。 因为是设计到有序的数组，所以可以使用两个指针来指向数组的左右两端。左右两端的数相加，如果比目标值大的话，指向最大值的指针向左移动。如果相加的值比目标值小的话，指向最小值的指针向右移动。 代码实现123456789101112131415// Time: O(n), Space: O(1)public int[] getTargetArr(int[] arr, int target) &#123; int a = 0; int b = arr.length -1; while (a &lt; b) &#123; if (arr[a] + arr[b] == target) &#123; return new int[] &#123;a, b&#125;; &#125; else if (arr[a] + arr[b] &gt; target) &#123; b--; &#125; else &#123; a++; &#125; &#125; return new int[] &#123;-1, -1&#125;;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求和为给定值的两个数]]></title>
    <url>%2F2017%2F07%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%B1%82%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[求和为给定值的两个数 问题描述给定一个整数数组和一个目标值，你要找到数组里两个整数，它们的和等于目标值。然后返回这两个整数的下标。12345比如说给你的整数数组是：1, 2, 3, 6, 8, 11目标值是 10。那么，满足条件的两个整数是，2 和 8，它们的和是 10。所以你要返回它们的下标是 1 和 4。 解题思路最开始看到这道题是 在公司的校招笔试题当中。 最开始想到的是 使用暴力破解法，直接两层循环，找到两个数相加等于目标值，但是这样做的时间复杂度为O(n^2) 之后又在网上看到可以使用hashmap的解法。 代码实现123456789101112131415161718192021222324252627// Time：O(n) Space: O(1) n为字符串的长度public class Palindrome &#123; //Time: O(n^2), Space: O(1) public static int[] getArray(int[] arr, int target) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; if (arr[i] + arr[j] == target) &#123; return new int[] &#123;i, j&#125;; &#125; &#125; &#125; return new int[] &#123;-1,-1&#125;; &#125; //Time: O(n), Space: O(n) public static int[] getArrayByHash(int[] arr, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; if (map.containsKey(target - arr[i])) &#123; return new int[] &#123;map.get(target - arr[i]), i&#125;; &#125; map.put(arr[i], i); &#125; return new int[] &#123;-1, -1&#125;; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中查找问题]]></title>
    <url>%2F2017%2F07%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是本人第一篇记录算法的博客，题目是《剑指offer》的第一道算法题，刚开始看到这道题的时候，直接想到的是两层for循环，遍历数据去判断包不包含目标整数。写完执行成功，但是在网上看到其他更加优雅的写法。下面是优化前和优化后的代码比对。写这篇博客的原因是因为开始的时候觉得这道题目很简单，看完开始coding，提醒自己无论问题的大小，要仔细认证的思考，要时刻保持谦逊认真的态度。 问题描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 代码展示1234567891011121314151617181920212223242526272829303132// 优化前代码public class Solution &#123; public boolean Find(int target, int [][] array) &#123; for(int i = 0; i &lt; array.length; i++)&#123; for(int j = 0; j &lt; array[i].length; j++)&#123; if(array[i][j] == target)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125;// 优化后代码public class Solution &#123; public boolean Find(int [][] array,int target) &#123; int len = array.length-1; int i = 0; while((len &gt;= 0)&amp;&amp; (i &lt; array[0].length))&#123; if(array[len][i] &gt; target)&#123; len--; &#125;else if(array[len][i] &lt; target)&#123; i++; &#125;else&#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2017%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用两个栈实现队列 问题描述编写一个类，用两个栈实现队列，支持队列的基本操作（add,poll,peek） 解题思路栈是先进后出，队列是先进先出，用两个栈实现队列只要进出stackPush和stackPop两个栈即可，但是要注意两个问题。 1：如果stackPush要往stackPop压入时，要将其全部数据压入 2：如果stackPop不为空，则stackPush决不能向stackPop压入 代码实现1234567891011121314151617181920212223242526272829303132333435public class TwoStackQueue &#123; public Stack&lt;Integer&gt; pushStack; public Stack&lt;Integer&gt; popStack; public TwoStackQueue()&#123; pushStack = new Stack&lt;Integer&gt;(); popStack = new Stack&lt;Integer&gt;(); &#125; public void add(int pushInt) &#123; pushStack.push(pushInt); &#125; pubic int poll() &#123; if (popStack.empty() &amp;&amp; pushStack.empty()) &#123; throw new runtimeExecption(); &#125; else if (popStack.empty()) &#123; while(!pushStack.empty()) &#123; popStack.push(pushStack.pop()); &#125; &#125; return popStack.pop(); &#125; public int peek() &#123; if (popStack.empty() &amp;&amp; pushStack.empty()) &#123; throw new runtimeExecption(); &#125; else if (popStack.empty()) &#123; while(!pushStack.empty()) &#123; popStack.push(pushStack.pop()); &#125; &#125; return popStack.peek(); &#125; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文字符串的判断]]></title>
    <url>%2F2017%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[回文字符串的判断 问题描述给定一个字符串，你要判断它是否是回文字符串。字符串里只考虑字母和数字，其它的字符可以无视。另外，对于字母，可以忽略大小写。123456789比如说，给你的字符串是：&quot; race a E-car &quot;只考虑字母数字并且忽略大小写，它是一个回文字符串，因此返回 true。再比如说，给你的字符串是&quot; race a car &quot;对比到最后，中间的 e 和 a 不相等，因此不是一个回文字符串，返回 false。 解题思路这个问题主要难点就是判断一个字符是否为字母和数字，并且将大写字母转换为小写字母。 本题的实现可以使用两个辅助变量来遍历数组 代码实现123456789101112131415161718192021222324252627282930313233343536// Time：O(n) Space: O(1) n为字符串的长度public class Palindrome &#123; private boolean isAlphanumeric(char c) &#123; return ((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt; 'Z') || (c &gt;= '0' &amp;&amp;c &lt;= '9')); &#125; private boolean isEqualCase(char a, char b) &#123; if (a &gt;= 'A' &amp;&amp; a &lt;= 'z') &#123; a += 32; &#125; if (b &gt;= 'A' &amp;&amp; b &lt;= 'z') &#123; b += 32; &#125; return a == b; &#125; public boolean isPalindrome(String str) &#123; if (str == null || str.length() == 0) &#123; return true; &#125; int i = 0; int j = str.length() - 1; for (; i &lt; j; i++, j--) &#123; while (i &lt; j &amp;&amp; !(isAlphanumeric(str.charAt(i)))) &#123; i++; &#125; while (i &lt; j &amp;&amp; !isAlphanumeric(str.charAt(j))) &#123; j++; &#125; if (i &lt; j &amp;&amp; !(isEqualCase(str.charAt(i), str.charAt(j)))) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithm，数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2017%2F07%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介适配器模式是将某个类的接口转换成客户端期望的另一个接口表示，主要的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装类（Wrapper）。 使用场景一个适配器使得因接口不兼容而不能在一起工作的类一起工作，做法是将类自己的接口包裹在一个已存在的类中。 系统需要使用现有类，而这些类的接口不符合系统的需求。 想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括可能在将来引进的类一起工作。 需要一个统一的接口，而输入端的类型不可预知。 举例说明：鸭子Duck和火鸡Turkey拥有不同的叫声，Duck的叫声调用quack()方法，Turkey的叫声调用gobble()方法。要求将Turkey的gobble()方法适配成quack()方法，从而让火鸡冒充鸭子！ 实现方法123public interface Duck &#123; void quack();&#125; 123public interface Turkey &#123; void gobble();&#125; 12345public class WildTurkey implements Turkey &#123; public void gobble() &#123; System.out.println("Globble!"); &#125;&#125; 123456789public TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; public void quack() &#123; turkey.glbble(); &#125;&#125; 1234567public class Client &#123; public static void main(String[] args) &#123; Turkey turkey = new WildTurkey(); Duck duck = new TurkeyAdapter(turkey); duck.quack(); &#125;&#125;]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2017%2F07%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍模板方法模式指的是定义了一个模板，将具体的内容延迟到子类去实现。其主要作用是在不改变模板的前提下在子类中重新定义模板的内容。模板方法模式是基于继承的方式实现的。主要解决的问题是提高了代码的复用性和实现了反向控制。提高代码的复用性指的是将相同部分的代码放到抽象类中，将不同的代码放到不同的子类中。实心反向控制是指通过一个父类调用子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合“开闭原则”。 案例演示通过一个抽象类定义执行方法的具体流程（抽象方法），由子类实现抽象方法，通过父类引用，子类实例化的方式实现改流程。 代码实现模板方法：1234567891011121314151617181920212223242526272829public abstract class Template &#123; //这是我们的模板方法 public final void TemplateMethod()&#123; PrimitiveOperation1(); PrimitiveOperation2(); PrimitiveOperation3(); &#125; protected void PrimitiveOperation1()&#123; //当前类实现 &#125; //被子类实现的方法 protected abstract void PrimitiveOperation2(); protected abstract void PrimitiveOperation3();&#125;public class TemplateImpl extends Template &#123; @Override public void PrimitiveOperation2() &#123; //当前类实现 &#125; @Override public void PrimitiveOperation3() &#123; //当前类实现 &#125;&#125; 总结模板方法模式：定义了一个算法流程，将一些步骤的具体实现延迟到子类。使得可以不改变算法流程的情况下，通过不同的子类，来定制流程中特定步骤 策略模式：使不同算法可以相互替换，而不影响客户端的使用。]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2017%2F07%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在日常的开发中，可以使用工厂模式来进行实例化对象，提高程序的耦合度，通过前面简单工厂模式可知，工厂的目的是为了帮助我们创建对象的实例，并且可以隐藏类名和其实现的过程，从而无需关注对象的创建，简单工厂模式可以算是工厂方法模式的入门模式。 工厂方法模式的意义就是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。核心工厂类不再负责产品的创建，这样核心类就成为一个抽象工厂的角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象话的好处是使得工厂方法模式可以使系统在不修改具体工厂角色下引进新的产品。 代码实现定义一个工厂类接口:123public interface Factory&#123; public Operactory createOperaction();&#125; 定义具体的工厂类： 1234567891011121314151617181920212223242526272829303132333435// 加法类工厂public class AddFactory implements Factory&#123; public Operation createOperation() &#123; System.out.println("加法运算"); return new Add(); &#125;&#125;// 减法类工厂public class SubFactory implements Factory&#123; public Operation createOperation() &#123; System.out.println("减法运算"); return new Sub(); &#125;&#125;// 乘法类工厂public class MulFactory implements Factory&#123; public Operation createOperation() &#123; System.out.println("乘法运算"); return new Mul(); &#125;&#125;// 除法类工厂public class DivFactory implements Factory&#123; public Operation createOperation() &#123; System.out.println("除法运算"); return new Div(); &#125;&#125;]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2017%2F06%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式是为已有的功能动态的添加更多功能的一种方式 前言装饰模式是在不改变原类，使用继承的情况下，动态扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实对象。 实现代码首先创建一个等待装饰的接口Component123public interface Component &#123; void method();&#125; 接下来就是一个具体的接口实现类，俗称原始对象12345public class ConcreteComponent implements Component &#123; public void method() &#123; System.out.println("原始方法"); &#125;&#125; 接下来用装饰器模式来扩展对象，首先创建一个包装抽象类来实现待包装的接口(抽象装饰器父类)。12345678910public abstract class Decorator implements Component &#123; private Component component; public Decorator (Component component) &#123; super(); this.component = component; &#125; public void method() &#123; component.method(); &#125;&#125; 下面是我们的装饰器A和装饰器B123456789101112131415161718package com.decorator;public class ConcreteDecoratorA extends Decorator&#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; public void methodA()&#123; System.out.println("被装饰器A扩展的功能"); &#125; public void method()&#123; System.out.println("针对该方法加一层A包装"); super.method(); System.out.println("A包装结束"); &#125;&#125; 123456789101112131415161718package com.decorator;public class ConcreteDecoratorB extends Decorator&#123; public ConcreteDecoratorB(Component component) &#123; super(component); &#125; public void methodB()&#123; System.out.println("被装饰器B扩展的功能"); &#125; public void method()&#123; System.out.println("针对该方法加一层B包装"); super.method(); System.out.println("B包装结束"); &#125;&#125; 测试类 12345678910111213141516171819202122package com.decorator;public class Main &#123; public static void main(String[] args) &#123; Component component =new ConcreteComponent();//原来的对象 System.out.println("------------------------------"); component.method();//原来的方法 ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(component);//装饰成A System.out.println("------------------------------"); concreteDecoratorA.method();//原来的方法 concreteDecoratorA.methodA();//装饰成A以后新增的方法 ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(component);//装饰成B System.out.println("------------------------------"); concreteDecoratorB.method();//原来的方法 concreteDecoratorB.methodB();//装饰成B以后新增的方法 concreteDecoratorB = new ConcreteDecoratorB(concreteDecoratorA);//装饰成A以后再装饰成B System.out.println("------------------------------"); concreteDecoratorB.method();//原来的方法 concreteDecoratorB.methodB();//装饰成B以后新增的方法 &#125;&#125; 和其他设计模式的区别装饰器设计模式：原来的方法已经不能满足需求，需要对其进行扩展，理论上我们可以无限的装饰下去，比如在设计之前加一个需求分析。也可以去掉某个装饰器 适配器设计模式：原来的接口已经不兼容了，适配器在原对象和目标对象中间，通过对原对象兼容的那个接口，通过转换，调用目标对象那个不兼容的接口。举个不恰当的例子，一个英国人去买饭，听不懂中国服务员说什么（接口不兼容），这时候来了一个翻译（适配器），他能与英国人交流（接口适配成功），然后翻译不干活，而是通过中国服务员的活动，将结果再返回给英国人。 代理模式：你们要实现什么功能我不管，我只负责调用该调用的方法。有点类似前台MM，你们干什么我不管，你就告诉我你找谁，我给你找去。]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAop的动态代理]]></title>
    <url>%2F2017%2F06%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FSpringAop%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[面向切面编程：面向切面编程是对面向对象编程的一种补充，面向对象编程更多指的是从上到下的关系（继承，封装，多态），面向切面编程更多指的是横向的关系，从左向右的，比如实现一个类的方法，代码肯定是继承或者注入这个类，然后执行这个类中的方法。如果类或者类中的方法发生改变，其他引用的地方也是发生改变（耦合性比较大），而面向切面可以将这种方法抽离出切面，然后将切面织入到代码中。主要使用两个注解（@Aspect：声明切面，@Poincut:通知，在哪些类的哪些方法执行，advice表达在方法执行的什么时机去执行切面的内容）。 主要功能：日志记录，事物处理，安全控制，异常处理 主要意图：扩展功能时不修改源代码，将功能代码从业务逻辑代码中分离出来。通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。 简介根据静态代理介绍大家会发现，一个目标类对应着一个代理类，但是在实际的开发过程当中，如果有多个目标类需要被代理，那么动态代理就是我们所需要的。动态代理是JDK5引入的，在动态代理中，代理类并不是java代码锁实现的，而是运行期由JVM根据反射等机制动态生成，和静态代理相比，动态代理可以很好的对多个类进行统一的处理，java动态代理分为jdk代理和cglib代理。 JDK动态代理java.lang.reflect.proxy(类)和java.lang.reflect.InvocationHandler(接口)是动态代理最核心的两个类。这里不会详细的介绍这两个类，主要看一下相关的方法。 Subject定义的目标类接口：123public interface Subject &#123; public void eat();&#125; RealSubject要被代理的目标类12345public class RealSubject implements Subject &#123; public void eat() &#123; System.out.println("eat"); &#125;&#125; 此处是重点动态创建代理对象的类 12345678910111213141516171819202122232425public class MyProxy implements InvocationHandler &#123; //目标对象 private Object object; //与具体的实现类绑定关系 public Object newProxyInstance(Object object)&#123; this.object = object; //获取生成代理对象的类加载器,负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。 每次生成动态代理类对象时都需要指定一个类加载器对象 ClassLoader loader = object.getClass().getClassLoader(); //获取当前类（即object）实现的接口列表 Class&lt;?&gt;[] interfaces = object.getClass().getInterfaces(); //根据传入的参数返回一个代理对象 return Proxy.newProxyInstance(loader, interfaces, this); &#125; //该方法负责集中处理动态代理类上的所有方法调用。第一个参数既代理类实例，第二个参数是被调用的方法对象,第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //原对象方法调用之前处理 System.out.println("before"); //目标方法执行 Object result = method.invoke(object, args); //原对象方法调用之后处理 System.out.println("after"); return result; &#125;&#125; 动态代理实现的步骤：123456789// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用InvocationHandler handler = new InvocationHandlerImpl(..);// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象Class clazz = Proxy.getProxyClass(classLoader, new Class[] &#123; Interface.class, ... &#125;);// 通过反射从生成的类对象获得构造函数对象Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;);// 通过构造函数对象创建动态代理类实例Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123; handler &#125;); Proxy类的静态方法newProxyInstance对上面的具体步骤的后三步做了封装，简化了动态代理对象的获取过程。 newProxyInstance方法12345// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发InvocationHandler handler = new InvocationHandlerImpl(..);// 通过 Proxy 直接创建动态代理类实例Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, new Class[] &#123; Interface.class &#125;, handler ); 源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@CallerSensitive//为了避免双重反射的注解，就是堵漏洞的public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; //执行权限检查 checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. * 查找或生成指定的代理类 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler.使用指定的调用处理程序调用其构造函数 */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 获取代理类的方法getProxyClass：123456789private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; //检查实现的接口数，65535这个数字好特殊，端口数好像也是这个，这个数字是由虚拟机所决定的，2^16-1个 if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; //如果由给定的加载器实现给定的接口定义的代理类存在，这将简单地返回缓存的副本;否则，它将通过ProxyClassFactory创建代理类 return proxyClassCache.get(loader, interfaces); &#125; 继续跟着代码可以看到真正实现代理类的是私有类ProxyClassFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; //所有代理类名称的前缀 private static final String proxyClassNamePrefix = "$Proxy"; //用于生成唯一代理类名称的下一个数字 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; //验证类加载器是否将此接口的名称解析为同一个Class对象。 Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; //验证Class对象实际上代表一个接口。 if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; //验证这个接口不是重复的。 if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; //记录一个非公开代理接口的包，以便在同一个包中定义代理类。验证所有非公开的代理接口是否在同一个包中。 for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; //如果没有非公开的代理接口，请使用com.sun.proxy包 proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; //为要生成的代理类选择一个名称。 long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; //生成指定的代理类。 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125; JDK中动态代理，实现的步骤为：1.创建代理类的源码；2.对源码进行编译成字节码；3.将字节码加载到内存；4.实例化代理类对象并返回给调用者； 反编译生成的代理类,可以看出是继承Proxy类的，由于java是单继承的，所以jdk动态代理只能代理接口，不能代理抽象类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import designpatterns.dynproxy.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy1 extends Proxy implements Subject&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy1(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void eat() &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m3 = Class.forName("designpatterns.dynproxy.Subject").getMethod("eat", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125; 总结优点：动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强。缺点：诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。 cglib代理上面说jdk动态代理通过反射类Proxy和InvocationHandler回调接口实现，要求委托类必须实现一个接口，只能对该类接口中定义的方法实现代理，这在实际编程中有一定的局限性。cglib代理并不要求委托类必须实现接口，是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 实例 委托类12345public class RealSubject &#123; public void eat() &#123; System.out.println("eat"); &#125;&#125; 生成代理类123456789101112131415161718192021222324public class MyMethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class&lt;?&gt; clazz)&#123; enhancer.setSuperclass(clazz); enhancer.setCallback(new MethodInterceptor()&#123; /** * 拦截所有目标类方法的调用 * * o目标实例对象 * method 目标方法的反射对象 * objects方法的参数 * methodProxy代理类的实例 */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("Before:" + method); Object object = methodProxy.invokeSuper(o, objects); System.out.println("After:" + method); return object; &#125; &#125;); return enhancer.create(); &#125;&#125; 测试类1234567public class Test &#123; public static void main(String[] args) &#123; MyMethodInterceptor myMethodInterceptor = new MyMethodInterceptor(); RealSubject realSubject = (RealSubject) myMethodInterceptor.getProxy(RealSubject.class); realSubject.eat(); &#125;&#125; 结果123Before:public void designpatterns.cglibproxy.RealSubject.eat()eatAfter:public void designpatterns.cglibproxy.RealSubject.eat() 代理对象的生成过程由Enhancer类实现，大概步骤如下：1、生成代理类Class的二进制字节码；2、通过Class.forName加载二进制字节码，生成Class对象；3、通过反射机制获取实例构造，并初始化代理类对象。 Enhancer类，Enhancer是CGLib的字节码增强器，可以方便的对类进行扩展，内部调用GeneratorStrategy.generate方法生成代理类的字节码。该Enhancer动态创建一个给定类型的子类，拦截所有的方法调用。除了Proxy类之外，这对于类和接口类型都适用。 有兴趣的同学可以自行反编译生成的代理类进行分析。这里就不做具体介绍了。 jdk和cglib动态代理实现的区别1.jdk动态代理生成的代理类和委托类实现了相同的接口；2.cglib动态代理中生成的字节码更加复杂，生成的代理类是委托类的子类，且不能处理被final关键字修饰的方法；3.jdk采用反射机制调用委托类的方法，cglib采用类似索引的方式直接调用委托类方法； 由于本人知识有限，如有错误欢迎指正。]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2017%2F06%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义策略模式（strategy）:它定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。 实例策略模式是一种定义一系列算法的方法，从概念上讲，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的算法调用所有的算法，减少了各种算法类和使用算法类之间的耦合。 在《大话设计模式中》举了一个很形象的收银系统，打折和减免，面向对象的编程，并不是类越多越好，类的划分是为了封装，但是分类的基础是为了抽象，具有相同属性和功能的对象的抽象集合才是类。所以打折算法是一个类，减免算法是一个类。 策略代码的实现 定义了一个收银的接口Cash，三种收银策略CashNormal(正常)，CashRebate(打折)，CashReturn(减免)。还有具体策略的类Context。 策略接口(收银系统) 1234package designpatterns.strategy;public interface Cash &#123; double acceptCash(double money);&#125; 三种策略实现类： 正常收费 1234567package designpatterns.strategy;public class CashNormal implements Cash &#123; @Override public double acceptCash(double money) &#123; return money; &#125;&#125; 打折 1234567891011package designpatterns.strategy;public class CashRebate implements Cash &#123; private double moneyRebate = 1; public CashRebate(double moneyRebate)&#123; this.moneyRebate = moneyRebate; &#125; @Override public double acceptCash(double money) &#123; return money * moneyRebate; &#125;&#125; 减免 1234567891011121314151617package designpatterns.strategy;public class CashReturn implements Cash &#123; //返利条件 private double moneyCondition = 0; //返利的值 private double moneyReturn = 0; public CashReturn(double moneyCondition, double moneyReturn)&#123; this.moneyCondition = moneyCondition; this.moneyReturn = moneyReturn; &#125; @Override public double acceptCash(double money) &#123; if (money &gt;= moneyCondition) return money - Math.floor(money / moneyCondition) * moneyReturn; return money; &#125;&#125; 使用具体策略的类 12345678910package designpatterns.strategy;public class Context &#123; private Cash cash; public Context(Cash cash)&#123; this.cash = cash; &#125; public double result(double money)&#123; return cash.acceptCash(money); &#125;&#125; 测试类 123456789101112package designpatterns.strategy;public class StrategyTest &#123; public static void main(String[] args) &#123; Context context; context = new Context(new CashNormal()); System.out.println(&quot;正常收费： &quot; + context.result(100)); context = new Context(new CashRebate(0.8)); System.out.println(&quot;打八折收费： &quot; + context.result(100)); context = new Context(new CashReturn(100, 30)); System.out.println(&quot;满100减30: &quot; + context.result(100)); &#125;&#125; 总结优点： 通过共同实现的接口，可以把公用的功能抽取出来。 简化单元测试，因为每个接口都有自己的类，可以通过自己的接口单独测试。 消除类中的条件判断语句 扩展性良好 缺点： 选择具体实现的职责由客户端对象承担，并转给策略模式的Context对象，并没有解除客户端的选择判断的压力。 新增策略就要新增策略类。 策略模式时用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种可能发生的变化。 但是在策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式使用对象，这本身并没有解除客户端需要选择判断的压力，解决这一问题的方法是使用策略模式和工厂模式结合，选择具体实现的职责也由策略使用类Context来承担。这就最大化的减轻了客户端的职责。 这里就不给出实现代码了，有兴趣的同学可以自行实现。]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design patterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2017%2F06%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义从设计模式类型来说，简单工厂模式是属于创建型模式，又叫做静态工厂方法模式。但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂决定创建哪一种产品类的实例。简单工厂模式是工厂家族中最简单最实用的模式，可以理解为是不同工厂模式的一个特殊体现。 结构图及其说明 上图可以看出共有三个类，一个是工厂类Creator,一个是产品类Iproduct,一个便是具体的产品，例如产品A和产品B。工厂类负责创建产品的逻辑判断，为了使工厂类能够知道我们需要哪一种产品，我们需要在创建产品时传递工厂类一个参数，去表明我们需要创建哪些产品。 实现代码产品接口123public interface Iproduct &#123; public void method();&#125; 两个具体的产品123456789101112public class ProductA implements Iproduct &#123; public void method() &#123; System.out.println("产品A方法"); &#125;&#125;public class ProductB implements Iproduct &#123; public void method() &#123; System.out.println("产品B方法"); &#125;&#125; 工厂类12345678910111213141516public class Creater&#123; private Creater()&#123;&#125; public static Iproduct createProduct(String productName) &#123; if (productName == null) &#123; return null; &#125; if (productName.equals("A")) &#123; return new ProductA(); &#125; else if (productName.equals("B")) &#123; return new ProductB(); &#125; else &#123; return null; &#125; &#125;&#125; 测试类客户端 123456789public class Client &#123; public static void main(String[] args) &#123; Iproduct productA = Creater.createrProduct("A"); productA.method(); Iproduct productB = Creater.createrProduct("B"); productB.method(); &#125;&#125;]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>design patterns</tag>
      </tags>
  </entry>
</search>
