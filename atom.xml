<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qiutiangang</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiutiangang123.github.io/"/>
  <updated>2020-03-26T02:49:39.256Z</updated>
  <id>https://qiutiangang123.github.io/</id>
  
  <author>
    <name>邱天罡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARTS第二周</title>
    <link href="https://qiutiangang123.github.io/2020/03/25/ARTS/ARTS%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
    <id>https://qiutiangang123.github.io/2020/03/25/ARTS/ARTS第二周/</id>
    <published>2020-03-25T12:18:43.000Z</published>
    <updated>2020-03-26T02:49:39.256Z</updated>
    
    <content type="html"><![CDATA[<p>Algorithm/Review/Tips/Share每周学习一道leetcode算法题，提高自己逻辑思维，阅读一篇英文文档，锻炼自己的英语能力。总结工作或者学习中遇到的编程技巧，提高自己代码水平。分享一篇有意义的技术文章。<a id="more"></a></p><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>实例一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>实例二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!checkValue(s.charAt(i)) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!checkValue(s.charAt(j)) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> a = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> b = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="string">'A'</span> &amp;&amp; a &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">                a += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= <span class="string">'A'</span> &amp;&amp; b &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">                b += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkValue</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><h4 id="Ready-for-changes-with-Hexagonal-Architecture-Link"><a href="#Ready-for-changes-with-Hexagonal-Architecture-Link" class="headerlink" title="Ready for changes with Hexagonal Architecture Link"></a>Ready for changes with Hexagonal Architecture <a href="https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749" target="_blank" rel="noopener">Link</a></h4><p>这篇文章主要讲了netflix的六角形架构。主要讲了从一开始的聚合架构到六角形架构的解耦，包括底层数据源的不同，可能是数据库，也可能是来源于微服务。到能够简单的实现交互restful api。这样做的目的当然是为了适应需求的变化而快速开发。文章当中还提到了架构中的测试问题。主要分为api的测试，数据源可以进行mock操作。还有对微服务之间交互测试以及整体测试。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="CDN-Content-Delivery-Network"><a href="#CDN-Content-Delivery-Network" class="headerlink" title="CDN(Content Delivery Network)"></a>CDN(Content Delivery Network)</h4><p>上一篇文章主要讲了Python的一些应用，其中netflix将一些用户的信息之间存在CDN中，这样做的目的当然是减少网络传输以及减轻服务器的压力，这次主要了解一下CDN的一些内容。</p><p>CDN主要为了解决网络传输问题，加速网站的访问。用户请求过来的时候，先通过DNS解析IP地址，然后找到离用户最近的CDN服务器，去获取一些内容，CDN服务器主要存储一些静态的内容。比如图像，JS文件以及流媒体视频等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Algorithm/Review/Tips/Share每周学习一道leetcode算法题，提高自己逻辑思维，阅读一篇英文文档，锻炼自己的英语能力。总结工作或者学习中遇到的编程技巧，提高自己代码水平。分享一篇有意义的技术文章。
    
    </summary>
    
      <category term="ARTS" scheme="https://qiutiangang123.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://qiutiangang123.github.io/tags/ARTS/"/>
    
      <category term="algorithm" scheme="https://qiutiangang123.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ARTS第一周</title>
    <link href="https://qiutiangang123.github.io/2020/03/09/ARTS/ARTS%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>https://qiutiangang123.github.io/2020/03/09/ARTS/ARTS第一周/</id>
    <published>2020-03-09T12:18:43.000Z</published>
    <updated>2020-03-14T14:26:55.830Z</updated>
    
    <content type="html"><![CDATA[<p>Algorithm/Review/Tips/Share每周学习一道leetcode算法题，提高自己逻辑思维，阅读一篇英文文档，锻炼自己的英语能力。总结工作或者学习中遇到的编程技巧，提高自己代码水平。分享一篇有意义的技术文章。<a id="more"></a></p><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>实现一个字符串，将字符串转换成整数，首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>实例一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure></p><p>实例二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br></pre></td></tr></table></figure><p>实例三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br></pre></td></tr></table></figure><p>实例四</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>实例五</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">str2Int</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="keyword">int</span> p = <span class="number">0</span>; <span class="keyword">int</span> n = value.length();</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 得到数字开始的位置并判断开始位置是否和字符串的长度相等</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; (value.charAt(p) &lt; <span class="string">'0'</span> || value.charAt(p) &gt; <span class="string">'9'</span>)) &#123;</span><br><span class="line">      p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == n) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value.charAt(p-<span class="number">1</span>) == <span class="string">'-'</span>) &#123;</span><br><span class="line">      flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value.charAt(p) == <span class="string">'0'</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == n) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    start = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt; n &amp;&amp; value.charAt(p) &gt;= <span class="string">'0'</span> &amp;&amp; value.charAt(p) &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == start) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n - start &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; p; i++) &#123;</span><br><span class="line">      num = num * <span class="number">10</span> + (value.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    num = flag ? num : - num;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    str2Int(<span class="string">"aa"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><h4 id="python-at-netflix-Link"><a href="#python-at-netflix-Link" class="headerlink" title="python at netflix Link"></a>python at netflix <a href="https://netflixtechblog.com/python-at-netflix-bba45dae649e" target="_blank" rel="noopener">Link</a></h4><p>这篇文章主要介绍了python在netflix公司的应用情况，读完感觉也是python的主要应用方向。</p><p>首先netflix把一些内容保存在开放链接上（Open connect）,开放性链接也就是CDN（content delivery network）。这些内容包括推荐用户的信息，是否登录，观看记录等等。这些信息存放在CDN上的目的是为了减少与服务器之间的交互，提高效率，节省流量。CDN上的系统软件是用python进行构建的。</p><p>此外，本篇文章还介绍了python在一些其他团队的应用，比如进行系统报警，自动检测，自动修复等功能。还可以进行数据分析，人工智能，算法推荐，应用测试等。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="restful接口的安全性校验"><a href="#restful接口的安全性校验" class="headerlink" title="restful接口的安全性校验"></a>restful接口的安全性校验</h4><p>使用restful进行接口交互的优点有很多，首先，restful实现接口比较轻量级，直接基于http协议，以http协议的Get/Post/Delete/Put为CRUD操作。数据描述比较简单，可以直接通过Json进行交互，但是由于restful接口是无状态的，所以存在安全性的问题，比如说存在A、B、C三个服务，其中服务A只允许服务B进行调用，不允许服务C进行调用，这种情况下就需要接口的安全性校验。安全性的校验可以有多种的实现，主要介绍基于token机制的签名认证机制（对接平安保险业务时平安保险就使用该种接口认证方式）</p><p>token认证机制主要是在调用接口之前首先进行resutful接口的请求获取access key 和secret key。access key主要是进行用户信息的认证，应用会通过它进行区分不同的用户。而access key是接口请求的加密。其中加密算法可以使用对称加密和非对称加密。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Algorithm/Review/Tips/Share每周学习一道leetcode算法题，提高自己逻辑思维，阅读一篇英文文档，锻炼自己的英语能力。总结工作或者学习中遇到的编程技巧，提高自己代码水平。分享一篇有意义的技术文章。
    
    </summary>
    
      <category term="ARTS" scheme="https://qiutiangang123.github.io/categories/ARTS/"/>
    
    
      <category term="ARTS" scheme="https://qiutiangang123.github.io/tags/ARTS/"/>
    
      <category term="algorithm" scheme="https://qiutiangang123.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot深入分析学习</title>
    <link href="https://qiutiangang123.github.io/2019/07/02/%E5%88%86%E5%B8%83%E5%BC%8F/SpringBoot%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/"/>
    <id>https://qiutiangang123.github.io/2019/07/02/分布式/SpringBoot深入分析学习/</id>
    <published>2019-07-02T07:55:07.000Z</published>
    <updated>2019-07-02T03:30:13.573Z</updated>
    
    <content type="html"><![CDATA[<p>其实在17年入职目前公司的时候就已经接触了SpringBoot,当时公司重构代码，组长决定通过SpringBoot构建微服务架构，在会议室里面深入讲了一下微服务相关概念，当时也不是很懂，后来觉得SpringBoot就是为微服务所准备的，可以通过main函数运行。但其实SpringBoot版本发行是在2005年，而微服务这种概念的提出是在06年。本篇博客主要通过官网文档像大家介绍一下SpringBoot的基本概念。<br><a id="more"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>SpringBoot是Spring家族中的一份子。在官网中的概念如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;.</span><br><span class="line"></span><br><span class="line">We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss.</span><br><span class="line">Most Spring Boot applications need very little Spring configuration.</span><br></pre></td></tr></table></figure><p>Spring Boot可以简单的创建单机的，生产级别的Spring应用使你可以直接运行。我们采取一个Spring平台固化视图和三方包，你可以更加轻量级的运行。大多数SpringBoot应用需要需要很少的Spring 配置。</p><p>通过上述概念可以说明的是Spring Boot创建的还是一个Spring的应用。并且Spring Boot更加轻量级，传统的Spring Boot de的配置很麻烦，要去关注各个三方应用的版本等问题。在Spring Boot中通过减少或者可以不用XML进行配置应用。通过自动装配等功能轻量级的开始一个应用。传统的Spring应用虽然功能很强大，但是并不是一个容器，它的生命周期还是通过Tomcat来完成的，而Spring Boot内嵌容器，使得生命周期可以自己去进行控制。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>官网中对Spring Boot的特性描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- Create stand-alone Spring applications</span><br><span class="line"></span><br><span class="line">- Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</span><br><span class="line"></span><br><span class="line">- Provide opinionated &apos;starter&apos; dependencies to simplify your build configuration</span><br><span class="line"></span><br><span class="line">- Automatically configure Spring and 3rd party libraries whenever possible</span><br><span class="line"></span><br><span class="line">- Provide production-ready features such as metrics, health checks and externalized configuration</span><br><span class="line"></span><br><span class="line">- Absolutely no code generation and no requirement for XML configuration</span><br></pre></td></tr></table></figure><ol><li>创建单机的Spring应用。注意Spring Boot创建的还是Spring的应用。</li><li>内嵌Tomcat、Jetty可以直接运行，不需要去构建War包。内嵌容器可以更加方便构建Spring应用。并不是说内嵌容器的方式比通过打包使用脚本的方式效率或者速度更快。</li><li>提供’start’依赖去简化构建配置。</li><li>尽可能自动配置Spring和第三方库</li><li>提供生成级别的应用例如指标，运行状况检查和外部化配置</li><li>绝对没有代码生成也不需要XML配置。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实在17年入职目前公司的时候就已经接触了SpringBoot,当时公司重构代码，组长决定通过SpringBoot构建微服务架构，在会议室里面深入讲了一下微服务相关概念，当时也不是很懂，后来觉得SpringBoot就是为微服务所准备的，可以通过main函数运行。但其实SpringBoot版本发行是在2005年，而微服务这种概念的提出是在06年。本篇博客主要通过官网文档像大家介绍一下SpringBoot的基本概念。&lt;br&gt;
    
    </summary>
    
      <category term="Distributed" scheme="https://qiutiangang123.github.io/categories/Distributed/"/>
    
    
      <category term="Java" scheme="https://qiutiangang123.github.io/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://qiutiangang123.github.io/tags/SpringBoot/"/>
    
      <category term="distributed" scheme="https://qiutiangang123.github.io/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://qiutiangang123.github.io/2019/01/21/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Redis%E7%AE%80%E4%BB%8B/"/>
    <id>https://qiutiangang123.github.io/2019/01/21/数据存储/Redis简介/</id>
    <published>2019-01-21T11:19:02.000Z</published>
    <updated>2019-05-28T02:56:46.753Z</updated>
    
    <content type="html"><![CDATA[<p>缓存是互联网公司基本技术之一，使用缓存主要有两点好处，高性能和高并发，高性能是指可以把一些经常查询基本不变耗时的数据，放在缓存中，可以减少对数据库的依赖。<a id="more"></a>在高并发的情况下，mysql的数据库可能会挂机。这种情况下可以将数据放到缓存中来应对高峰期高并发。</p><h2 id="redis与memcached区别"><a href="#redis与memcached区别" class="headerlink" title="redis与memcached区别"></a>redis与memcached区别</h2><p>从下面几个方面来归纳总结redis和memcached的区别</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>memcached只支持string类型的数据存储，redis支持string，hash，list，set，zset五种数据类型。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Redis通过RDB和AOF两种方式支持数据的持久化，而memcached不支持持久化。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>Redis通过一主多从的方式实现分布式。</p><p>memcached不支持分布式，只能通过客户端使用一致性哈希来实现分布式存储方式，这种方式在存储和查询时都需要在客户端计算一次数据所在的节点。</p><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>在Redis中，会将value值存储在磁盘中，内存中存储key的值，而memcached会将所有的数据都保存在内存中。</p><p>Redis为什么是单线程还支持高并发：</p><p>主要有三点支持高并发，首先Redis是基于内存操作，其效率很高，其次Redis是基于非阻塞的IO多路复用机制NIO，最后使用单线程可以避免上下文切换。</p><h2 id="Redis的五种数据类型"><a href="#Redis的五种数据类型" class="headerlink" title="Redis的五种数据类型"></a>Redis的五种数据类型</h2><p>Redis共支持五种数据类型，以下会从每种的数据结构，底层的数据类型和使用场景进行详细的说明</p><h3 id="String字符串类型"><a href="#String字符串类型" class="headerlink" title="String字符串类型"></a>String字符串类型</h3><p>底层数据结构：String类型通过int和SDS(simple dynamic string)作为结构存储，其中int存储整数类型的数据，SDS存储字节/字符串和浮点型数据。</p><p>应用场景：普通的key/value存储都可以归为此类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set &quot;test&quot; test</span><br><span class="line"></span><br><span class="line">get &quot;test&quot;</span><br><span class="line"></span><br><span class="line">del &quot;test&quot;</span><br></pre></td></tr></table></figure><h3 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h3><p>底层数据结构：数据量小的时候用ziplist,另外一种是hashtable。</p><p>应用场景：整体看作一个对象，每一个field - value相当于对象的属相和属性值。例如存储用户信息对象数据，包括用户ID,用户姓名，年龄和生日，通过ID我们希望获取用户的姓名年龄和生日。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/redis-hash数据类型应用场景.png" alt="image-w100"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HSET userInfo1 username &apos;tom&apos; </span><br><span class="line"></span><br><span class="line">HSET userInfo1 password &apos;123456&apos; </span><br><span class="line"></span><br><span class="line">hmset name &quot;qiutiangang&quot;</span><br><span class="line"></span><br><span class="line">hgetall name</span><br><span class="line"></span><br><span class="line">hdel name</span><br></pre></td></tr></table></figure><h3 id="list列表类型"><a href="#list列表类型" class="headerlink" title="list列表类型"></a>list列表类型</h3><p>底层数据结构：before3.2 当list元素个数和单个元素长度比较小的时候，采用ziplist否则用linkedlist结构，after3.2 底层用quickList来实现。linkedlist在插入节点上时间复杂度低但内存开销比较大。ziplist存储在连续的内存上，存储率比较高。但是插入和删除都需要频繁的申请和释放内存。quicklist仍是双向链表，只每一个节点是ziplist。</p><p>quicklist ==&gt; linkedlist + ziplist</p><p>应用场景：列表类型可以存储一个有序的字符串列表，常用的操作是向列表的两端添加元素或者获取列表的某一个片段。列表的内部使用一个双向链表实现，所以向列表两端添加元素的时间复杂度是o(1)，获取越接近两端的元素就越来越快。这意味着即使几千万的元素，获取前几条元素也很快。可以应用与twitter的关注列表，粉丝列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lpush testList qiutiangang</span><br><span class="line"></span><br><span class="line">Lpop testList</span><br><span class="line"></span><br><span class="line">lrange testlist 0 10</span><br></pre></td></tr></table></figure><h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h3><p>底层数据结构:当set找那个只包含整数型元素时采用intset来存储。否则炒菜用hashtable来存储，对于set来说，该hashtable的value值用于null，通过key来存储元素。</p><p>应用场景：与list类似是一个列表功能。set是自动排重的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sadd testSet aa</span><br><span class="line"></span><br><span class="line">smembers testSet</span><br></pre></td></tr></table></figure><h3 id="zset有序集合"><a href="#zset有序集合" class="headerlink" title="zset有序集合"></a>zset有序集合</h3><p>底层数据结构：采用ziplist或者hashtable</p><p>应用场景：有序自动排重列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd testZ a</span><br></pre></td></tr></table></figure><h2 id="Redis的持久化方式"><a href="#Redis的持久化方式" class="headerlink" title="Redis的持久化方式"></a>Redis的持久化方式</h2><p>Redis支持两种方式的持久化，一种是RDB方式、另一种是AOF（append-only-ﬁle）方式。前者会根据指定的规则“定时”将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来。两种持久化方式可以单独使用其中一种，也可以将这两种方式结合使用。</p><h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p>当符合一定条件时，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，等到持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方 式要比AOF方式更加的高效。RDB的缺点是后一次持久化后的数据可能丢失。</p><h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p>当使用Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能。</p><h2 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h2><p>Redis的内存淘汰侧罗是指在Redis的用于缓存内存不足时，怎么处理需要重新申请额外的空间数据：</p><ol><li>no-envicition:当内存不足以容纳新写入的数据时，写入操作会报错。</li><li>allkeys-Iru:当内存不足以容纳新写入数据时，在键空间找那个，移除最少使用的key.</li><li>allkeys-random:当内存不足以容纳新写入的数据时，在键空间中，随机移除某个key。</li><li>volatile-Iru:当内存不足以容纳新写入的数据时。在设置过期的时间的键空间中，移除最少使用的key。</li><li>volatile-random:当内存不足以容纳新写入的数据时，在设置过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl:当内存空间不足以容纳新写入的数据时，在设置过期时间的键空间中，有更早过期时间的key优先移除</li></ol><h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><p>将Redis中的Key设置过期可以通过以下过期策略：</p><ol><li>定时过期：每个设置过期时间的Key都需要创建一个定时器，到过期时间会立即清除，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的时间和吞吐量。</li><li>惰性过期：只有当访问一个Key时，才会判断Key是否已经过期。过期则清除。该策略最大化节省了CPU资源，却对内存非常不友好，极端情况下可能出现大量的key没有被访问，从而不会清除占用大量内存。</li><li>定期过期：每隔一段时间会扫描一定数量的数据库expires字典中的key，并清除其中已经过期的Key。</li></ol><p>Redis使用了惰性过期和定时过期两种过期策略</p><h2 id="Redis的高可用和高并发"><a href="#Redis的高可用和高并发" class="headerlink" title="Redis的高可用和高并发"></a>Redis的高可用和高并发</h2><p>在分布式的环境中，要保证系统的高可用和高并发，就需要部署集群。Redis的高可用采用主从模式，一主多从，每个实例都容纳完整的数据。在保证高并发的情况下，还需要容纳大量的数据，这时就需要将Redis部署集群模式。保证系统的高可用，是在部署主从模式之上加哨兵机制。就可以实现，任何一个实例宕机，自动会进行主备之间切换。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>将Redis部署为主从模式，如果master服务器宕机之后，可以手动的将slave服务器切换为mater服务器。这种人工切换的方式会使服务在一定时间内导致不可用。因此可以使用哨兵模式来完成。</p><p>哨兵是一个独立的进程，其原理是通过哨兵进行来进行对Redis实例发送消息，等待响应，从而监控运行的Redis实例。当master服务宕机之后，会自动将slave服务器切换为master服务器，并通过发布订阅模式通知其他服务修改配置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缓存是互联网公司基本技术之一，使用缓存主要有两点好处，高性能和高并发，高性能是指可以把一些经常查询基本不变耗时的数据，放在缓存中，可以减少对数据库的依赖。
    
    </summary>
    
      <category term="数据存储" scheme="https://qiutiangang123.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="database，redis" scheme="https://qiutiangang123.github.io/tags/database%EF%BC%8Credis/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://qiutiangang123.github.io/2018/12/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://qiutiangang123.github.io/2018/12/17/Java并发编程和高并发/线程池/</id>
    <published>2018-12-17T06:36:07.000Z</published>
    <updated>2019-07-01T03:22:58.294Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴开发手册中有一条关于使用线程的规定：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【强制】线程资源必须由线程池来提供，不允许在应用中显示的创建线程</span><br><span class="line"> 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。</span><br><span class="line"> 如果不使用用线程池，有可能造成系统创建大量同类线程而导致系统消耗完内存或者“过度切换”的问题。</span><br></pre></td></tr></table></figure></p><p>使用线程有如下几个好处：</p><ol><li>线程是稀缺资源，不能频繁的创建</li><li>解耦作用，将线程的创建与执行分开操作。</li><li>提高线程的可管理性。</li></ol><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><p>当提交一个新的任务到线程池时，线程池的处理流程如下：</p><ol><li>线程池判断核心线程池是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程。</li><li>线程池判断工作队列是否已经满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里，如果工作队列满了，则进入下一个流程。</li><li>线程池判断线程池是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/线程池工作原理.jpg" alt="image-w100"></p><h3 id="线程池ThreedPoolExecutor参数简介"><a href="#线程池ThreedPoolExecutor参数简介" class="headerlink" title="线程池ThreedPoolExecutor参数简介"></a>线程池ThreedPoolExecutor参数简介</h3><p>四个构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//六个参数的构造函数-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//六个参数的构造函数-2</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//七个参数的构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>int corePoolSize ==&gt; 该线程池中核心线最大值</p><blockquote><p>当一个任务被提价到线程池中，如果线程池中最大线程数小于核心线程池时，则创建核心线程，如果超过corePoolSize并小于最大线程数，则新建非核心线程。在默认情况下，核心线程在闲置的情况下不会被销毁。但是如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉。</p></blockquote><p>int maximumPoolSize ==&gt; 该线程池中线程最大总数</p><blockquote><p>线程总数 = 核心线程 + 非核心线程。</p></blockquote><p>long keepAliveTime ==&gt; 非核心线程闲置超时时间</p><blockquote><p>如果非核心线程闲置时间超过该设置的时间，则会被销毁。如果设置allowCoreTreadTimeOut,则会作用于核心线程。</p></blockquote><p>BlockingQueue<runnable> workQueue ==&gt; 工作队列</runnable></p><blockquote><p>当一个任务被提交到线程池中，如果线程数超过核心线程数，则会被提交的工作队列中，如果工作队列中线程数超过最大值时，则会创建非核心线程执行该任务。</p></blockquote><h3 id="向ThreadPoolExecutor添加任务"><a href="#向ThreadPoolExecutor添加任务" class="headerlink" title="向ThreadPoolExecutor添加任务"></a>向ThreadPoolExecutor添加任务</h3><p>可以使用两个方法向线程池来提交任务，分别是execute()和submit()方法。</p><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.executor(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>submit()方法用于提交需要返回值的任务。线程吃会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harRetureValuetask)</span><br></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或者shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt放啊发来中断线程，所以无法响应中断的任务可能永远无法终止。</p><h3 id="常见的四种线程池"><a href="#常见的四种线程池" class="headerlink" title="常见的四种线程池"></a>常见的四种线程池</h3><p>Excutors是Java提供管理线程池的类，改类的两个作用，控制数量和重用线程，通过该类主要有四种线程池的实现方式，这四种线程池底层主要是使用ThreadPoolExcutors类。</p><ol><li><p>CacheThreadPool该线程池内部没有核心线程，线程池的数量没有限制，在创建线程时，若有空闲的线程则服用空闲的线程，若没有则创建新的线程，闲置状态的线程超过了60s没有被使用则会销毁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService excutor = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure></li><li><p>FixedThreadPool该线程池的最大线程数等于核心线程数，在默认的情况下，该线程池的线程不会为闲置状态超时而被销毁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService excutor = Executors.newFixedThreadPool(2);</span><br></pre></td></tr></table></figure></li><li><p>SingleThreadPool有且只有一个工作线程执行任务，所有的线程遵循队列的执行规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService excutor = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure></li><li><p>ScheduledThreadPool不仅设置了核心线程数，最大线程数也是Integer.MAX_VALUE。这个线程池时上述四个中唯一一个有延迟执行和周期执行任务的线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService excutor = Executors.newScheduledThreadPool(1);</span><br></pre></td></tr></table></figure></li></ol><h3 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h3><blockquote><p>线程池看似很美好，但是也会带来一些问题。</p></blockquote><p>如果我们很多业务都依赖于同一线程池，其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p><p>这样其他业务就不能运行，这种情况对系统的打击是巨大的。</p><p>所以我们需要将线程池进行隔离。通常的做法是根据业务来进行划分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如下单业务使用一个线程池，获取数据的任务使用一个线程池，这样即使一个任务将线程池的资源消耗尽，也不会对其他任务产生影响。</span><br></pre></td></tr></table></figure><h4 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a>hystrix 隔离</h4><p>这样的需要hystrix已经帮我们实现了。</p><blockquote><p>hystrix是一款开源的容错插件，具有依赖隔离，系统降级容错等功能。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿里巴巴开发手册中有一条关于使用线程的规定：&lt;br&gt;
    
    </summary>
    
      <category term="concurrency" scheme="https://qiutiangang123.github.io/categories/concurrency/"/>
    
    
      <category term="Java" scheme="https://qiutiangang123.github.io/tags/Java/"/>
    
      <category term="thread" scheme="https://qiutiangang123.github.io/tags/thread/"/>
    
      <category term="concurrency" scheme="https://qiutiangang123.github.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程原理与实例</title>
    <link href="https://qiutiangang123.github.io/2018/11/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E4%BE%8B/"/>
    <id>https://qiutiangang123.github.io/2018/11/22/Java并发编程和高并发/JAVA多线程原理与实例/</id>
    <published>2018-11-22T12:14:07.000Z</published>
    <updated>2019-05-17T08:43:13.411Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客详细介绍Java多线程的基本原理与并发知识。参考博客<a href="https://github.com/CyC2018" target="_blank" rel="noopener">https://github.com/CyC2018</a><br><a id="more"></a></p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程状态如下图所示，共有线程新建、可运行、阻塞、无限期等待、限期等待和终止五种状态。<br><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/线程状态图.png" alt="image-w100"></p><h3 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h3><p>线程的新建状态是指创建之后未使用。</p><h3 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h3><p>线程的可运行状态指的是可能正在运行，也可能正在等待CPU时间片。</p><h3 id="阻塞（Blocked）"><a href="#阻塞（Blocked）" class="headerlink" title="阻塞（Blocked）"></a>阻塞（Blocked）</h3><p>等待获取排它锁，如果其他线程释放锁便会结束此状态。</p><h3 id="无限期等待"><a href="#无限期等待" class="headerlink" title="无限期等待"></a>无限期等待</h3><p>等待其他线程显式的唤醒，否则不会分配时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置TImeout参数的Object.wait()</td><td>Object().notify()和Object().notifyAll()</td></tr><tr><td>没有设置Timeout参数的Object.join()</td><td>被调用的线程执行完毕</td></tr></tbody></table><h3 id="限期等待"><a href="#限期等待" class="headerlink" title="限期等待"></a>限期等待</h3><p>无需等待其他线程显示的唤醒，在一定时间之后会被系统自动的唤醒。</p><p>调用Thread.sleep()方法使线程进入限期等待状态，用“使一个线程睡眠”来进行描述。</p><p>调用Object.wait()方法是线程进入限期等待状态，用“使一个线程挂起”来进行描述。</p><p>睡眠和挂起用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别为，阻塞是被动的，它是等待获取一个排它锁，而等待是主动的。通常调用Thread.sleep()或者Object.wait()方法进入</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>使用Thread.sleep()方法</td><td>时间结束</td></tr><tr><td>设置Timeout参数的Thread.join()方法</td><td>时间结束/被调用的线程执行完毕 </td></tr><tr><td>设置Timeout参数的Object.wait()方法</td><td>时间结束/Object.notify()/Object.notifyAll()</td></tr></tbody></table><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>线程执行完毕或者产生异常而结束。</p><h2 id="线程的实现方法"><a href="#线程的实现方法" class="headerlink" title="线程的实现方法"></a>线程的实现方法</h2><p>有三种实现线程的方法</p><ol><li>实现Runnable接口</li><li>实现Callable接口</li><li>继承Thread类</li></ol><p>实现Runnable接口或者实现Callable接口的类只能当做可以在线程中运行的任务，而不是真正的线程。最后还需要Thread类来调用。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AIMain &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable instance = new MyRunnable();</span><br><span class="line">    Thread t = new Thread(instance);</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyRunnable implements Runnable&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    System.out.println(&quot;创建线程&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与Runnable接口相比，Callable接口有返回值，返回值通过FutureTask进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    MyCallable instance = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(instance);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class AIMain &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    MyThread t = new MyThread();</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    System.out.println(&quot;创建线程&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其他部分之前完成。那么就需要对线程进行协调。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在线程中调用另一个线程join()方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于下面的程序来说，在线程B中，调用了a.join()方法，所以在执行时，即使B线程先执行，但是也要等线程a执行完毕之后再执行线程b。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample joinExample = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    joinExample.test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    B (A a) &#123;</span><br><span class="line">      <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        a.join();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B(a);</span><br><span class="line">    b.start();</span><br><span class="line">    a.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="wait-、notify-和notifyAll"><a href="#wait-、notify-和notifyAll" class="headerlink" title="wait()、notify()和notifyAll()"></a>wait()、notify()和notifyAll()</h3><p>调用wait()使得线程等待某个条件满足，线程在等待时会挂起，当其他线程运行使得这个条件满足时，其他线程会调用notify()或者notifyAll()来唤醒被挂起的线程。</p><p>它们都属于Object的一部分，而不属于Thread()。</p><p>使用wait()挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么对象就无法进入同步方法或者同步控制块中，那么就无法执行notify()或者notifyAll()来唤醒挂起的线程，造成死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample we = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; we.after());</span><br><span class="line">    executorService.execute(() -&gt; we.befor());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">befor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"after"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><h3 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String s1 = <span class="string">"s1"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String s2 = <span class="string">"s2"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程a先锁住变量s1,然后锁住变量s1</span></span><br><span class="line">    Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"锁住变量s1"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">"锁住变量s2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程b先锁住变量s2,然后锁住变量s1</span></span><br><span class="line">    Thread b = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"锁住变量s2"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">"锁住变量s1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    a.start();</span><br><span class="line">    b.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客详细介绍Java多线程的基本原理与并发知识。参考博客&lt;a href=&quot;https://github.com/CyC2018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CyC2018&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="concurrency" scheme="https://qiutiangang123.github.io/categories/concurrency/"/>
    
    
      <category term="thread" scheme="https://qiutiangang123.github.io/tags/thread/"/>
    
      <category term="concurrency" scheme="https://qiutiangang123.github.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>并发编程常见概念</title>
    <link href="https://qiutiangang123.github.io/2018/10/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/"/>
    <id>https://qiutiangang123.github.io/2018/10/22/Java并发编程和高并发/并发编程常见概念/</id>
    <published>2018-10-22T12:14:07.000Z</published>
    <updated>2019-05-28T03:20:03.057Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文主要记录了各种并发概念，参考《JAVA并发编程的艺术》。<br><a id="more"></a></p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>在执行程序时，为了提高性能，处理器和编译器常常会对指令进行重新排序，排序时要遵循两个规则：在单线程的环境下不能改变程序运行的结果、存在数据依赖关系的不可以指令重排。这两个规则可以总结为不能通过happen-before原则推导出来，JMM允许任意指令重排。</p><p>as-if-serial:所有的操作都可以为了优化而重排序，但是必须保证重排序的执行的结果不能改变。as-if-serial只保证单线程，多线程环境下无效。</p><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B前面。但是A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>由于我们就所有的场景来规定某个变量修改的变量何时对其他线程可见，我们可以指定某些规则，这些规则就是happens-before。在JMM中，如果一个操作的结果对另一个操作的结果可见，那么这两个操作之间必定存在happens-before关系。happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。依靠这个原则，我们可以解决在并发环境下两操作之间是否可能存在冲突的所有问题。</p><p>happens-before原则的定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的结果对于第二个操作结果可见，而且第一个操作的顺序排在第一个操作顺序之前。</li><li>两个操作之间存在happens-before关系，并不一定要按照happens-before原则指定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种排序结果不非法。</li></ol><p>下面是happens-before的原则规则：</p><ol><li>程序次序规则：一个线程内，按照代码的顺序，书写前面的操作先发生与书写在后面很的操作。</li><li>锁定规则：一个unlock操作先行发生与后面对同一个锁的unlock操作。</li><li>volatile变量规则：对于变量的写操作先行发生于对这个变量的读操作。</li><li>传递规则：如果操作A先行发生于操作B,而操作B又先行发生于操作C,则可以得出操作A先发生于操作C、</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程中断规则：对线程的interrupt()方法的调用先行发生与被中断线程的代码检测到中断事件的发生。</li><li>线程终结规则：线程中的所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()返回值手段检测到线程已经终止执行。</li><li>对象终结规则：一个对象初始化完成先行发生于它的finalize()方法的开始。</li></ol><h2 id="synchronized和volatile比较"><a href="#synchronized和volatile比较" class="headerlink" title="synchronized和volatile比较"></a>synchronized和volatile比较</h2><h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><p>Java中的每一个对象都可以作为锁，具体表现为以下三种形式。</p><ol><li>对于普通的同步方法，锁是当前的同步对象。</li><li>对于静态同步方法，锁是当前类的class对象。</li><li>对于同步方法块，锁是synchronized括号里面配置对象。</li></ol><p>JVM基于进入和退出Monitor对象来实现方法的同步和代码块的同步，但是两者的实现细节不一样。代码块的同步是使用monitorenter和monitorexit指令实现的，方法的实现是使用另一种方式实现的，但是可以同样使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块开始的位置，而monitorexit是插入到方法的结束处和异常处。任何对象都有一个monitorenter与之相关联，当一个monitor被持有后，它将处于锁定状态，线程执行到monitorenter指令时，将会尝试获取对象锁对应的monitor的所有权，即尝试获取对象的锁。</p><h3 id="synchronized作用域"><a href="#synchronized作用域" class="headerlink" title="synchronized作用域"></a>synchronized作用域</h3><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号括起来的代码，作用的对象时调用这个代码块的对象。</li><li>修饰一个方法，被修饰的方法被称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象。</li><li>修饰一个静态的方法，作用的范围是整个静态的方法，作用的对象是这个类的所用对象。</li><li>修饰一个类，其作用的范围是synchronized后面括起来的部分，作用的对象是这个类的所用对象。</li></ol><h3 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h3><p>synchronized在JSK1.6之后为了减少获取锁和释放锁，引入了偏向锁和轻量级锁，使得synchronized变得不那么重，所以锁的状态一共有四种 ==》 无锁状态、偏向锁、轻量级锁、重量级锁。锁的状态只升级不能降级</p><h4 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h4><p>无锁状态是指不对资源进行锁定，所有线程都可以访问，但只有一个线程可以修改成功。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>CAS</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>升级为重量级锁之后等待的线程会阻塞</p><h3 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h3><ol><li>使得变量更新变得具有可见性，只要被volatile关键字修饰的变量的赋值一旦发生变化就会通知到其他线程，其他线程会放弃副本拷贝的值，主动去主内存进行拷贝。</li><li>产生内存屏障，防止指令进行重排序。</li></ol><h3 id="volatile-和-synchronized的区别"><a href="#volatile-和-synchronized的区别" class="headerlink" title="volatile 和 synchronized的区别"></a>volatile 和 synchronized的区别</h3><ol><li>Volatile 的本质是告诉JVM当前变量是不确定的，需要从主存中获取。synchronized.synchronized 是锁定变量，只有当前线程可以访问。</li><li>Volatile 仅能使用变量级别。synchrnized 则是锁定当前变量，方法。</li><li>Volatile 不会造成线程的阻塞，synchronized会造成线程的阻塞。</li></ol><h3 id="怎么实现所有的线程在等待某个事件的发生才会去执行"><a href="#怎么实现所有的线程在等待某个事件的发生才会去执行" class="headerlink" title="怎么实现所有的线程在等待某个事件的发生才会去执行"></a>怎么实现所有的线程在等待某个事件的发生才会去执行</h3><ol><li>读写锁：主线程先获取写锁，所有的子线程获取读锁，等待线程发生时主线程释放写锁。</li><li>countDownLatch countDownLatch初始值设置为1，所有的子线程调用await方法等待，等事件发生时调用countDown方法计数减为0。</li></ol><h3 id="synchronized和lock有什么区别"><a href="#synchronized和lock有什么区别" class="headerlink" title="synchronized和lock有什么区别"></a>synchronized和lock有什么区别</h3><ol><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类。</li><li>synchronied无法判断是否获取锁的状态，Lock可以判断是否获取到锁。</li><li>synchronized会自动释放锁（a:线程执行完会自动释放锁 b:线程执行遇到异常时会自动释放锁），Lock需要在finally中手动释放锁，否则会造成线程死锁。</li><li>用synchronized关键字的两个线程1和线程2，如果线程1获得锁或者线程1阻塞，线程2则会一直等待下去。而lock锁不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了。</li><li>synchronized锁可重入，不可中断，非公平。而lock锁可重入，可中断，可公平。</li><li>Lock锁适合大量同步的代码同步问题，而synchronized锁适合代码少量同步问题。</li></ol><h3 id="CAS-无锁算法"><a href="#CAS-无锁算法" class="headerlink" title="CAS(无锁算法)"></a>CAS(无锁算法)</h3><p>对于多线程编程问题，为了保证多个线程对同一对象进行访问时，我们需要加同步锁synchronized，保证对象在多线程环境下使用正确性，但是加锁会导致如下两个问题1. 加锁和释放锁会导致上下文切换，引起性能问题。2. 多线程可以导致死锁问题。</p><ul><li>独占锁（悲观锁）：在整个处理过程当中将数据处于锁定状态，它指的是数据被外界修改保持悲观状态，synchronized就是一种独占锁，它会导致所有需要此锁的线程挂起，等待锁的释放。</li><li>乐观锁：相对于悲观锁而言，乐观锁假设一般情况下不会造成冲突，在数据进行提交更新的情况下才会正式对数据的冲突与否进行检测，如果发现数据冲突则让用户决定如何去做。</li></ul><p>CAS的机制就相当于这种（非阻塞算法），CAS由cpu内部硬件实现，执行速度较快，CAS有三个操作参数：内存地址，旧值，新值，操作时比较旧值有没有发生变化，如果没有发生变化就交换新值，没有发生变化则不交换。</p><p>CAS实现原子操作的三大问题：</p><ol><li>ABA问题: CAS操作值的时候，会检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成B,后又变成A,那么使用CAS进行检查时发现它的值没有发生变化，实际上却发生了变化，可以用版本号进行解决。</li><li>循环的时间长开销比较大。</li><li>只能保证一个共享变量的原子操作。</li></ol><h2 id="CountDownLatch和CyclicBarrier简介"><a href="#CountDownLatch和CyclicBarrier简介" class="headerlink" title="CountDownLatch和CyclicBarrier简介"></a>CountDownLatch和CyclicBarrier简介</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch的构造函数接受一个int的参数作为构造器，如果想等待n个完成就需要传入参数为n。当调用countDownLatch的countDown方法时，n就会减1，countDownLatch的await方法会阻塞当前线程，直到n变为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch count = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread() + <span class="string">"正在执行"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      count.countDown();</span><br><span class="line">      System.out.println(Thread.currentThread() + <span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread() + <span class="string">"正在执行"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      count.countDown();</span><br><span class="line">      System.out.println(Thread.currentThread() + <span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"waiting two thread excuted"</span>);</span><br><span class="line">    count.await();</span><br><span class="line">    System.out.println(<span class="string">"all thread alread excuted"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层分析：<br>CountDownLatch底层是基于AQS来实现的，使用一个status变量来判断是否阻塞线程，如果status不为0的情况下，调用await()方法会将当前线程阻塞，并将线程加入队列里面。当有线程调用countdown时，会将status变量减一，直到变为0。</p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier的字面意思是可循环使用的屏障。它要做的事情就是躺一组线程达到一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续执行。线程执行await()方法后线程将减1，并进行等待。直到计数器减为0，所有调用await()方法而在等待的线程才能继续执行。CyclicBarrier和CountDownLatch的区别是CyclicBarrier的计数器可以通过reset()方法循环使用，所以它才叫循环屏障。</p><p>底层分析：</p><p>与CountDownLatch的实现方式不同，并没有直接通过AQS来实现同步功能，而是通过ReentrantLock的基础上实现的。在线程调用await()方法时，会调用Condition的await方法进入等待状态，当最后一个线程调用await()方法时，调用Condition的signalAll方法唤醒所有线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文主要记录了各种并发概念，参考《JAVA并发编程的艺术》。&lt;br&gt;
    
    </summary>
    
      <category term="concurrency" scheme="https://qiutiangang123.github.io/categories/concurrency/"/>
    
    
      <category term="thread" scheme="https://qiutiangang123.github.io/tags/thread/"/>
    
      <category term="concurrency" scheme="https://qiutiangang123.github.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="https://qiutiangang123.github.io/2018/10/13/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>https://qiutiangang123.github.io/2018/10/13/数据存储/数据库系统原理/</id>
    <published>2018-10-13T06:19:02.000Z</published>
    <updated>2019-05-06T02:44:45.684Z</updated>
    
    <content type="html"><![CDATA[<p>本文会介绍一些数据库的系统原理，比如常见的事务概念、数据库的隔离级别等。参考博客<a href="https://github.com/CyC2018" target="_blank" rel="noopener">https://github.com/CyC2018</a><br><a id="more"></a></p><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><p>事物是指满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以通过Rollback进行回滚。</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>事务被看做为最小的执行单位，要么全部执行成功，要么进行事务的回滚。可以通过日志来实现，将事务的操作记录到日志中，回滚时反向执行这些日志即可。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>数据库在事务的执行前后保持一致。在一致性的状态下，所有的事务对一个数据的读取结果都是一致的。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>每个事务都是相互隔离的。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>事务一旦提交，所对数据库的修改将永久的保存在数据库当中。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h3><p>事务在没有提交之前，数据对其他事务是可见的。</p><h3 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h3><p>一个事务只有在提交之后数据才对其他事务可见。</p><h3 id="可重复读（SERIALIZABLE）"><a href="#可重复读（SERIALIZABLE）" class="headerlink" title="可重复读（SERIALIZABLE）"></a>可重复读（SERIALIZABLE）</h3><p>保证同一个事务对一个数据的多次读取结果是相同的。</p><h3 id="可串行读（REPEATABLE-READ）"><a href="#可串行读（REPEATABLE-READ）" class="headerlink" title="可串行读（REPEATABLE READ）"></a>可串行读（REPEATABLE READ）</h3><p>强制事务串行执行。</p><h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难得到保证，因此会出现很多并发一致性的问题。</p><h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><p>T1修改数据，T2读取这个数据，之后T1撤回修改，这样就会导致T1读到的数据是脏数据</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>T2读取一个数据，之后T1对这个数据进行修改，此时T2再次读取时和第一次读取的结果不一样。</p><h3 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h3><p>T1读取一个范围的数据，T2在这个范围内插入数据，此时T1读取的结果和第一次读取的结果不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会介绍一些数据库的系统原理，比如常见的事务概念、数据库的隔离级别等。参考博客&lt;a href=&quot;https://github.com/CyC2018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CyC2018&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://qiutiangang123.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="database" scheme="https://qiutiangang123.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://qiutiangang123.github.io/2018/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://qiutiangang123.github.io/2018/07/27/数据结构与算法/基础排序算法分析/</id>
    <published>2018-07-27T11:19:02.000Z</published>
    <updated>2019-03-12T08:05:49.165Z</updated>
    
    <content type="html"><![CDATA[<p>本文会为大家介绍几种常见的排序算法，将持续更新！<br><a id="more"></a></p><h3 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h3><p>冒泡排序算法是将数组中最大的数放到最后。先比较0和1的位置上数的大小并交换，再比较2和3位置的大小并交换。代码实现如下。其平均时间复杂度为O(n^2)，<br>最坏时间复杂度为O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h3><p>选择排序法是找到数组中最小的元素放到位置0上，找到第二小的数字放到1位置上，依次类推。其平均时间复杂度为O(n^2)， 最坏时间复杂度为O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="comment">// 循环的作用是找到最小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h3><p>插入排序法的核心思想是默认左边的所有元素是有序的，例如待比较的数据为7,6,9,8,5,1。将6开始抽离出来，形成7,_,9,8,5,1从7开始比较，6和7进行比较，发现7&gt;6,将7右移，形成 _,7,9,8,5,1。然后将6插入到7前面的空位。结果为6,7,9,8,5,1。然后一次进行排序。其平均时间复杂度为O(n^2)， 最坏时间复杂度为O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>;j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>将数组中的最后一个值作为比较值，将小于X的值放大数组的左边，大于X的值放到数组的右边。</p><p>然后再将&lt;=x 的区域的最后一个值在祖册区域进行划分，右侧区域依次排序。</p><p>快排的时间复杂度最好的情况是O(N<em>log2N) 最坏的情况是<br>O(n^2) 平均时间复杂度为O(N</em>log2N)</p><p>代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经典快排</span></span><br><span class="line">    classicSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 随机快排</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">classicSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line">      <span class="comment">// 数组，左边界，右边界，partition的条件num</span></span><br><span class="line">      <span class="keyword">int</span>[] part = partition(arr, L, R, arr[R]);</span><br><span class="line">      classicSort(arr, part[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">      classicSort(arr, L, part[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//随机快排</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">      <span class="comment">//随机快排就是经典快排的基础上多这一步：产生一个随机位置与最后一个位置的数交换</span></span><br><span class="line">      <span class="comment">//从而使时间复杂度理论的长期 期望值是 :O(N*logN)</span></span><br><span class="line">      swap(arr, right, left+(<span class="keyword">int</span>)((right-left+<span class="number">1</span>)*Math.random()) );</span><br><span class="line">      <span class="keyword">int</span> par[] = partition(arr, left, right, arr[right]);</span><br><span class="line">      randomSort(arr, left, par[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">      randomSort(arr, par[<span class="number">1</span>]+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 荷兰国旗问题，小于放左边，大于放右边，等于放中间</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = L; <span class="comment">// 当前索引位置</span></span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>; <span class="comment">// 小于区域</span></span><br><span class="line">    <span class="keyword">int</span> more = R;<span class="comment">// 大于区域</span></span><br><span class="line">    <span class="comment">// 当前位置一直向右推，一定会遇到大于的区域</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[index] &lt; num) &#123;</span><br><span class="line">        <span class="comment">// 当前位置的数与小于区域的下一个数进行交换，然后当前位置下移一位</span></span><br><span class="line">        swap(arr, index++, ++less);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &gt; num) &#123;</span><br><span class="line">        <span class="comment">// 当前位置的数与大于区域的数继续交换，由于不知道交换过来的数的大小，所以继续比较</span></span><br><span class="line">        swap(arr, index, --more);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, R);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = t; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h3><p>堆数据结构为完全二叉树，完全二叉树的子节点从左到右必须依次存在。例如下面的树结构，图一不是完全二叉树，因为2没有左节点却存在右节点。不满足从左到右依次存在。图二和图三是完全二叉树。堆排的时间复杂度为 O(N*log2N)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3     </span><br><span class="line">   \</span><br><span class="line">    4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br></pre></td></tr></table></figure><p>其完全二叉树的实际结构对应为一个数组，对于任意一个节点，其左节点为2i-1，其右节点为2i+1。其父节点为i-1/2。</p><p>堆排的核心思想是将首先建立一个初始堆，使堆顶的元素最大，然后将对顶的元素和最后的元素进行交换，比较其左孩子和右孩子的最大值。将最大值进行交换。然后将索引值指向最大值的位置，将左孩子重新赋值为新的索引的左孩子。重复上述过程，就完成堆排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      heapInsert(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">      swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">      swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">      <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">      largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">      <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, largest, index);</span><br><span class="line">      index = largest;</span><br><span class="line">      left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    heapSort(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会为大家介绍几种常见的排序算法，将持续更新！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://qiutiangang123.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm，数据结构，算法" scheme="https://qiutiangang123.github.io/tags/algorithm%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper实现原理</title>
    <link href="https://qiutiangang123.github.io/2018/07/23/%E5%88%86%E5%B8%83%E5%BC%8F/Zookeeper%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://qiutiangang123.github.io/2018/07/23/分布式/Zookeeper实现原理/</id>
    <published>2018-07-23T07:55:07.000Z</published>
    <updated>2019-05-16T08:01:07.279Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper主要是解决分布式环境下服务协调问题而产生的。本文首先讨论如果实现一个Zookeeper要如何设计，然后介绍经典2pc理论，最后会介绍ZAB协议。<br><a id="more"></a></p><h2 id="有关Zookeeper的设计猜想"><a href="#有关Zookeeper的设计猜想" class="headerlink" title="有关Zookeeper的设计猜想"></a>有关Zookeeper的设计猜想</h2><p>如果想要去实现Zookeeper可以考虑主要是从下面几几个方面来实现。</p><p>1：防止单点故障</p><p>如果想要防止单点故障，解决的办法就是将项目部署为高可用集群模式。高可用模式意味着集群中某个节点宕机，不影响整个集群的数据继续提供服务的可能性。一般部署集群模式都是遵循主从复制模式，但是Zookeeper没有遵循这个思路。而是将节点设置为leader、follower和oberserver三种角色，每个节点通过ZAB协议来保证数据一致性。</p><p>2：高可用的集群模式</p><p>如果要满足高可用的集群模式，需要每个节点都可以接受到数据请求，并且每个节点接受的数据请求保持一致。Zookeeper针对这种情况为每个节点分为leader、follower和oberserver三个角色。并且还需要考虑一下leader节点挂了之后的操作（zookeeper用了基于paxos理论所衍生出来 的ZAB协议）。</p><p>3：强一致性</p><p>在分布式系统中，如果想要保持强一致性，就会涉及到分布式事物。分布式事务的数据一致性协议由2pc协议和3pc协议。下面将详细介绍一下经典的2pc理论。</p><h2 id="关于2pc提交"><a href="#关于2pc提交" class="headerlink" title="关于2pc提交"></a>关于2pc提交</h2><p>2pc(Two Phase Commitment Protocol)当一个事务操作需要跨越多个分布式节点的时候，为了保持事务的ACID特性，需要一个协调者(TM)来统一调度所有分布式节点的执行逻辑。这些分布式节点称为AP。TM负责调度AP的行为。并且最终决定这些AP是否要把事务进行真正的提交，因为分两阶段进行提交，所以叫2PC。</p><blockquote><p>阶段一：提交事务请求（投票）</p></blockquote><p>1：事务询问</p><p>协调者向所有的分布式节点发送事务内容，并询问是否可以进行事务提交操作。并开始等待各参与者的反应。</p><p>2：执行事务</p><p>各个参与者执行事务操作，并且将Undo和Redo信息记录到事务操作日志中。并且尽量把提交过程中的所有消耗时间的操作和准备都提前完成，确保后面成功提交事务。</p><p>3: 各个参与者向协调者发送询问响应</p><p>如果各个参与者成功执行事务，则向协调者发送yes相应，如果参与者没有执行成功，则向协调者发送no的响应。</p><blockquote><p>阶段二：提交事务</p></blockquote><p>协调者会根据投票阶段各个参与者的响应去完成响应操作，要么提交事务，要么中断事务（通过undo和redo来完成）。</p><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，主要依赖ZAB协议实现分布式数据的一致性。ZAB协议包含两种基本模式：崩溃恢复和原子广播。</p><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>当整个集群启动时，或者leader节点出现网络中断、崩溃等情况时，ZAB协议就会进入到恢复模式并选举产生新的leader，当leader服务器选举出来后，并且集群中有过半的集合和该leader节点完成同步后，ZAB协议就会退出恢复模式。</p><h4 id="崩溃恢复原理"><a href="#崩溃恢复原理" class="headerlink" title="崩溃恢复原理"></a>崩溃恢复原理</h4><p>ZAB协议基于原子广播协议的，正常情况下没有任何问题，当时一旦leader节点崩溃或者由于网络问题导致leader服务器失去过半的follower节点的联系（网络分区）。那么就会进入到崩溃恢复模式，为了使leader系统可以正常工作，需要解决两个问题。</p><blockquote><p>已被处理的消息不能丢失</p></blockquote><p>当leaders收到合法数量的follower的ack后，就会向各个follower广播commit命令。同时也会在本地执行commit命令。并向客户端返回成功。当时如果各个follower在收到commit命令之前leader挂了，导致剩下的服务器并没有执行这条消息。比如follower1执行了，follower2还没有收到commit命令</p><blockquote><p>被丢弃的消息不能再次出现 </p></blockquote><p>当leader接收到消息请求生成proposal（提案）后就挂了，其他follower并没有收到proposal。因此经过恢复模式。重新选举leader后，这条消息是被跳过了，此时，挂了的leader重新启动并注册了follower，保留了被跳过的proposal状态，与这整个系统状态不一致，需要删除</p><p>ZAB协议需要满足上面两种情况，就必须设计一个leader选举算法：能够确保已经被leader提交事物的proposal能够被提交，同时丢弃已经被跳过的事物proposal。针对这个要求：如果leader选举算法能够保证新选举出来的leader服务器拥有最高的编号（zxid最大）的事物proposal,那么就可以保证这个新选举出来的leader一定具有已经提交的提案。</p><h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><p>当集群中已经有过半的follower节点和leader状态同步后，整个集群就会进入到消息广播模式。在leader正常工作时，启动一台新的服务器进入到新的集群，这个集群就会进入到数据恢复模式，和leader节点进行数据同步，同步完成后，集合正常对外处理非事务请求处理。</p><h4 id="消息广播实现原理"><a href="#消息广播实现原理" class="headerlink" title="消息广播实现原理"></a>消息广播实现原理</h4><p>消息广播实际上就是一个简化版的二阶段提交。</p><ol><li>leader接受到消息请求后，将消息赋予一个全局唯一的64位自增ID：zxid。</li><li>leader为每个follower准备FIFO队列，将带有zxid消息作为一个提案（proposal）分发给所有的follower。</li><li>当follower接收到proposal，先把proposal写到磁盘，写入成功后向leader回复一个ack。</li><li>当leader接收到合法数量的ACK后，leader就会向这些follower发送commit命令，同时在本地指向该消息。</li><li>当follower收到消息的commit命令以后，会提交该消息</li></ol><h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><p>leader选举分为两种情况，启动时leader选举，leader崩溃时选举</p><h4 id="启动时leader选举"><a href="#启动时leader选举" class="headerlink" title="启动时leader选举"></a>启动时leader选举</h4><p>集群初始化时，每一个节点都是LOOKING状态，处于观望状态，接下来就开始进入主流程。当有一台服务器server1启动时，它本身无法进行和完成leader选举，当第二台server2启动时，这两台机器可以相互通信，每个机器试图找到leader，于是进入leader选举过程：</p><ol><li>server1和server2都会将自己作为leader服务器进行投票，每次投票都会包含所推举的服务器myId和zxId,此时server1的投票为（1,0）。server2的投票为（2,0）。然后将各自投票发给其他集群机器。</li><li>接受来自各个服务器的投票</li><li>处理投票：针对每一个投票的服务器都需要将别人的投票和自己的投票PK。pk的规则如下，优先zxid，如果zxid相同则比较myid。</li></ol><h4 id="运行时leader选举"><a href="#运行时leader选举" class="headerlink" title="运行时leader选举"></a>运行时leader选举</h4><p>当集群中的leader服务器出现宕机或不可用的情况下会进行leader选举。</p><ol><li>变更状态：leader挂后，剩下的非observer服务器都会将自己的服务器状态变为LOOKING,然后开始选举</li><li>每个server都会发出一个投票，在运行期间，每个server的zxId可能不同，例如server1的zxid为123，server3的zxid为122。产生投票（1,123），（2,122）</li><li>处理投票</li><li>统计投票</li><li>改变服务器状态</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zookeeper主要是解决分布式环境下服务协调问题而产生的。本文首先讨论如果实现一个Zookeeper要如何设计，然后介绍经典2pc理论，最后会介绍ZAB协议。&lt;br&gt;
    
    </summary>
    
      <category term="Distributed" scheme="https://qiutiangang123.github.io/categories/Distributed/"/>
    
    
      <category term="Java" scheme="https://qiutiangang123.github.io/tags/Java/"/>
    
      <category term="distributed" scheme="https://qiutiangang123.github.io/tags/distributed/"/>
    
      <category term="Zookeeper" scheme="https://qiutiangang123.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://qiutiangang123.github.io/2018/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://qiutiangang123.github.io/2018/07/11/数据结构与算法/红黑树/</id>
    <published>2018-07-11T06:19:02.000Z</published>
    <updated>2019-02-22T04:33:12.335Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍了二叉搜索树，它可以支持任何一种基本动态集合的操作，其时间复杂度为O(n)。因此，如果树的高度较高时，这些操作可能不比链表上执行的快。红黑树是许多平衡搜索树的一种，可以保证最坏的情况下基本动态集合的操作的时间复杂度为O(lgn)。<br><a id="more"></a></p><h3 id="红黑树性质"><a href="#红黑树性质" class="headerlink" title="红黑树性质"></a>红黑树性质</h3><p>红黑树是一颗近似平衡的二叉查找树，它能够确保任何一个节点的左右子树高度二者中最低的二倍。一棵红黑树是满足于下面的红黑性质的二叉搜索树：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色。</li><li>红色节点不能连续（红色节点的孩子和父亲不能是红色）。</li><li>对每个节点，从该节点到其后代节点的简单路径上，均包含相同数目的黑色节点</li></ol><p>有了上面几个性质作为限制，即可避免了二叉查找树退化成单链表的情况。但是仅仅避免这种情况是不够的，这里还要考虑每个节点到其每个页节点的路径长度的问题。如果某些路径长度过长，那么在对这些路径上的节点进行增删查操作时，效率也会大大降低。这个时候性质四和性质五作为约束，即可保证任意节点到其每个页节点的路径的最长不会超过最短路径的二倍。原因如下：</p><p>当某条路径最短时，这条路径必然都是由黑色节点构成的。当某条路径长度最长时，这条路径必然由红色和黑色节点构成的（性质4限定了不能出现两个连续的红色节点）。而性质五又限定了从任意节点到每个页节点的所有路径必须包含相同数量的黑色节点。此时，在路径最长的情况下，路径上的红色节点数量=黑色节点的数量。该路径长度为两倍黑色节点的数量。也就是最短路径长度的两倍。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/红黑树路径.png" alt="image-w100"></p><p>上图画出了从根节点M出发的其页子节点的最长和最短路径，上图包含了两条最短路径，实际上最长路径有四条，分别是：</p><p>M -&gt; Q -&gt; O -&gt; N</p><p>M -&gt; Q -&gt; O -&gt; P</p><p>M -&gt; Q -&gt; Y -&gt; Z</p><p>M -&gt; Q -&gt; Y -&gt; X</p><p>最短路径为 M -&gt; E 长度为2，最长路径是最短路径的两倍。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>红黑树的时间复杂度为O(lgn)</p><p>从某个节点x出发到达一个叶节点的任意一条简单路径上的黑色节点的个数成为该节点的黑高。</p><p>一棵有n个内部节点的红黑树的高度至多为2lg(n+1)</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>红黑树的基本操作有插入和删除，运行时间为O(lgn)。由于这两个操作对树做了修改，可能违反红黑树的性质，通过旋转改变树中的某些节点的颜色以及指针。旋转主要分为两种情况，左旋和右旋。如下图所示：</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/左旋和右旋.png" alt="image-w100"></p><p>左旋的代码如下所示（参考算法导论）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    Node y = x.right<span class="comment">//设置y节点，为x的右节点</span></span><br><span class="line">    <span class="comment">//旋转开始</span></span><br><span class="line">    x.right = y.left <span class="comment">//x的由节点设置为y的左节点</span></span><br><span class="line">    <span class="keyword">if</span> (y.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        y.left.parent = x <span class="comment">//将y的左节点的父节点指向x</span></span><br><span class="line">    &#125;</span><br><span class="line">    y.parent = x.parent</span><br><span class="line">    <span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = y <span class="comment">//如果x的父节点为空，那么y就是root节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == x.parent.left) &#123;</span><br><span class="line">        x.parent.left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.parent.right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y.left = x;</span><br><span class="line">    x.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是左旋修改红黑树例子：</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/左旋例子.png" alt="image-w100"></p><p>左旋和右旋代码是对称的，时间复杂度为O(1),旋转过程只改变指针了指针，其他属性不变。</p><p>右旋代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node y)</span></span>&#123;</span><br><span class="line">       Node&lt;K&gt; x = y.left; <span class="comment">//设置x结点，为y结点的左结点</span></span><br><span class="line">       <span class="comment">//旋转开始</span></span><br><span class="line">       y.left = x.right; <span class="comment">//y的左结点设置为x的右结点</span></span><br><span class="line">       <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</span><br><span class="line">           x.right.parent = y; <span class="comment">//把x右结点的父结点指向y结点</span></span><br><span class="line">       x.parent = y.parent; <span class="comment">//把x的父结点改为y的父结点</span></span><br><span class="line">       <span class="keyword">if</span> (y.parent == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">this</span>.root = x; <span class="comment">//如果y的父结点为空。那么x就是root结点</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (y == y.parent.left) <span class="comment">//y为它父结点的左结点</span></span><br><span class="line">           y.parent.left = x; <span class="comment">//把y的父结点的左结点改为x结点</span></span><br><span class="line">       <span class="keyword">else</span> y.parent.right = x; <span class="comment">//把y的父结点的右结点改为x结点</span></span><br><span class="line">       x.right = y; <span class="comment">//x结点的右结点为y</span></span><br><span class="line">       y.parent = x; <span class="comment">//y的父结点为x</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>总结</p><ol><li>在任何一种有n的节点的红黑树中，有n-1中可能旋转。</li><li>对x进行左旋，意味着将x的由孩子变为x的父节点。左旋中的左，意味着被旋转的节点变成左节点</li><li>对y进行右旋，意味着，将y的左结点变为y的父亲结点；即将y变成了一个右节点(y成了为x的右孩子)。因此，右旋中的右，意味着被旋转的节点将变成一个右节点。</li></ol></blockquote><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>我们可以在O(lgn)的时间内完成向一颗n个节点的红黑树插入一个新的节点。为了做到这一点，利用二叉搜索树的insert过程中的一个略做修改的版本将节点z插入树中，为了保证红黑树的性质，我们用一个辅助的方法fixUp对节点进行重新着色并旋转。</p><p>insert方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node&lt;K&gt; z)</span></span>&#123;</span><br><span class="line">       Node&lt;K&gt; y = <span class="keyword">null</span>;</span><br><span class="line">       Node&lt;K&gt; x = <span class="keyword">this</span>.root;</span><br><span class="line">       <span class="keyword">int</span> com;</span><br><span class="line">       <span class="keyword">while</span> (x != <span class="keyword">null</span>)&#123; <span class="comment">// 如果根结点不为空，循环比较z的key的大小</span></span><br><span class="line">           y = x;</span><br><span class="line">           com = z.key.compareTo(x.key);</span><br><span class="line">           <span class="keyword">if</span> (com &lt; <span class="number">0</span>)</span><br><span class="line">               x = x.left;</span><br><span class="line">           <span class="keyword">else</span> x = x.right;</span><br><span class="line">       &#125;</span><br><span class="line">       z.parent = y; <span class="comment">// y是x结点的父结点，把z结点定义为y结点的子结点</span></span><br><span class="line">       <span class="keyword">if</span> (y == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">this</span>.root = z; <span class="comment">//如果y为null的话，z即为root结点</span></span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           com = z.key.compareTo(y.key);</span><br><span class="line">           <span class="keyword">if</span> (com &lt; <span class="number">0</span>) <span class="comment">//如果z的key小于y的key，即为左结点</span></span><br><span class="line">               y.left = z;</span><br><span class="line">           <span class="keyword">else</span> y.right = z;<span class="comment">//反之为右结点</span></span><br><span class="line">       &#125;</span><br><span class="line">       z.color = RED;<span class="comment">//新增结点颜色定义为红色，不违反红黑树性质的第五条</span></span><br><span class="line">       fixUp(z);<span class="comment">//做颜色上的调整</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>利用fixUP做旋转和着色处理，节点初始值为红色（红色可以少违反一条性质，性质5）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixUp</span><span class="params">(Node&lt;K&gt; z)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (z.parent != <span class="keyword">null</span> &amp;&amp; z.parent.color)&#123; <span class="comment">//若当前z结点的父结点是红色</span></span><br><span class="line">           <span class="keyword">if</span> (z.parent == z.parent.parent.left)&#123; <span class="comment">//若z的父结点是z的祖父结点的左结点</span></span><br><span class="line">               Node&lt;K&gt; y = z.parent.parent.right; <span class="comment">//定义y结点为z的祖父结点的右结点</span></span><br><span class="line">               <span class="keyword">if</span> (y != <span class="keyword">null</span> &amp;&amp; y.color)&#123; <span class="comment">//case1: 如果y是红色</span></span><br><span class="line">                   z.parent.color = BLACK; <span class="comment">//z的父结点为黑色</span></span><br><span class="line">                   y.color = BLACK; <span class="comment">//z的叔叔结点为黑色</span></span><br><span class="line">                   z.parent.parent.color = RED; <span class="comment">//祖父结点为红色</span></span><br><span class="line">                   z = z.parent.parent; <span class="comment">//将祖父节点设为当前节点(红色节点)</span></span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (z == z.parent.right)&#123; <span class="comment">//case2: y是黑色，且当前结点为右结点</span></span><br><span class="line">                       z = z.parent; <span class="comment">//将父节点作为新的当前节点。</span></span><br><span class="line">                       rotateLeft(z); <span class="comment">//以新的当前节点为支点进行左旋。</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//case3: y是黑色，且当前节点是左结点。</span></span><br><span class="line">                   z.parent.color = BLACK; <span class="comment">//设置父结点为黑色</span></span><br><span class="line">                   z.parent.parent.color = RED; <span class="comment">//祖父结点为红色</span></span><br><span class="line">                   rotateRight(z.parent.parent); <span class="comment">//以z的祖父结点为支点右旋</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123; <span class="comment">//若z的父结点是z的祖父结点的右结点</span></span><br><span class="line">               Node&lt;K&gt; y = z.parent.parent.left; <span class="comment">//定义y结点为z的祖父结点的左结点</span></span><br><span class="line">               <span class="comment">//case1：y结点是红色</span></span><br><span class="line">               <span class="keyword">if</span> (y.color) &#123;</span><br><span class="line">                   z.parent.color = BLACK;</span><br><span class="line">                   y.color = BLACK;</span><br><span class="line">                   z.parent.parent.color = RED;</span><br><span class="line">                   z = z.parent.parent; <span class="comment">//将祖父节点设为当前节点(红色节点)</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//case2：y是黑色，且当前节点是左结点</span></span><br><span class="line">                   <span class="keyword">if</span> (z == z.parent.left)&#123;</span><br><span class="line">                       z = z.parent; <span class="comment">//将父节点作为新的当前节点。</span></span><br><span class="line">                       rotateRight(z); <span class="comment">//以新的当前节点为支点进行右旋。</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//case3: y是黑色，且当前节点是右结点。</span></span><br><span class="line">                   z.parent.color = BLACK; <span class="comment">//设置父结点为黑色</span></span><br><span class="line">                   z.parent.parent.color = RED; <span class="comment">//祖父结点为红色</span></span><br><span class="line">                   rotateLeft(z.parent.parent); <span class="comment">//以z的祖父结点为支点左旋</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.root.color = BLACK;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>下图是fixUP的工作原理：</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/fixUp工作原理.png" alt="image-w100"></p><p>与n个节点的红黑树的其他基本操作一样，删除一个节点要花费的时间也是O(lgn)。与插入操作相比，删除操作要更加复杂一些。从一棵红黑树中删除节点的过程是基于二叉搜索树的delete过程。同样也需要transplant子过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transplant</span><span class="params">(Node&lt;K&gt; u, Node&lt;K&gt; v)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (u.parent == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">this</span>.root = v;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (u == u.parent.left)</span><br><span class="line">           u.parent.left = v;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           u.parent.right = v;</span><br><span class="line">       v.parent = u.parent;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>delete方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node&lt;K&gt; z)</span></span>&#123; <span class="comment">//z是被删除结点</span></span><br><span class="line">       <span class="comment">//x是取代节点的右孩子，也是需要调整的节点。</span></span><br><span class="line">       Node&lt;K&gt; x, parent;</span><br><span class="line">       <span class="keyword">boolean</span> color;</span><br><span class="line">       <span class="keyword">if</span> ((z.left != <span class="keyword">null</span>) &amp;&amp; (z.right != <span class="keyword">null</span>) ) &#123; <span class="comment">//被删除节点的左右结点都不为空的情况。</span></span><br><span class="line">           Node&lt;K&gt; y = z; <span class="comment">//被删节点的后继节点。用它来取代被删节点的位置，然后再将被删节点去掉。</span></span><br><span class="line">           y = y.right; <span class="comment">//获取后继节点</span></span><br><span class="line">           <span class="keyword">while</span> (y.left != <span class="keyword">null</span>)</span><br><span class="line">               y = y.left;</span><br><span class="line">           <span class="keyword">if</span> (z.parent != <span class="keyword">null</span>) &#123; <span class="comment">//要删除的结点不是根结点</span></span><br><span class="line">               <span class="keyword">if</span> (z.parent.left == z)</span><br><span class="line">                   z.parent.left = y;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   z.parent.right = y;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.root = y; <span class="comment">//是根结点</span></span><br><span class="line">           &#125;</span><br><span class="line">           x = y.right;</span><br><span class="line">           parent = y.parent;</span><br><span class="line">           <span class="comment">//保存取代节点的颜色</span></span><br><span class="line">           color = y.color;</span><br><span class="line">           <span class="comment">//被删除节点是它的后继节点的父节点</span></span><br><span class="line">           <span class="keyword">if</span> (parent == z) &#123;</span><br><span class="line">               parent = y;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//x不为空</span></span><br><span class="line">               <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">                   x.parent = parent;</span><br><span class="line">               parent.left = x;</span><br><span class="line">               y.right = z.right;</span><br><span class="line">               z.right.parent = y;</span><br><span class="line">           &#125;</span><br><span class="line">           y.parent = z.parent;</span><br><span class="line">           y.color = z.color;</span><br><span class="line">           y.left = z.left;</span><br><span class="line">           z.left.parent = y;</span><br><span class="line">           <span class="keyword">if</span> (color == BLACK)</span><br><span class="line">               deleteFixUp(x, parent);</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (z.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           x = z.left;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           x = z.right;</span><br><span class="line">       &#125;</span><br><span class="line">       parent = z.parent;</span><br><span class="line">       <span class="comment">//保存取代节点的颜色</span></span><br><span class="line">       color = z.color;</span><br><span class="line">       <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">           x.parent = parent;</span><br><span class="line">       <span class="comment">//不是根节点</span></span><br><span class="line">       <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (parent.left == z)</span><br><span class="line">               parent.left = x;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               parent.right = x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.root = x;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (color == BLACK)</span><br><span class="line">           deleteFixUp(x, parent);</span><br></pre></td></tr></table></figure></p><p>deleteFixUp方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteFixUp</span><span class="params">(Node&lt;K&gt; x, Node&lt;K&gt; parent)</span></span>&#123;</span><br><span class="line">       Node&lt;K&gt; w;</span><br><span class="line">       <span class="keyword">while</span> ((x == <span class="keyword">null</span> || x.color == BLACK) &amp;&amp; (x != <span class="keyword">this</span>.root)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (parent.left == x) &#123; <span class="comment">//如果x是它父结点的左结点</span></span><br><span class="line">               w = parent.right;</span><br><span class="line">               <span class="keyword">if</span> (w.color == RED) &#123;</span><br><span class="line">                   <span class="comment">//case1: x的兄弟w是红色的</span></span><br><span class="line">                   <span class="comment">//因为w必须有黑色子结点，所以可以改变w和x.parent的颜色，然后对x.parent做一次左旋</span></span><br><span class="line">                   w.color = BLACK;</span><br><span class="line">                   parent.color = RED;</span><br><span class="line">                   rotateLeft(parent);</span><br><span class="line">                   w = parent.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> ((w.left == <span class="keyword">null</span> || w.left.color == BLACK) &amp;&amp;</span><br><span class="line">                       (w.right == <span class="keyword">null</span> || w.right.color == BLACK)) &#123;</span><br><span class="line">                   <span class="comment">//case2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的</span></span><br><span class="line">                   <span class="comment">//因为w也是黑色，所以从x上去掉一重黑色，使x只有一重黑色而w为红色，在原来的x.parent上新增一重额外的黑色，通过将x.parent作为新的结点来重复循环实现。</span></span><br><span class="line">                   w.color = RED;</span><br><span class="line">                   x = parent;</span><br><span class="line">                   parent = x != <span class="keyword">null</span> ? x.parent : <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (w.right == <span class="keyword">null</span> || w.right.color == BLACK) &#123;</span><br><span class="line">                       <span class="comment">//case3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色</span></span><br><span class="line">                       <span class="comment">//交换w和其左孩子的颜色，然后对w进行右旋</span></span><br><span class="line">                       w.left.color = BLACK;</span><br><span class="line">                       w.color = RED;</span><br><span class="line">                       rotateRight(w);</span><br><span class="line">                       w = parent.right;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//case4: x的兄弟w是黑色的；并且w的右孩子是红色的</span></span><br><span class="line">                   <span class="comment">//修改w，x.parent, w.right颜色，对x.parent进行左旋，设置x为root结束循环</span></span><br><span class="line">                   w.color = parent != <span class="keyword">null</span> ? parent.color : BLACK;</span><br><span class="line">                   parent.color = BLACK;</span><br><span class="line">                   w.right.color = BLACK;</span><br><span class="line">                   rotateLeft(parent);</span><br><span class="line">                   x = <span class="keyword">this</span>.root;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">//x是父结点的右结点时情况和上面相反</span></span><br><span class="line">               w = parent.left;</span><br><span class="line">               <span class="keyword">if</span> (w.color == RED) &#123;</span><br><span class="line">                   w.color = BLACK;</span><br><span class="line">                   parent.color = RED;</span><br><span class="line">                   rotateRight(parent);</span><br><span class="line">                   w = parent.left;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> ((w.left == <span class="keyword">null</span> || w.left.color == BLACK) &amp;&amp;</span><br><span class="line">                       (w.right == <span class="keyword">null</span> || w.right.color == BLACK)) &#123;</span><br><span class="line">                   w.color = RED;</span><br><span class="line">                   x = parent;</span><br><span class="line">                   parent = x != <span class="keyword">null</span> ? x.parent : <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (w.left == <span class="keyword">null</span> || w.left.color == BLACK) &#123;</span><br><span class="line">                       w.right.color = BLACK;</span><br><span class="line">                       w.color = RED;</span><br><span class="line">                       rotateLeft(w);</span><br><span class="line">                       w = parent.left;</span><br><span class="line">                   &#125;</span><br><span class="line">                   w.color = parent != <span class="keyword">null</span> ? parent.color : BLACK;</span><br><span class="line">                   parent.color = BLACK;</span><br><span class="line">                   w.left.color = BLACK;</span><br><span class="line">                   rotateRight(parent);</span><br><span class="line">                   x = <span class="keyword">this</span>.root;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">           x.color = BLACK;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>下图给出了deleteFixUp的几种情况:</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/deleteFixUp.png" alt="image-w100"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面介绍了二叉搜索树，它可以支持任何一种基本动态集合的操作，其时间复杂度为O(n)。因此，如果树的高度较高时，这些操作可能不比链表上执行的快。红黑树是许多平衡搜索树的一种，可以保证最坏的情况下基本动态集合的操作的时间复杂度为O(lgn)。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://qiutiangang123.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm，数据结构，算法" scheme="https://qiutiangang123.github.io/tags/algorithm%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="https://qiutiangang123.github.io/2018/07/07/Java/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://qiutiangang123.github.io/2018/07/07/Java/ConcurrentHashMap源码分析/</id>
    <published>2018-07-07T10:17:02.000Z</published>
    <updated>2019-05-05T03:14:34.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashMap是线程不安全的。如果想要线程安全的HashMap可以使用Hashtable、Collections.synchronizedMap(new HashMap())或者ConcurrentHashMap。通常ConcurrentHashMap是更好的选择。<a id="more"></a>Hashtable是一个遗留类，线程安全的实现过程就是在方法中使用synchronized关键字。Collections.synchronizedMap(new HashMap())是对整个Map进行加锁。而ConcurrentHashMap是对桶数组进行加锁。在JDK1.8中ConcurrentHashMap与HashMap中有相通之处。底层依然由数组链表和红黑树组成。ConcurrentHashMap在实际中借用了较多的CAS算法。例如初始化利用CAS来判断有无其他线程进行初始化，在put元素时，如果数组中的元素为null时，则直接根据CAS插入。如果hash值相同的链表的头结点，会使用synchronized上锁，这样才能保证线程安全。本文源码分析根据JDK1.8版本。</p><h2 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h2><h3 id="JDK1-6的实现"><a href="#JDK1-6的实现" class="headerlink" title="JDK1.6的实现"></a>JDK1.6的实现</h3><p>ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层由Segment数组和HashEntry数组组成。segment继承ReentrantLock用来充当锁的角色，每个segment对象守护每个散列表的若干个桶。HashEntry用来封装映射表的键值对；每个桶是由若干个HashEntry对象连接起来的链表。一个ConcurrentHashMap实例中包含由若干个Segement对象组成的数组。如图所示。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/structure.png" alt="image-w100"></p><h3 id="JDK1-8中的改进"><a href="#JDK1-8中的改进" class="headerlink" title="JDK1.8中的改进"></a>JDK1.8中的改进</h3><p>取消了segement字段（segement虽然已经保留，但是为了兼容旧版本），直接采用transient volatile HashEntry table保存数据，采用table数组元素作为锁，从而实现了对每一行元素加锁，进一步减少并发冲突的概率。</p><p>将原来的table数组+单向链表的数据结构，变更为table数组+单向链表+红黑树的数据结构（和hashmap是相同的），对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中，如果hash之后散列的很均匀，那么table数组中的每个元素的队列长度主要为0或者1。单实际情况并非总是如此理想，虽然CorrentHashMap类默认的负载因子是0.75，但是在数据量大或者运气不佳的情况下，还是会存在一些队列过长。如果还是采用单向链表的方式，那么查询某个节点的时间复杂度是O(n),因此，对于个数超过8的链表，JDK1.8采用了红黑树的结构，那么时间复杂度为O(lgn)，可以改进性能。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//最大的表容量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">   <span class="comment">//默认的初始表容量。必须是2的幂</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//最大(两个)数组大小。</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">   <span class="comment">//此表的默认并发级别。(1.8中已经不使用了，为了兼容以前的版本)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//这个表的装载因子。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">   <span class="comment">//链表转红黑树的阀值，如果table[i]下面的链表长度大于8时就转化为树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//红黑树转链表的阀值，小于等于6时转为链表，仅在扩容时才可能树转链表</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//数组可以转化为树的表的最小容量，（否则，如果一个bin中的节点太多，表将被调整大小。）该值应至少为4 * TREEIFY_THRESHOLD以避免调整大小和树化阈值之间的冲突。</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//每个转移步骤的最小重新排列数。范围是细分为允许多个resizer线程。这个值作为一个下限，以避免resizers遇到内存争夺过多，该值至少应该是DEFAULT_CAPACITY。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//用来控制扩容的时候 单线程进入的变量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">//可以帮助调整大小的最大线程数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//节点的标识</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="comment">//装数据的数组，第一次插入数据的时候初始化,大小为2^n.</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">   <span class="comment">//扩容时使用</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">   <span class="comment">//记录容器的容量大小(但返回的不一定是当前Map的真实元素个数)，通过CAS无锁更新</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">//hash表初始化或扩容时的一个控制位标识量。</span></span><br><span class="line">   <span class="comment">//负数代表正在进行初始化或扩容操作</span></span><br><span class="line">   <span class="comment">//-1代表正在初始化</span></span><br><span class="line">   <span class="comment">//-N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line">   <span class="comment">//正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</span></span><br><span class="line">   <span class="comment">//默认是table大小的0.75 倍，用公式0.75（n - (n &gt;&gt;&gt; 2)）计算。</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line">   <span class="comment">//自旋锁（锁定通过 CAS）在调整大小和/或创建CounterCells时使用。在CounterCell类更新value中会使用，功能类似显示锁和内置锁，性能更好(在Striped64类也有应用)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ConcurrentHashMap共有5个构造方法，这里主要介绍第五个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/看一下最后一个参数concurrencyLevel,表示能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查参数的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回给定所需容量，table的大小总是2的幂次方</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码先用一系列的移位和|操作把n变成二进制表示的形式，然后右移一位，就会变成2^k了。</p><h3 id="重要的内部类"><a href="#重要的内部类" class="headerlink" title="重要的内部类"></a>重要的内部类</h3><blockquote><p>Node</p></blockquote><p>Node是最核心的内部类，它包装了key-value的键值对，与HashMap的定义很相似，但是两者之间还是有一些差别，它对value和next属性设置了volatile同步锁，它不允许调用setValue()方法直接改变Node的value域，它增加了find()方法辅助map.get()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">            <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                    (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                    (v == (u = val) || v.equals(u)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    K ek;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>TreeNode节点</p></blockquote><p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转化成TreeNode。但是与HashMap不同的是，它并不是直接转换成红黑树，而是把这些节点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap中继承Node类，而并非HashMap中继承子LinkedHashMap.entry类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">     * starting at given root.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TreeBin</p></blockquote><p>这个类并不负责包装用户的key,value信息，而是包装很多TreeNode节点。它代替了TreeNode的根节点，也就是实际的ConcurrentHashMap数组中，存放的是TreeBin对象，而不是Node对象，这是与HashMap的区别，另外这个类还带有读写锁。</p><blockquote><p>ForwardingNode</p></blockquote><p>在transfer操作中使用，一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1。这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。生命周期：仅存活于扩容操作。</p><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><blockquote><p>initTable</p></blockquote><p>当put()方法调用table==null时会执行此方法初始化table</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化表，使用sizeCtl中记录的大小。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="comment">//进入循环</span></span><br><span class="line">       <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//如果sizeCtl&lt;0说明已经有其它线程正在进行扩容，即正在初始化或初始化完成,其它线程通过Thread.yield()让出CPU时间片，等待table非空即可。</span></span><br><span class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">           <span class="comment">//利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                       <span class="comment">//这里注意table的大小为sizeCtl</span></span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>helpTransfer</p></blockquote><p>这是扩容过程中的辅助方法。在多线程的情况下，如果发现其他线程正在扩容，则帮助转移元素（只有这种情况下会被调用）。从某种程度上来说，其优先级很高，只要检测到扩容就会放下其他工作，先扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用这个方法之前，nextTable对象一定已经存在的。</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">           (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回用于调整大小为n的表的大小的标记位。</span></span><br><span class="line">           <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">           <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                  (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                   sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="comment">//开始扩容</span></span><br><span class="line">                   transfer(tab, nextTab);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> nextTab;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> table;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>addCount</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">       CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">       <span class="comment">//利用CAS方法把当前ConcurrentHashMap的元素个数+1</span></span><br><span class="line">       <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">           !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">           CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">           <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">               (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">               !(uncontended =</span><br><span class="line">                 U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">               <span class="comment">//多线程CAS发生失败的时候执行</span></span><br><span class="line">               fullAddCount(x, uncontended);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           s = sumCount();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span></span><br><span class="line">       <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">           <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">               <span class="comment">//正在进行初始化或扩容操作</span></span><br><span class="line">               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                       transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="comment">//如果已经有其他线程在执行扩容操作</span></span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                       transfer(tab, nt);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                   transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">               s = sumCount();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>transfer</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">       <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">           stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">       <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               <span class="comment">//构造一个nextTable对象 它的容量是原来的两倍</span></span><br><span class="line">               Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">               nextTab = nt;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">               sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           nextTable = nextTab;</span><br><span class="line">           transferIndex = n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">       <span class="comment">//构造一个连节点指针 用于标志位</span></span><br><span class="line">       ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">       <span class="comment">//并发扩容的关键属性 如果等于true 说明这个节点已经处理过</span></span><br><span class="line">       <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//循环的关键变量，判断是否已经扩容完成，完成就return，退出循环</span></span><br><span class="line">       <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">       <span class="comment">//死循环</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">           <span class="comment">//循环的关键控制i，i--操作保证了倒序遍历数组</span></span><br><span class="line">           <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">               <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                   advance = <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">//nextIndex=transferIndex=n=tab.length(默认16)</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   i = -<span class="number">1</span>;</span><br><span class="line">                   advance = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//用CAS计算得到的transferIndex</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                         nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                      nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                   bound = nextBound;</span><br><span class="line">                   i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                   advance = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//i&lt;0，i&gt;=n说明已经遍历完旧的数组tab，i+n&gt;=nextn说明已经扩容完成</span></span><br><span class="line">           <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">               <span class="keyword">int</span> sc;</span><br><span class="line">               <span class="comment">//所有节点复制完毕</span></span><br><span class="line">               <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                   nextTable = <span class="keyword">null</span>;</span><br><span class="line">                   table = nextTab;</span><br><span class="line">                   <span class="comment">//扩容阈值设置为原来容量的1.5倍，相当于现在容量的0.75倍</span></span><br><span class="line">                   sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//利用CAS更新扩容阈值,sc-1表明新加入一个线程参与扩容</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="comment">//如果有两个线程，值肯定不相等，所以直接返回（保持只有一个线程执行）</span></span><br><span class="line">                   <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   <span class="comment">//finishing和advance保证线程已经扩容完成了可以退出循环</span></span><br><span class="line">                   finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                   i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">               advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">           <span class="comment">//f.hash=-1,说明该节点为ForwardingNode，说明该节点已经处理过了</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//把当前节点加锁</span></span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                   <span class="comment">//ln原位置节点，hn新位置节点</span></span><br><span class="line">                       Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                       <span class="comment">//这是一个链表Node节点</span></span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                           <span class="comment">//构造两个链表，一个是原链表；另一个是原链表的反序排列</span></span><br><span class="line">                           Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                               <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                               <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                   runBit = b;</span><br><span class="line">                                   lastRun = p;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                               ln = lastRun;</span><br><span class="line">                               hn = <span class="keyword">null</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               hn = lastRun;</span><br><span class="line">                               ln = <span class="keyword">null</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                               <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                               <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                   ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//在nextTable的i位置上插入一个链表</span></span><br><span class="line">                           setTabAt(nextTab, i, ln);</span><br><span class="line">                           <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                           setTabAt(nextTab, i + n, hn);</span><br><span class="line">                           <span class="comment">//在table的i位置上插入forwardNode节点  表示已经处理过该节点</span></span><br><span class="line">                           setTabAt(tab, i, fwd);</span><br><span class="line">                           <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></span><br><span class="line">                           advance = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//对TreeBin对象进行处理，与上面的过程类似</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                           TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                           TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                           <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                           <span class="comment">//构造正序和反序两个链表</span></span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                               <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                               TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                   (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                               <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                   <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                       lo = p;</span><br><span class="line">                                   <span class="keyword">else</span></span><br><span class="line">                                       loTail.next = p;</span><br><span class="line">                                   loTail = p;</span><br><span class="line">                                   ++lc;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="keyword">else</span> &#123;</span><br><span class="line">                                   <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                       hi = p;</span><br><span class="line">                                   <span class="keyword">else</span></span><br><span class="line">                                       hiTail.next = p;</span><br><span class="line">                                   hiTail = p;</span><br><span class="line">                                   ++hc;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//如果扩容后已经不再需要tree的结构，反向转换为链表结构</span></span><br><span class="line">                           ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                               (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                           hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                               (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                           <span class="comment">//在nextTable的i位置上插入一个链表</span></span><br><span class="line">                           setTabAt(nextTab, i, ln);</span><br><span class="line">                           <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></span><br><span class="line">                           setTabAt(nextTab, i + n, hn);</span><br><span class="line">                           <span class="comment">//在table的i位置上插入fwd节点，表示已经处理过该节点</span></span><br><span class="line">                           setTabAt(tab, i, fwd);</span><br><span class="line">                           advance = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>put方法</p></blockquote><p>既然上面说的ConcurrentHashMap的构造函数不会初始化table，会延迟到第一次put，那么我们就来看看put方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//计算hash值</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//putVal操作采用CAS+synchronized实现并发插入或更新操作</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">//算出hash值（即数组下标）</span></span><br><span class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">       <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//死循环，直到插入成功</span></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//初始化table</span></span><br><span class="line">               tab = initTable();</span><br><span class="line">           <span class="comment">//去除tab中的节点赋值给f</span></span><br><span class="line">           <span class="comment">//如果table[i]==null(即该位置的节点为空，没有发生碰撞)，则利用CAS操作直接存储在该位置，如果CAS操作成功则退出死循环。</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//table[i]!=null(即该位置已经有其它节点，发生碰撞)</span></span><br><span class="line">           <span class="comment">//检查table[i]的节点的hash是否等于MOVED，如果等于，则检测到正在扩容，则帮助其扩容</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               V oldVal = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span></span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">               <span class="comment">//避免多线程，需要重新检查</span></span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                   <span class="comment">//fh〉0 说明这个节点是一个链表的节点 不是树的节点</span></span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="comment">//hash和key都相同</span></span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="comment">//如果没有找到值为key的节点，新建Node加入链表。</span></span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, <span class="keyword">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//首节点为TreeBin，为红黑树结构，按照红黑树的方式插入数据。</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//如果链表长度达到阀值需要调整结构变为红黑树。</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将当前ConcurrentHashMap的元素数量+1，有可能触发扩容操作。</span></span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>tryPresize</p></blockquote><p>这个方法也是扩容操作。在putAll和链表转红黑树的时候使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容</span></span><br><span class="line">       <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">           tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="comment">//没有正在初始化或扩容，或者说表还没有被初始化</span></span><br><span class="line">       <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">           <span class="comment">//没有被初始化</span></span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">               n = (sc &gt; c) ? sc : c;</span><br><span class="line">               <span class="comment">//期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//重复检查</span></span><br><span class="line">                       <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                           Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                           table = nt;</span><br><span class="line">                           <span class="comment">//无符号右移2位(即0.75*n)</span></span><br><span class="line">                           sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//更新扩容阀值</span></span><br><span class="line">                       sizeCtl = sc;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//若想要扩容的值不大于原阀值，或现有容量&gt;=最值，什么都不用做了</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">           <span class="comment">//返回一个标志位</span></span><br><span class="line">               <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">               <span class="comment">//执行扩容操作</span></span><br><span class="line">               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt;[] nt;</span><br><span class="line">                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                       transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                       transfer(tab, nt);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                   transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>treeifyBin</p></blockquote><p>链表转红黑树的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">       <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//容量小于64，扩容</span></span><br><span class="line">           <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">               tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                       TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                           TreeNode&lt;K,V&gt; p =</span><br><span class="line">                               <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                 <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                           <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                               hd = p;</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               tl.next = p;</span><br><span class="line">                           tl = p;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//在原来index的位置，用TreeBin替换掉原来的Node对象</span></span><br><span class="line">                       setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>get</p></blockquote><p> 上面介绍完put方法，下面看看get方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">      <span class="comment">//计算hash值</span></span><br><span class="line">      <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">      <span class="comment">//根据hash值确定节点位置</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">              <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                  <span class="keyword">return</span> e.val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//eh&lt;0，说明这个节点在树上，直接查找树</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">//链表，找到对应的值并返回</span></span><br><span class="line">          <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                  ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                  <span class="keyword">return</span> e.val;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>containsValue</p></blockquote><p> 查询当前ConcurrentHashMap是否包含该value值。有可能需要遍历一遍ConcurrentHashMap。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断value是否为null，这里和HashMap不同</span></span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       Node&lt;K,V&gt;[] t;</span><br><span class="line">       <span class="comment">//如果table不为空遍历table。</span></span><br><span class="line">       <span class="keyword">if</span> ((t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Traverser&lt;K,V&gt; it = <span class="keyword">new</span> Traverser&lt;K,V&gt;(t, t.length, <span class="number">0</span>, t.length);</span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; p; (p = it.advance()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">               V v;</span><br><span class="line">               <span class="keyword">if</span> ((v = p.val) == value || (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>replaceNode</p></blockquote><p> remove的核心方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//注意：cv才是key-value中的value！</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">           <span class="comment">//该table第一个元素为空，直接跳过</span></span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">               (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               V oldVal = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           validated = <span class="keyword">true</span>;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   V ev = e.val;</span><br><span class="line">                                   <span class="comment">//value为null或value和查到的值相等</span></span><br><span class="line">                                   <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                       (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                       oldVal = ev;</span><br><span class="line">                                       <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                           e.val = value;</span><br><span class="line">                                       <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                           pred.next = e.next;</span><br><span class="line">                                       <span class="keyword">else</span></span><br><span class="line">                                           setTabAt(tab, i, e.next);</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               pred = e;</span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//以树的方式find、remove</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           validated = <span class="keyword">true</span>;</span><br><span class="line">                           TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                           TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                           <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                               (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               V pv = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                   (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                   oldVal = pv;</span><br><span class="line">                                   <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                       p.val = value;</span><br><span class="line">                                   <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                       setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                           addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>clear</p></blockquote><p> 移除ConcurrentHashMap中所有的元素。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> delta = <span class="number">0L</span>; <span class="comment">// negative number of deletions</span></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      Node&lt;K,V&gt;[] tab = table;</span><br><span class="line">      <span class="keyword">while</span> (tab != <span class="keyword">null</span> &amp;&amp; i &lt; tab.length) &#123;</span><br><span class="line">          <span class="keyword">int</span> fh;</span><br><span class="line">          Node&lt;K,V&gt; f = tabAt(tab, i);</span><br><span class="line">          <span class="comment">//为空，直接跳过</span></span><br><span class="line">          <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">              ++i;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">              tab = helpTransfer(tab, f);</span><br><span class="line">              i = <span class="number">0</span>; <span class="comment">// restart</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      Node&lt;K,V&gt; p = (fh &gt;= <span class="number">0</span> ? f :</span><br><span class="line">                                     (f <span class="keyword">instanceof</span> TreeBin) ?</span><br><span class="line">                                     ((TreeBin&lt;K,V&gt;)f).first : <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">//首先删除链、树的末尾元素，避免产生大量垃圾</span></span><br><span class="line">                      <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          --delta;</span><br><span class="line">                          p = p.next;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//利用CAS无锁置null</span></span><br><span class="line">                      setTabAt(tab, i++, <span class="keyword">null</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (delta != <span class="number">0L</span>)</span><br><span class="line">          addCount(delta, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ConcurrentHashMap是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于HashTable和同步包装器包装的HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。<br>1.6中采用ReentrantLock 分段锁的方式，使多个线程在不同的segment上进行写操作不会发现阻塞行为;1.8中直接采用了内置锁synchronized，因为1.8的虚拟机对内置锁已经优化的足够快了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;HashMap是线程不安全的。如果想要线程安全的HashMap可以使用Hashtable、Collections.synchronizedMap(new HashMap())或者ConcurrentHashMap。通常ConcurrentHashMap是更好的选择。
    
    </summary>
    
      <category term="Java" scheme="https://qiutiangang123.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://qiutiangang123.github.io/tags/Java/"/>
    
      <category term="collection" scheme="https://qiutiangang123.github.io/tags/collection/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="https://qiutiangang123.github.io/2018/07/05/Java/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://qiutiangang123.github.io/2018/07/05/Java/HashMap源码分析/</id>
    <published>2018-07-05T04:17:02.000Z</published>
    <updated>2019-05-17T06:35:26.138Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是一种以Key,value存在的经典数据结构，也是在开发过程中比较常用的数据结构，本篇博客主要是结合源码进行分析理解。<br><a id="more"></a></p><h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>Java为数据结构映射定义了一个接口java.util.map，此接口公用四个常用的实现类，分别是HashMap,LinkedHashMap,HashTable,TreeMap。下面针对这四个常用集合进行说明。</p><blockquote><p>HashMap </p></blockquote><p>它根据键的hashcode进行存储数据，大多数的情况下可以直接定位它的值，因而具有很快的访问速度，但是遍历顺序不是确定的，HashMap最多允许一条记录的键为空，允许多条记录的值为空。HashMap不是线程安全的。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><blockquote><p>HashTable</p></blockquote><p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它是线程安全的和不允许键为空，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><blockquote><p>LinkedHashMap</p></blockquote><p>LinkedHashMap是HashMap的一个子类，它与HashMap的区别是LinkedHashMap是有序的，而HashMap是无序的。</p><blockquote><p>TreeMap</p></blockquote><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p><h2 id="HashMap知识点归纳总结"><a href="#HashMap知识点归纳总结" class="headerlink" title="HashMap知识点归纳总结"></a>HashMap知识点归纳总结</h2><blockquote><p>hashmap为什么不是线程安全的</p></blockquote><p>hashmap底层是一个Entry数组，当发生hash冲突的时候，hashmap采用链表的方式来解决，在对应的数组位置放链表的头结点，对链表来说，新加入的节点会从头结点加入（此过程不是同步的，如果多个线程同时访问一个hash映射，而其中一个线程从结构上修改该映射，则它必须保持跟外部同步）。如果两个线程同时对同一桶数组进行添加元素，线程a添加成功后，线程b会将其覆盖。会造成线程a的写操作丢失</p><blockquote><p> hashmap和hashtable区别</p></blockquote><ol><li>hashmap允许键值对为空，hashtable不允许键值对为空</li><li>hashtable的public的方法被synchronized修饰，线程安全的。</li><li>尽量不要使用hashtable，单线程可以使用hashmap，多线程可以使用concurrentHashMap，hashtable采用synchronized关键字，即hashtable是针对整个map进行锁定，ConcurrentHashMap是对map中的所有桶加了锁。这样会导致在竞争激烈的并发环境表现出效率低问题。</li></ol><blockquote><p>为什么hashMap中数组的size必须是2的次幂</p></blockquote><p>Hash简介：Hash一般译为散列或者直接音译为哈希，就是把任意长度的输入，通过hash算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是说，散列的空间远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单来说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>Hash表是一种与数组，链表等不同的数据结构，与他们需要不断的遍历比较来查找的办法，哈希表设计了一种哈希关系f(key)=address,根据key来计算存储地址address,这样可以一次查找。f既是存储数据过程中，用来指引数据存储到什么位置的函数。</p><p>如果桶数组的长度为2的次幂，则length-1转换成二进制末尾为1，再与hash进行与操作则不会造成空间的浪费，而如果不是2的次幂，则转换成二进制的末尾是0，则与hash进行运算时hash转换成二进制末尾不能为1。</p><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>从结构上来讲，HashMap是数组 + 链表 + 红黑树实现的，如下所示：</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/HashMap.png" alt="image-w100"></p><p>需要明白两个问题：数据底层到底存储的是什么？这样存储的方式有什么优点？</p><blockquote><p>底层实现</p></blockquote><p>从源码可知，HashMap类有一个非常重要的字段，就是Node[] table即桶数组，很明显是Node数组，底层源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry&lt;K,V&gt;,其本身就是一个映射（键值对），上图的黑色圆点就是Node对象。</p><h3 id="功能实现简介"><a href="#功能实现简介" class="headerlink" title="功能实现简介"></a>功能实现简介</h3><blockquote><p>确定Hash桶数组的位置</p></blockquote><p>不管是增加元素，删除和查找键值对，定位到Hash桶数组的位置都是关键的一步，当我们用Hash算法求得元素对应的位置时候，马上就可以知道对应元素的位置是我们想要的，而不用去遍历链表大大优化了查询速度。对应源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的hash算法本质上就三步，key的hashcode值、高位运算和取模运算。下面举例说明，n为table的长度。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/确定桶数组的位置1.png" alt="image-w100"></p><p>上述的计算步骤可以简化理解为要查询下图结构是否包含35元素,首先定位到35所处的桶的位置，index = 35 % 16 = 3。在3号桶所指的链表继续查找，发现35在链表中</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/确定桶数组的位置2.png" alt="image-w100"></p><blockquote><p>分析HashMap的put方法</p></blockquote><p>HashMap的执行过程可以简化为如下所示：</p><ol><li>判断桶数组table[i]是否为空或者null,如果数组为空则进行扩容操作。</li><li>根据key值计算hash值来得到桶数组索引i,如果table[i] == null,直接执行第6步骤，否则执行第3步骤。</li><li>判断table[i]的元素是否key相同，如果相同则直接覆盖，这里相同指的是hashcode和equals相同，否则直接执行步骤4</li><li>判断table[i]是否为treeNode,即是否为红黑树，如果是红黑树，直接插入，否则执行步骤5</li><li>判断table[i],判断链表长度是否大于8，大于8则把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的操作。遍历过程中发现key存在直接覆盖value即可。</li><li>插入成功后，会判断是否需要扩容。默认的负载因子为0.75，也就是说如果插入的元素超过桶数组中75%时，就会将原来的桶数组扩容至现在的两倍。并将原来的对象插入到新的数组中。</li></ol><p>Hash碰撞处理：</p><p>根据Key进行插入或者获取元素时，首先会根据Key值调用hashcode()方法，如果得到相同的hashcode时，会调用equals()方法，如果key相同时，插入直接覆盖，如果不同时，插入链表的下一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩容机制</p></blockquote><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。鉴于JDK1.8中使用红黑树，较复杂，为了理解使用JDK1.7源码进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JDK1.7扩容时可能形成环，这是因为插入的数据会插入到头节点中。JDK优化将数据插入到末尾<br><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/HashMap扩容形成环.png" alt="image-w100"></p><p>JDK1.8扩容代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HashMap的有序性问题"><a href="#HashMap的有序性问题" class="headerlink" title="HashMap的有序性问题"></a>HashMap的有序性问题</h3><blockquote><p>说明</p></blockquote><p>在HashMap中，是将key作hash算法，然后将hash值映射到内存地址中，直接取的key所对应的数据。在HashMap中，底层数据结构采用的是数组，所谓的内存地址是数组的下标索引。HashMap功能的缺点是无序的，即存入HashMap的元素与其遍历的结果不一致，如果希望HashMap是有序的，可以使用LinkedHashMap.LinkedHashMap继承自HashMap,具有高效性，同时在HashMap的基础上，添加了链表的head 和 tail 两个节点，从而变成了按照插入顺序的双向循环链表。<br>HashMap通过Hash算法可以尽快的进行put()和get()操作,TreeMap则提供了一种完全不同的Map实现，从功能上讲，TreeMap比HashMap提供了更为强大的功能，它实现了 SortedMap 接口，这意味着它可以对元素进行排序。TreeMap的性能略微低于 HashMap。如果在开发中需要对元素进行排序，那么使用HashMap便无法实现这种功能，使用 TreeMap 的迭代输出将会以元素顺序进行。LinkedHashMap是基于元素进入集合的顺序或者被访问的先后顺序排序，TreeMap 则是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。</p><blockquote><p>源码分析</p></blockquote><p>对于HashMap的遍历，一般我们会采用下面两种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object key : map.keySet()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(HashMap.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看出，一般都是对HashMap的key集合或者Entry集合进行遍历。多次遍历的结果顺序都是一致的，但是与插入的顺序是不一致的。其对应HashMap集合源码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry </span></span><br><span class="line">            <span class="comment">// 寻找第一个包含链表节点引用的桶</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 寻找下一个包含链表节点引用的桶</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面代码所示，遍历所有的键时，首先要获取KeySet对象，然后再通过keySet的迭代器keyIterator进行遍历，keyIterator继承hashIterator类，核心逻辑也封装在HashIterator类中，HashIterator的逻辑并不复杂，在初始化时HashIterator先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行链表。遍历完成后。再继续寻找下一个包含链表节点引用的桶，找到则继续遍历，找不到则结束遍历。其遍历过程如下所示：<br><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/HashMap遍历.png" alt="image-w100"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap是一种以Key,value存在的经典数据结构，也是在开发过程中比较常用的数据结构，本篇博客主要是结合源码进行分析理解。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://qiutiangang123.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://qiutiangang123.github.io/tags/Java/"/>
    
      <category term="collection" scheme="https://qiutiangang123.github.io/tags/collection/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://qiutiangang123.github.io/2018/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://qiutiangang123.github.io/2018/06/29/设计模式/单例模式/</id>
    <published>2018-06-29T08:20:07.000Z</published>
    <updated>2019-02-11T03:33:44.273Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是一套被反复使用、多人知晓的，经过分类编目的，代码设计经验总结。<br><a id="more"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>java中单例模式是一种常见的设计模式，单例模式有以下几种特点：</p><ol><li>单例类中只能有一个实例（对象全局唯一），可以使用的单例模式都有一个的类都有一个共性，那就是这个类没有状态，换句话说，这个类无论实例化多少个，都是一样的。</li><li>单例类中只能自己创建自己唯一的实例</li><li>单例类必须给其他所有的对象提供这一实例</li></ol><p>单例模式可以分为懒汉式和饿汉式</p><ol><li>懒汉式单例模式：在类加载时不初始化</li><li>饿汉式单例模式：在类加载时完成初始化，所以类加载比较慢，但是获取对象的速度快。</li></ol><p>我们是通过以下几个方式去保证我们取到的实例是唯一的：</p><p>1：静态实例，带有static关键字的属性在每一个类都是唯一的。</p><p>2：私有化构造方法，此为保证单例中最重要一步。</p><h3 id="懒汉式单例模式（线程不安全）"><a href="#懒汉式单例模式（线程不安全）" class="headerlink" title="懒汉式单例模式（线程不安全）"></a>懒汉式单例模式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式单例模式（线程安全）"><a href="#懒汉式单例模式（线程安全）" class="headerlink" title="懒汉式单例模式（线程安全）"></a>懒汉式单例模式（线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>静态内部类加载单例模式时候跟其他方式有所不同，其他方式只要类被加载时，那么instance就会被实例化，而使用静态内部类单例模式时，虽然类被装载了，instance不一定被初始化。因为SingletionHolder类没有主动被使用，只有通过getInstance方法时，才会显示SingletionHolder类，从而实例化instance。如果实例化instance很消耗资源，让他延迟加载，另一方面，不希望Instance在类加载时就被实例化，因为不能确保Singletion类还可能在其他方面被主动使用而被加载，那么这个时候实例化instance是不合适的。这个时候显然使用静态内部类单例模式会显得更加合理一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton () &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singletion instance = new Singleton(); </span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance () &#123;</span><br><span class="line">        return SingletonHolder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式是一套被反复使用、多人知晓的，经过分类编目的，代码设计经验总结。&lt;br&gt;
    
    </summary>
    
      <category term="design" scheme="https://qiutiangang123.github.io/categories/design/"/>
    
    
      <category term="design pattern" scheme="https://qiutiangang123.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://qiutiangang123.github.io/2018/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://qiutiangang123.github.io/2018/06/28/设计模式/代理模式/</id>
    <published>2018-06-28T08:20:07.000Z</published>
    <updated>2019-02-11T06:11:32.356Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是为其他对象提供一种代理以控制对这个对象的访问。代理模式分为两种，可以分为两种，一种是静态代理，另外一种是动态代理。<br><a id="more"></a><br>两种代理模式本质都是相同的，都是从原有类的行为基础上，加入多出的行为，甚至替换原有的东西，产生一个新的与原有类接口相同却行为不同的类型。</p><p>静态代理有如下几个特点：</p><ol><li>代理类持有一个被代理类的对象的引用。</li><li>对于不关心的方法，一般全部交给被代理类对象处理。</li><li>在代理类中处理我们关心的方法。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>一般来说数据库连接是一种珍贵资源，频繁的创建、销毁连接是一种浪费系统CPU以及内存，一般使用数据库连接池来解决这个问题。创建固定的连接等待被使用，使用完毕放回到连接池中。数据库在整个应用启动期间，几乎是不关闭的。</p><p>但是在编写程序时，会调用connection.close()方法去关闭数据库连接，这样做是对的，并不能告诉程序员们说，你们使用连接都不要关了，去调用一个其他的类似归还给连接池的方法吧。这不符合程序员的编程思维的，也很勉强，而且具有风险性，因为程序员会忘的。</p><p>Connection方法（去掉很多方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Wrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span>  <span class="keyword">extends</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>connection代理类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConnectionProxy implements Connection&#123;</span><br><span class="line">    </span><br><span class="line">    private Connection connection;</span><br><span class="line">    </span><br><span class="line">    public ConnectionProxy(Connection connection) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Statement createStatement() throws SQLException&#123;</span><br><span class="line">        return connection.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void close() throws SQLException&#123;</span><br><span class="line">        System.out.println(&quot;不真正关闭连接，归还给连接池&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数据库连接池<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;Connection&gt; connectionList = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">createNewConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(<span class="string">"url"</span>, <span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connectionList == <span class="keyword">null</span> || connectionList.size() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        connectionList.add(createNewConnection());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConnectionProxy <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connectionList.size() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">//return connectionList.remove();  这是原有的方式，直接返回连接，这样可能会被程序员把连接给关闭掉</span></span><br><span class="line">      <span class="comment">//下面是使用代理的方式，程序员再调用close时，就会归还到连接池</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConnectionProxy(connectionList.remove());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点：可以在不修改目标类的前提下，对目标类进行修改。</p><p>缺点：代理类需要与目标类实现同一接口，所以会有很多代理类，类太多，并且，一旦接口增加方法，目标类与代理类都需要维护，增加了维护成本。</p><p>并且静态代理一定是要目标类存在的前提下，但是实际项目中编译之前有可能不知道要代理哪个，这就由动态代理来解决了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式是为其他对象提供一种代理以控制对这个对象的访问。代理模式分为两种，可以分为两种，一种是静态代理，另外一种是动态代理。&lt;br&gt;
    
    </summary>
    
      <category term="design" scheme="https://qiutiangang123.github.io/categories/design/"/>
    
    
      <category term="design pattern" scheme="https://qiutiangang123.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>微服务基本原理</title>
    <link href="https://qiutiangang123.github.io/2018/06/22/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://qiutiangang123.github.io/2018/06/22/分布式/微服务基本原理/</id>
    <published>2018-06-22T07:55:07.000Z</published>
    <updated>2019-05-06T08:04:25.686Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要介绍微服务基本原理。参考博客<a href="https://mp.weixin.qq.com/s/mOk0KuEWQUiugyRA3-FXwg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mOk0KuEWQUiugyRA3-FXwg</a><br><a id="more"></a></p><h2 id="微服务简介"><a href="#微服务简介" class="headerlink" title="微服务简介"></a>微服务简介</h2><p>微服务就是一种架构风格，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务运行在独立进程中，服务间采用轻量级的通信机制协作（通常采用HTTP/JSON），每个服务都能独立部署，独立维护，独立扩展，服务与服务之间通过诸如Restful API等方式相互调用。</p><h2 id="使用场景描述"><a href="#使用场景描述" class="headerlink" title="使用场景描述"></a>使用场景描述</h2><p>在电商网站用户下单场景中，首先订单服务会与财务系统发生数据交互，对财务系统返回的结果进行判断，如果下单成功，更新本地数据库订单支付状态。调用库存服务，相应的商品数量较少一个。然后通知仓储服务，通知进行发货操作，最后更新用户服务中用户的积分。如下图所示。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/用户下单场景图.jpg" alt="image-w100"></p><h2 id="微服务组件介绍"><a href="#微服务组件介绍" class="headerlink" title="微服务组件介绍"></a>微服务组件介绍</h2><p>根据上述简单业务场景介绍，大致可以看到订单服务，库存服务，仓储服务与用户服务之间的调用关系，在微服务中主要通过各个组件来实现其功能。下面重点介绍微服务中常见的组件</p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>订单服务想要调用其他服务时，首先要知道其他服务的地址才可以进行发送请求，这时就需要Eureka来协助完成。Eureka是微服务的注册中心，专门负责服务的注册与发现。Eureka Service里有一张注册表，当服务启动时，会将服务的IP地址和端口号保存到注册表中。每个服务会把Eureka service中的注册表缓存到本地中。这样就可以进行服务之间的调用。</p><p>总结一下：</p><ul><li>Eureka client：负责将这个服务的信息注册到Eureka Service中。同时会将Eureka Service中注册表缓存到本地中。</li><li>Eureka Service：注册中心，里面有注册表，保存了各个服务的IP地址和端口号。</li></ul><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>订单服务知道其他服务的IP地址和端口号，需要与其他系统进行网络连接，然后构造复杂的请求，发送请求，解析其他服务返回的结构。这时，可以用Feign组件来完成。Feign组件的关键是使用动态代理完成。首先，如果你对某个接口定义了@FeignClient这个注解，Feign就会针对这个接口创建一个动态代理，Feign的动态代理会根据你在接口上的@RequestMapping(“”)来动态构造你要请求的地址。最后针对这个地址来发起请求，解析响应。</p><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>假设库存服务部署在多台机器上，此时Feign是不知道究竟请求哪台机器上的服务。Ribbon就是解决这个问题的，它的作用是负载均衡，每次请求时选择一台机器，均匀的把请求分布到各个机器上。</p><p>Ribbon负载均衡默认使用最经典的Round Ribbon轮询算法，这个算法的大概意思是假设有库存服务部署在五台机器上，现在有10次请求，会先将你的请求分配在第一台机器，第二台机器上，第三台机器上第四台机器上，第五台机器上。然后再来依次轮询。</p><p>此外，Ribbon是和Feign以及Eureka紧密协作完成工作的。具体如下：</p><ul><li>首先Ribbon会从Eureka Service获取对应的服务注册表，也就是知道了所有的机器都部署在哪台机器上，在监听哪些端口号。</li><li>然后Ribbon就可以使用默认的Ribbon Round算法，从中选择一台机器。</li><li>Feign就会根据这台机器，进行构建链接，发起请求。</li></ul><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/Ribbon使用情景图.jpg" alt="image-w100"></p><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>在微服务架构里，一个系统会有很多服务。以上述场景为例，在一个业务逻辑中，订单服务需要调用四个服务，假设订单服务最多可以同时支持100个线程。在调用用户服务时用户服务挂了，此时执行这个逻辑就会卡住几秒钟，最后会抛出超时异常。在高并发的情况下，订单服务的100个线程都会卡在用户服务这块，导致订单服务没有其他的线程处理请求。然后就会导致其他系统请求订单系统时，发现订单服务也挂了，不响应任何请求。</p><p>上面这个就是微服务架构中恐怖的雪崩问题。某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p><p>可以使用微服务中Hystrix，Hystrix是隔离、熔断以及降级的一个框架。假设某个系统挂了，就不去请求这个服务，而是走本地的一个方法。这个过程就是熔断，服务降级。</p><h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p>Zuul是负责网络路由的。举个简单的例子，加入在后台部署了几百个服务，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p><p>而且有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/微服务架构图.jpg" alt="image-w100"></p><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><p>Eureka2.x注册中心停止迭代维护，并且Eureka是不能保证数据的一致性（当注册一个服务时，其他服务根本发现不了，或者很长时间才能发现）。这时可以使用Consul组件作为微服务的注册中心。如果使用Consul作为注册中心，必须在每一个服务所在的机器上部署一个Consul Agent。作为一个服务所在的机器代理。然后还要在多台机器上部署Consul Server。这就是核心的注册中心。</p><p>Consul Agent会发送每个服务的信息到Consul Server，还会对服务发送请求判断是否健康。集中式心跳管理比如Eureka。是让各个服务每隔一段时间发送心跳到Eureka Server。如果一段时间没有接受到请求，那么就认为这台机器宕机。使用集中式心跳管理会对Eureka Server造成很大的压力。实际上平时Eureka Server接受到最多的请求就是各个服务的请求。所以Consul Agent对集中式心跳管理进行优化，引入了Consul Agent。每个机器上的Consul Agent会对服务不断的发送请求判断是否宕机，如果服务宕机则发送请求到Consul Server。这样可以减少Consul Server的服务压力。</p><p>如果要发现其他服务。Consul Agent也会转发请求到Consul Server，查询其他服务所在的机器信息。Consul Server一般要求部署三到五台，以保证高可用和以及数据的一致性。他们之间会自动实现数据同步。而且Consul Server会自动选举出一台机器作为leader，其他为follower。各个服务发送给Leader，由Leader同步给follower。如果库存服务注册时，那么Leader一定有注册信息。其他服务发现库存服务，会先请求Leader Server。服务的注册和发现都是通过Leader Server来完成，保证数据的强一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要介绍微服务基本原理。参考博客&lt;a href=&quot;https://mp.weixin.qq.com/s/mOk0KuEWQUiugyRA3-FXwg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/mOk0KuEWQUiugyRA3-FXwg&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Distributed" scheme="https://qiutiangang123.github.io/categories/Distributed/"/>
    
    
      <category term="Java" scheme="https://qiutiangang123.github.io/tags/Java/"/>
    
      <category term="distributed" scheme="https://qiutiangang123.github.io/tags/distributed/"/>
    
      <category term="Microservice" scheme="https://qiutiangang123.github.io/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>JVM简介</title>
    <link href="https://qiutiangang123.github.io/2018/04/24/Java/JVM%E7%AE%80%E4%BB%8B/"/>
    <id>https://qiutiangang123.github.io/2018/04/24/Java/JVM简介/</id>
    <published>2018-04-24T03:17:06.000Z</published>
    <updated>2019-05-27T12:40:29.693Z</updated>
    
    <content type="html"><![CDATA[<p>JVM主要实现两个功能，分别是<strong>软件层面的机器码翻译和内存管理</strong>，这个功能主要是帮助Jav实现Write Once Run Everywhere。<a id="more"></a>首先JDK会将程序编译为.class文件。然后JVM加载class文件将其编译成机器可识别的0、1状态码。内存管理主要可以使编程者专注于业务代码的实现，而不必关心垃圾回收的问题。</p><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><blockquote><p>Java是由JVM自动管理内存，负责垃圾回收，进行对象的销毁，下面是运行时数据区域：</p></blockquote><ul><li>程序计数器：存放当前线程执行字节码指令地址（行号）。当线程进行上下文切换时需要记录被挂起线程执行的位置。</li><li>虚拟机栈/本地方法栈：本地方法栈与虚拟机栈的作用是类似的，他们的区别是虚拟机栈执行为虚拟机执行Java方法，而本地方法栈则为虚拟机使用到的Native方法服务（Native是指调用Java方法调用非Java代码的接口的代码）。虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行时都会创建一个帧栈，用于存储局部变量表、操作数栈、动态链接、方法等信息。栈的存储速度比堆的存储速度更快一点，栈的存储速度仅次于计算机的寄存器。栈的大小是确定的。对象的引用是存在栈中，对象的本身是存在堆中的。</li><li>堆：存放对象实例。可以处于物理上不连续的内存空间，只要逻辑上连续就可以。每次动态进行分配内存，由于是每次运行时进行动态内存分配，所以存储速度比较慢。</li><li>方法区：用于存储已被虚拟机加载的类信息，常量，静态变量，及时编译的代码等数据。</li></ul><p>方法区和堆是线程共享的，程序计数器和虚拟机栈/本地方法栈是线程私有的。</p><p>Java堆分为新生代和老年代。新生代：所有的新生对象放到新生代，新生代分为三个区，一个伊甸园区（Eden）,两个幸存者（survivor）,新的对象先进入到Eden区，Eden区满了之后还存活的对象会放到其中一个survivor区，满了之后仍然存活的对象会进入到第二个survivor区。第二个survivor区满了之后还存活的对象会进入到老年代，会始终保持有一个survivor区是空的。</p><p>有关Java堆的参数设置:</p><p>-Xms20M(start)堆的起始大小</p><p>-Xmx(max) 堆的最大大小</p><p>-Xmn(new) 堆的新生代大小</p><p>老年代：经过多次新生代GC幸存的对象会被放到老年代。大对象直接进入到老年代。</p><h3 id="对象在堆空间中分配的流程"><a href="#对象在堆空间中分配的流程" class="headerlink" title="对象在堆空间中分配的流程"></a>对象在堆空间中分配的流程</h3><p>Java堆分为新生代和老年代。新生代：所有的新生对象放到新生代，新生代分为三个区，一个伊甸园区（Eden）,两个幸存者（survivor）,新的对象先进入到Eden区，Eden区满了之后还存活的对象会放到其中一个survivor区，满了之后仍然存活的对象会进入到第二个survivor区。第二个survivor区满了之后还存活的对象会进入到老年代，会始终保持有一个survivor区是空的。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/堆空间结构图.png" alt="image-w100"></p><p>新对象在堆空间分配流程：</p><ol><li>当产生一个新对象时，首先会判断Eden区是否有足够的内存，如果有足够的内存，直接将对象分配到堆内存中。如果Eden区内存不足则进入下一流程。</li><li>当Eden区不足时会进行一次Minor GC操作，将没有存活的对象清除掉，然后继续判断是否有足够的内存空间，如果存在足够的内存空间，则将对象之间分配到Eden区。如果内存空间不足则进入下一流程。</li><li>如果Minor GC之后Eden区的内存依然不足，会判断survivor区是否有足够的内存空间，如果survivor中有足够的内存空间，则将Eden区存活的对象分配在Survivor区，然后继续判断Eden区是否有足够的内存空间，如果Eden区有足够的内存空间，则将对象直接分配到Eden区。如果Survivor区的内存空间不足时，则进入下一个流程。</li><li>当Survivor区内存空间不足时，则将Survivor内存空间分配到老年代中，然后将Eden区中存活的对象分配到Survivor中，最后判断Eden区是否有足够的内存空间分配新对象，如果此时还没有足够的内存空间分配对象，则根据大对象直接分配在老年代中，继续判断老年代是够有足够的空间分配对象。</li><li>当老年代中没有足够的空间，则进行Full GC。</li></ol><h3 id="判断对象是否可以被回收"><a href="#判断对象是否可以被回收" class="headerlink" title="判断对象是否可以被回收"></a>判断对象是否可以被回收</h3><p>判断对象是否存活的两种算法：引用计数算法和可达性分析算法。</p><p>引用计数算法就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，表示对象可以被回收，其缺点是很难解决对象之间相互引用问题。</p><p>可达性分析算法基本的思路就是通过一系列名为“GC Roots”对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>其中GC Roots包括虚拟机栈中的引用对象，方法区中静态变量所引用的对象，本地方法栈中JNI(一般说的Native方法)引用的对象。</p><p>四种引用类型：强引用、软引用、弱引用和虚引用。</p><h3 id="垃圾收集算法："><a href="#垃圾收集算法：" class="headerlink" title="垃圾收集算法："></a>垃圾收集算法：</h3><ol><li>标记-清除算法：首先标记出所有需要回收的对象，在标记完后统一回收被标记的对象，这个过程中会有两个步骤：标记和清除，其效率不高并且会产生大量碎片。</li><li>复制回收算法：将内存划分为相同的两块，每次只使用一块，将存活的对象复制到另一块。其缺点是空间利用率不高。</li><li>标记整理算法：对象存活率较高时使用复制算法其效率会变低，让所有存活的对象都向一端移动，直接清理掉边界以外的内存。先标记，然后修改用用地址到碎片的过程，然后修复碎片</li><li>分代收集算法：将对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，新生代中，每次垃圾收集时都会有大批的对象死去，只有少量的存活，选择复制算法，只要复制少量存活对象的复制文本就可以完成收集，而老年代中因为对象的存活率高，没有额外的空间对它进行分配就必须用标记-清理或者标记-整理算法进行回收。</li></ol><h3 id="GC垃圾回收器"><a href="#GC垃圾回收器" class="headerlink" title="GC垃圾回收器"></a>GC垃圾回收器</h3><p>JVM提供的收集器较多，特征不一，适用于不同的业务场景：</p><blockquote><p>serial 收集器</p></blockquote><p>最古老的垃圾单线程收集器，进行垃圾收集时必须暂停其他线程，一般作用于clent端。serial 收集器作用与新生代，采用复制算法，serial-old 收集器作用于老年代，采用标记整理算法。</p><blockquote><p>parnew 收集器</p></blockquote><p>parnew 收集器是serial收集器的多线程的版本。与serial收集器相同，进行垃圾回收时必须暂停其他线程工作。新生代采用复制算法，老年代（parnew old）采用标记整理算法。<br>它是运行在server模式下首选的新生代收集器，除了serial收集器外，目前只有它能配合CMS收集器工作。</p><blockquote><p>parallel scavenges 收集器</p></blockquote><p>parallel scavenge收集器是一个新生代的收集器，它也是使用复制算法的收集器，又是并行的多线程的收集器。主要注重吞吐量</p><blockquote><p>cms 收集器</p></blockquote><p>CMS(Concurrent mark sweep) 是一种以标记清除算法实现作用于老年代的收集器，是第一次让垃圾收集线程与工作线程同时工作的。</p><blockquote><p>G1收集器</p></blockquote><p>G1(Garbage-first) 与其他GC收集器相比，G1具备如下特点</p><p>1：并行与并发：G1能充分利用充分利用多CPU的硬件环境。使用多个CUP来缩短stop-the-world时间。</p><p>2：分代收集：G1不需要其他收集器的配合完成分代收集</p><p>3：空间整合：与CMS 收集器采用标记-清除算法不同，G1收集器采用标记整理算法。</p><h3 id="JVM内存溢出情况整理"><a href="#JVM内存溢出情况整理" class="headerlink" title="JVM内存溢出情况整理"></a>JVM内存溢出情况整理</h3><blockquote><p>Java堆内存溢出情况</p></blockquote><p>Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制回收对象，那么在对象达到最大堆容量限制之后就会产生内存溢出异常。当出现Java堆内存溢出，异常堆栈信息’Java.lang.OutOfMemoryError’会跟着进一步提示”Java heap space”,要解决这个区域的异常，一般会先通过内存映象分析工具对Dump出来的对转存储快照进行分析，重点是确认内存中的对象是否是必要的，也就是先区分到底是内存泄露还是内存溢出。如果是内存泄露，可进一步通过工具来进行查看泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎样的路径与GC Roots相关导致垃圾回收器无法回收它们，如果不存在泄露，就是内存中的对象是存活的，那就应当检查虚拟机的堆参数与机器物理内存对比是否可以调大，并且从代码上检查某些对象存在的生命周期是否过长。</p><blockquote><p>虚拟机栈和本地方法栈溢出</p></blockquote><p>如果线程请求的栈深度大于虚拟机锁允许的最大深度，将会抛出StackOverflowError,如果虚拟机在扩展栈时没有足够的内存空间，则会抛出OutOfMemoryError。以上两种情况其实是对同一件事情的描述，当栈空间无法继续分配时，到底是栈内存空间太小还是已经使用的栈内存空间太大。在单线程的情况下，无论是帧栈太大还是虚拟机栈太小，当内存无法分配时，则会抛出StackOverFlowError异常。如果通过建立多线程的方式导致的内存溢出，在不能减少线程或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少帧栈容量来换取更多线程。</p><blockquote><p>方法区和运行时常量池溢出</p></blockquote><p>若是运行时常量池溢出，在OutOfMemoryErro后面跟随的提示信息是’PermGen Space’,说明运行时常量池属于方法区(永久代)的一部分。方法区用于存放calss类的相关信息，比如类名，访问权限，常量池，方法描述，若运行时产生大量的类去填充方法区，直达溢出。比如Spring对类进行增强时（创建代理类），都会使用到cglib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载到内存。再比如大量JSP或动态产生JSP文件应用（JSP第一次运行时需要编译为Java类）等。</p><h3 id="jvm加载类的过程"><a href="#jvm加载类的过程" class="headerlink" title="jvm加载类的过程"></a>jvm加载类的过程</h3><p>从源文件的生成到程序的运行，Java程序要经过两个步骤：编译和运行。源文件由编译器编译成字节码，字节码由Java虚拟机解释运行。</p><p>编译：创建完源文件之后，程序会被编译器编译为.class文件。Java编译一个类时,如果这个类所依赖的类没有被编译，编译器会先编译这个被依赖的类，然后引用，否则直接引用。编译后的字节码格式主要是两部分，常量池和方法字节码。</p><p>常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等，而符号引用主要包括了三类常量：类和接口的全限定名，字段的名称和描述符。方法的名称和描述符。</p><p>运行：Java类的运行大概分为两部分，类的加载和执行。类的加载是通过加载器将字节码（*.class）加载到jvm内存中。类从被加载到内存开始，到卸载出内存为止，共有七个阶段，加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备和解析三个部分统称为连接。</p><blockquote><p>类加载器</p></blockquote><p>类加载器虽然只是用于实现类的加载动作，但在Java程序中起到的作用远远不限于类的加载阶段，对于任何一个类，都需要由加载它的类加载器和这个类本身一同确定在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否相等，只有这个类是由同一个类加载器加载的前提才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类必定不相等。共有四种类加载器：启动类加载器，扩展类加载器，应用程序类加载器和自定义类加载器。</p><ol><li>启动类加载器：它的作用是将JAVA_HOME/lib目录下的类加载到内存中。需要注意的是由于启动类加载器涉及到虚拟机本地的实现细节，开发人员无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</li><li>扩展类加载器：它是由Sun的ExtClassLoader实现的，它的作用是将JAVA_HOME/lib/ext目录下或由系统变量Java.ext.dir指定位置中的类加载到内存中，它可以由开发人员直接使用。</li><li>应用程序类加载器：它是由Sun的AppClassLoader实现的，它的作用是将classpath路径下指定的类加载到内存中。它也可以由开发人员使用。</li><li>自定义加载器：自定义的类加载器继承自ClassLoader，并覆盖findClass方法，它的作用是将特殊用途的类加载到内存中。</li></ol><blockquote><p>双亲委派模型：</p></blockquote><p>所谓的类加载器的双亲委派模型指的是类加载器的层级关系。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这种组合关系来实现，而不是通过继承来实现。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/classLoader.png" alt="image-w100"></p><p>启动类加载器：启动类加载器将存放在&lt;JAVA_HOME&gt;\lib的目录中的类库加载到虚拟机内存中，启动类加载器无法被Java程序直接引用</p><p>扩展类加载器：负责加载&lt;JAVA_HOME&gt;\lib\exe目录中，开发者可以直接使用扩展类加载器</p><p>应用程序类加载器: 一般称为系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序没有定义过自己的类加载器，一般情况下这个就是程序的默认的类加载器。</p><p>某一个类加载器请求加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，则返回成功，如果父类加载器无法完成加载任务，将抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载，依次类推。</p><p>使用双亲委派模型的好处：即防止内存中出现多份相同的字节码。</p><p>反向思考这个问题，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写一个Java.lang.Object的同名类并放在ClassPath中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的Object类，那么类之间的比较结果及类的唯一性将无法保证，而且如果不适用这种双亲委派模型将会给虚拟机的安全带来隐患。所以，要让类对象进行比较有意义，前提是他们要被同一个类加载器加载。</p><blockquote><p>破坏双亲委派机制：</p></blockquote><p>上文提到的双亲委派模型并不是强制性的模型，而是Java设计者推荐给开发者的类加载的实现方式，在Java的世界里，绝大部分的类加载器都遵循这个规律，但是会有破坏双亲委派模型的情况：<br>线程上下文类加载器，这个类加载器可以通过Java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那么类加载器就是应用程序类，像JDBC就采用了这种方式。这种方式就是逆向使用了加载器，违背了一般性原则。</p><h3 id="保证线程可见的三种方法："><a href="#保证线程可见的三种方法：" class="headerlink" title="保证线程可见的三种方法："></a>保证线程可见的三种方法：</h3><ol><li>使用volatile关键字</li><li>使用synchronized关键字</li><li>使用final关键字（一旦初始化完成其他线程就可见）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM主要实现两个功能，分别是&lt;strong&gt;软件层面的机器码翻译和内存管理&lt;/strong&gt;，这个功能主要是帮助Jav实现Write Once Run Everywhere。
    
    </summary>
    
      <category term="Java" scheme="https://qiutiangang123.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://qiutiangang123.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://qiutiangang123.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>网络编程基础知识</title>
    <link href="https://qiutiangang123.github.io/2018/03/31/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://qiutiangang123.github.io/2018/03/31/网络编程/网络编程/</id>
    <published>2018-03-31T07:55:07.000Z</published>
    <updated>2019-06-04T03:12:37.484Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程的一些基础概念介绍<br><a id="more"></a></p><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><p>第一层：物理层。这一层主要就是传输这些二进制数据。</p><p>第二层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输。</p><p>第三层：网络层。定义网络设备间如何传输数据。</p><p>第四层：传输层。管理着网络中端到端的数据传输。</p><p>第五层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断。</p><p>第六层：表示层。定义了不同系统的数据传输格式，编码和解码规范等。</p><p>第七层：应用层。定义了用于在网络中进行通信和传输数据的接口。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP/IP 是传输层的协议，使用三次握手和四次挥手提供一种面向链接，可靠的字节流服务。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/三次握手四次挥手.png" alt="image-w100"></p><h3 id="TCP内存模型"><a href="#TCP内存模型" class="headerlink" title="TCP内存模型"></a>TCP内存模型</h3><p>一个TCP连接由四个元组构成，分别是两个IP地址和两个端口号。一个TCP连接通长分为三个阶段：启动、数据传输、退出。</p><p>当一个TCP接收到另一端的数据时，它会发送一个确认，这个确认不会立即发送，一般会延迟一会。ACK是累积的，一个确认字节号N的ACK表示直到N（不包含N）已经被成功接收了。这样的好处是一个ACk丢失，后面的ACK就足以确认前面的报文。</p><p>一个完整的TCP连接是双向对称的。数据可以在两个方向平等的流动。给上次应用程序提供一种双服务，一旦建立连接，这个连接的一个方向的每个TCP报文段包含相反方向的报文段的ACK。</p><p>ACK —— 确认，使得确认号有效。</p><p>RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。</p><p>SYN —— 用于初如化一个连接的序列号。</p><p>FIN —— 该报文段的发送方已经结束向对方发送数据。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手的作用就是为了向对方证明自己的发送、接受数据是没有问题的。</p><p>第一次握手：客户端发送带有SYN标志的数据包到服务端，如果服务端接收到数据包，则服务端得出结论：客户端的发送能力和服务端的接受能力是没有问题的。</p><p>第二次握手：服务端发送带有SYN/ACK标志的数据包到服务端。如果客户端接受到该数据包，则客户端得出结论：客户端、服务端的发送接受能力是没有问题的。</p><p>第三次握手：客户端发送带有ACK标志的数据包到服务端。如果服务端接受到哦数据包。则服务端得出结论：客户端、服务端的发送接受能力是没有问题的。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>TCP的连接是双向传输的对等模式，双方都可以向对方发送接受数据，当有一方要关闭连接时，会发送指令告诉对方，我要关闭连接。这时对方会回ACK，此时，一个连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完所有的数据，会发送一个FIN段来关闭此方向的连接。接受方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK，它是无法马上回复对方一个FIN报文段的，因为结束数据运输的指令是上层应用层所决定的。</p><ul><li>客户端-发送一个FIN,用来关闭客户端到服务端的数据传送。</li><li>服务端-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号，</li><li>服务端-关闭与客户端的连接，发送一个FIN给客户端。</li><li>客户端-发回ACK报文确认，并将确认序号设置为收到序号加10.0</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP协议是建立在TCP协议基础之上的，当浏览器需要从网页上获取网页数据的时候，会发出一次HTTP请求，HTTP会通过TCP建立起一个服务器的连接通道，当本次请求需要的数据完毕后，HTTP会立即将TCP链接断开，这个过程很短，HTTP是一种短连接，无状态的连接。所谓无状态连接，是指每次请求服务器都会通过一个新的连接来进行请求，连接结束之后，相关内容就会释放，不会记录任何状态，所以是无状态连接。</p><h3 id="一次完整的HTTP请求过程"><a href="#一次完整的HTTP请求过程" class="headerlink" title="一次完整的HTTP请求过程"></a>一次完整的HTTP请求过程</h3><p>DNS域名解析 –&gt; 发起TCP三次握手 –&gt; 建立TCP连接后发起HTTP请求 –&gt; 服务器响应HTTP请求，得到相应的数据 –&gt; 浏览器解析请求，渲染视图等操作。</p><h3 id="HTTP的长连接和短连接"><a href="#HTTP的长连接和短连接" class="headerlink" title="HTTP的长连接和短连接"></a>HTTP的长连接和短连接</h3><p>HTTP的长连接和短连接本质上是属于TCP的长连接和短连接。其中HTTP是属于应用层的传输协议，TCP是属于传输层的协议，而IP是网络层的协议。IP协议主要解决网络路由和寻址的问题。TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p><p>在HTTP/1.0中默认使用短连接。也就是说客户端和服务器之间每进行一次HTTP请求，就建立一次连接，任务结束就中断连接。而从HTTP/1.1起，默认使用长连接。使用长连接的HTTP协议，会在响应头加下面这行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器端的HTTP协议不会断开（底层的TCP连接不会关闭），客户端再次访问这个服务器时，会继续使用这个连接。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS协议是由SSL + HTTP构建的加密传输、身份认证的网络协议，比HTTP协议更加安全。一般HTTPS协议需要到CA上进行申请证书，一般免费证书较少，需要一定费用。</p><h4 id="安全传输"><a href="#安全传输" class="headerlink" title="安全传输"></a>安全传输</h4><p>正常客户端和服务单的通信如下图所示，这种传输不是安全传输，因为如果第三方劫持消息的话，B就接受不到A的消息。安全传输一句话描述就是对于A向B发送消息，只有A和B两个节点能够知道。</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/sendMessage.jpg" alt="image-w100"></p><p>进行安全传输的话，可以服务单和客户端进行加密解密，也就是对称传输，但是如果一个服务端有很多个客户端的话，无异于没有加密。也是不安全的传输。</p><p>针对上述问题，可以使用HTTPS进行公钥和私钥先进行非对称加密，再进行对称加密来完成安全传输。如下图所示，私钥可以被公钥所解密，但是公钥只有私钥可以解密，私钥属于服务端，公钥属于客户端。具体过程如下所示：</p><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/https_trans.jpg" alt="image-w100"></p><blockquote><p>客户端在使用HTTPS协议与HTTP进行通信时有如下几个步骤(原理)：</p></blockquote><ol><li>客户端发起HTTS请求，并且生成一个随机数（第一个随机数）传送给服务端</li><li>服务端接收到随机数，也会产生一个随机数（第二个随机数），并将随机数和证书（颁发机构（CA）、证书内容本身的数字签名（使用第三方机构的私钥加密）、证书持有者的公钥、证书签名用到的hash算法）返回给客户端。</li><li>客户端会接受到证书做验证（根据颁发机构找到本地的根证书，根据CA得到根证书的公钥，通过公钥对数字签名进行解密，得到证书的内容摘要A。用证书提供的算法对证书的内容进行摘要，得到摘要B，通过A和B进行对比，也就是验证数字签名）。</li><li>通过验证后会产生一个随机数（第三个随机数）发送给客户端，通过公钥对随机数进行加密发送给服务端</li><li>（随机数1 + 2 + 3）通过对称加密得到一个密匙（会话秘钥）</li><li>通过会话密匙对内容进行对称加密传输</li></ol><p>注：HTTPS传输随机数是非对称加密，通过验证之后使用对称加密。非对称加密需要两个秘钥（公钥和私钥），如果公钥对其加密，只有对应的私钥才能进行解密，如果私钥加密，与其对应的所有公钥都可以进行解密。</p><h2 id="REST-和-RESTFUL"><a href="#REST-和-RESTFUL" class="headerlink" title="REST 和 RESTFUL"></a>REST 和 RESTFUL</h2><blockquote><p>关于REST(representational state transfer) 表述性状态转移，使用web标准来做一些准则和约束</p></blockquote><p>REST原则：</p><ol><li>网络上所有的事物都被抽象为资源</li><li>每一个资源都有一个唯一的资源标识符（URI）</li><li>使用统一的接口处理资源请求（POST/PUT/GET/DELETE/HEAD）</li><li>所有的操作都是无状态的</li></ol><blockquote><p>RESTFUL:遵守了rest原则的web服务，是由rest派生出来的。</p></blockquote><p>在Restful之前的操作：</p><p><a href="http://127.0.0.1/user/query/1" target="_blank" rel="noopener">http://127.0.0.1/user/query/1</a> GET  根据用户id查询用户数据</p><p><a href="http://127.0.0.1/user/save" target="_blank" rel="noopener">http://127.0.0.1/user/save</a> POST 新增用户</p><p><a href="http://127.0.0.1/user/update" target="_blank" rel="noopener">http://127.0.0.1/user/update</a> POST 修改用户信息</p><p><a href="http://127.0.0.1/user/delete" target="_blank" rel="noopener">http://127.0.0.1/user/delete</a> GET/POST 删除用户信息</p><p>RESTful用法：</p><p><a href="http://127.0.0.1/user/1" target="_blank" rel="noopener">http://127.0.0.1/user/1</a> GET  根据用户id查询用户数据</p><p><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  POST 新增用户</p><p><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  PUT 修改用户信息</p><p><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  DELETE 删除用户信息</p><h2 id="RPC（remote-procedure-call）架构"><a href="#RPC（remote-procedure-call）架构" class="headerlink" title="RPC（remote procedure call）架构"></a>RPC（remote procedure call）架构</h2><p>RPC服务和HTTP服务还是存在不同点的，RPC的效率会更高，而HTTP服务开发迭代会更快。对于大型企业来说，内部子系统和接口较多，RPC的框架的好处就会显示出来，RPC是基于Socket,而socket真则是对TCP/IP的封装和应用。首先是长链接，不用每次请求三次握手，减少网络开销。其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。下面主要从一下三个方面来介绍RPC服务：分别是RPC架构，同步异步调用一集流行的RPC框架。</p><blockquote><p>RPC架构</p></blockquote><p>从图中我们可以清楚的看到，一个完整的RPC架构里面包含了四个核心组件，分别是Client，Server，Client stub，Server stub(stub可以理解为存根)</p><ol><li>客户端：服务的调用方。</li><li>服务端：真正的服务提供者。</li><li>客户端存根：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务端。</li><li>服务端存根：接受客户端发过来的消息，将消息解包，并调用本地方法。<br><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/RPC.png" alt="image-w100"></li></ol><p>RPC主要是应用与大型企业里面（系统繁多，业务线复杂），在实际的开发中，一般会这样做，项目中一般使用maven来管理，处理订单的系统服务，先声明它的所有的接口（这里指的是具体的interface），然后将整个项目打包一个jar包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边只需要引入二方库即可调用，这么做主要是为了减少客户端的jar包大小。另外将客户端和服务端进行解耦，提高程序的可移植性，</p><blockquote><p>同步调用和异步调用</p></blockquote><p>同步调用是指客户端等待服务端调用执行完成并返回结果。异步调用是指客户端不等待调用执行完成返回结果，通过回调函数等待接受返回结果的通知。如果客户端并不关心结果，则可以变成单向的调用。</p><blockquote><p>流行的RPC框架</p></blockquote><ol><li>gRPC是谷歌最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言，底层使用Netty框架支持。</li><li>Thrift是FaceBook一个开源项目，主要是跨语言的服务开发框架。它有一个代码生成器来对它说定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发即可。对于底层的RPC等都是透明的。但是对于用户来说需要学习特定领域语言特性，是需要花费一定成本的。</li><li>Dubbo是阿里集团开源的极为出名的RPC框架。在众多互联网和企业中广泛应用。协议和序列化框架都可以插拨是及其鲜明的特色。同样远程接口是基于Java Interface，并且依托于Spring框架方便开发，并且方便打包成单一文件，独立进行运行，和现在微服务概念一致。</li></ol><blockquote><p>RPC架构和REST对比</p></blockquote><p><img src="https://raw.githubusercontent.com/qiutiangang123/images/master/RPC&amp;REST.png" alt="image-w100"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络编程的一些基础概念介绍&lt;br&gt;
    
    </summary>
    
      <category term="network" scheme="https://qiutiangang123.github.io/categories/network/"/>
    
    
      <category term="netWork" scheme="https://qiutiangang123.github.io/tags/netWork/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号序列</title>
    <link href="https://qiutiangang123.github.io/2017/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    <id>https://qiutiangang123.github.io/2017/09/01/数据结构与算法/有效的括号序列/</id>
    <published>2017-09-01T13:00:02.000Z</published>
    <updated>2019-05-28T02:17:03.857Z</updated>
    
    <content type="html"><![CDATA[<p>有效的括号序列<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个括号序列，里面包含小括号，中括号和大括号。你要判断这个括号序列是否有效。有效的括号序列要求，每个左括号都必须有一个同类的右括号与它正确配对。另外，空字符串认为是有效的括号序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如说，给你的序列是：</span><br><span class="line"></span><br><span class="line">()[]&#123;&#125;</span><br><span class="line"></span><br><span class="line">小括号/中括号/大括号的左右括号都能正确配对，因此这是一个有效的括号序列。</span><br><span class="line"></span><br><span class="line">再比如说给你的序列是：</span><br><span class="line"></span><br><span class="line">([)]</span><br><span class="line"></span><br><span class="line">这里面虽然正好有一对小括号和一对中括号，但它们的顺序不对，括号间无法正确配对，因此这不是一个有效的括号序列。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用栈这种数据结构来解决此问题，如果遇到括号的左半部分，则压入栈，遇到右半部分则跟栈顶元素匹配，判断是否匹配。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有序的括号序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(checkStr(<span class="string">"([])"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str.charAt(i) == <span class="string">'('</span> || str.charAt(i) == <span class="string">'['</span> || str.charAt(i) == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">        stack.push(str.charAt(i));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">')'</span> &amp;&amp; stack.peek() != <span class="string">'('</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">']'</span> &amp;&amp; stack.peek() != <span class="string">'['</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">'&#125;'</span> &amp;&amp; stack.peek() != <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有效的括号序列&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://qiutiangang123.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm，数据结构，算法" scheme="https://qiutiangang123.github.io/tags/algorithm%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最大利润</title>
    <link href="https://qiutiangang123.github.io/2017/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <id>https://qiutiangang123.github.io/2017/08/30/数据结构与算法/买卖股票的最大利润/</id>
    <published>2017-08-30T13:00:02.000Z</published>
    <updated>2019-05-24T06:28:01.310Z</updated>
    
    <content type="html"><![CDATA[<p>买卖股票的最大利润<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组，其中第 i 个元素表示的是第 i 天的股票价格，你要计算出先买一股，然后再卖出它能获得的最大利润</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如说，给你的数组是：</span><br><span class="line"></span><br><span class="line">9, 3, 7, 5, 1, 8</span><br><span class="line"></span><br><span class="line">如果你在价格为 1 时买入并在价格为 8 时卖出，这时能获得最大的利润 7。</span><br><span class="line"></span><br><span class="line">再比如说给你的数组是：</span><br><span class="line"></span><br><span class="line">9, 8, 7, 6</span><br><span class="line"></span><br><span class="line">这时股票每天都在迭，不存在买入再卖出来获利的可能，因此没有交易，最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先声明一个链表指向给定的链表值，然后用一个链表指针指向声明的链表，判断指针的下一个是否与目标值项目，如果与目标值相同则指向下一个，循环此过程。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 买卖股票的最大利润</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] prices = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    System.out.println(getMaxValue(prices));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prices[i] &lt; buy) &#123;</span><br><span class="line">        buy = prices[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = Math.max(result, prices[i] - buy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;买卖股票的最大利润&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://qiutiangang123.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm，数据结构，算法" scheme="https://qiutiangang123.github.io/tags/algorithm%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
